subroutine output_patch(filename)
  character(LEN=80)::filename
  character(LEN=80)::fileloc
  character(LEN=30)::format
  integer::ilun

  ilun=11

  fileloc=TRIM(filename)
  format="(A)"
  open(unit=ilun,file=fileloc,form='formatted')
  write(ilun,format)"../patch/rt/frig_main/frig_Gbox/cloud_module.f90"
  write(ilun,format)"module cloud_module"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters,only:Msun"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)""
  write(ilun,format)"  ! TODO - CLEAN THIS OUT"
  write(ilun,format)""
  write(ilun,format)"  !initial temperature used for the isothermal run"
  write(ilun,format)"  real(dp)::temper"
  write(ilun,format)"  real(dp)::temper_iso"
  write(ilun,format)""
  write(ilun,format)"  !feedback from jet"
  write(ilun,format)"  logical:: jet = .false., rad_jet=.false. "
  write(ilun,format)"  real(dp)::Ucoef=1."
  write(ilun,format)"  real(dp):: mass_jet_sink=0. !mass above which a jets is included"
  write(ilun,format)""
  write(ilun,format)"  !Initial conditions parameter for the dense core"
  write(ilun,format)"  real(dp)::bx_bound=0."
  write(ilun,format)"  real(dp)::by_bound=0."
  write(ilun,format)"  real(dp)::bz_bound=0."
  write(ilun,format)"  real(dp)::turb=0."
  write(ilun,format)"  real(dp)::dens0=0."
  write(ilun,format)"  real(dp)::V0=0."
  write(ilun,format)"  real(dp)::Height0=0."
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  real(dp)::bl_fac=1.   !multiply calculated boxlen by this factor"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !Initial conditions parameters for the dense core"
  write(ilun,format)"  logical ::bb_test=.false. ! Activate Boss & Bodenheimer inital conditions instead of 1/R^2 density profile"
  write(ilun,format)"  logical ::uniform_bmag=.false. ! Activate uniform magnetic field initial conditions for BE-like initial density profile"
  write(ilun,format)"  real(dp)::mass_c=1.         !cloud mass in solar mass"
  write(ilun,format)"  real(dp)::contrast=100.d0   !density contrast (used when bb_test=.true.)"
  write(ilun,format)"  real(dp)::cont=1.           !density contrast (used when bb_test=.false.)"
  write(ilun,format)"  real(dp)::rap=1.            !axis ratio"
  write(ilun,format)"  real(dp)::ff_sct=1.         !freefall time / sound crossing time"
  write(ilun,format)"  real(dp)::ff_rt=1.          !freefall time / rotation time"
  write(ilun,format)"  real(dp)::ff_act=1.         !freefall time / Alfven crossing time"
  write(ilun,format)"  real(dp)::ff_vct=1.         !freefall time / Vrms crossing time"
  write(ilun,format)"  real(dp)::theta_mag=0.      !angle between magnetic field and rotation axis"
  write(ilun,format)"  real(dp)::thet_mag=0.      !angle between magnetic field and rotation axis"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: C2_vis=0.0d0 !Von Neumann & Richtmeyer artificial viscosity coefficient 3 en principe"
  write(ilun,format)"  real(dp):: alpha_dense_core=0.5d0"
  write(ilun,format)"  real(dp):: beta_dense_core=0.0d0"
  write(ilun,format)"  real(dp):: crit=0.0d0"
  write(ilun,format)"  real(dp):: delta_rho=0.0d0"
  write(ilun,format)"  real(dp):: Mach=0.0d0"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  real(dp)::Vshear=0.    !value of the shear in km/s"
  write(ilun,format)"  logical:: shear=.false.        !add Corriolis and centrifuge forces"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! PMS evolution related stuff"
  write(ilun,format)"  logical :: rt_feedback=.false.       ! take into account RT feedback"
  write(ilun,format)"  logical :: PMS_evol=.false.          ! Take into account PMS evolution subgrid model"
  write(ilun,format)"  logical :: Hosokawa_track=.false.    ! Take into account PMS evolution subgrid model"
  write(ilun,format)"  real(dp):: dt_lsink_update=50        ! frequency of the sink luminosity update with PMS evolution (in yr)"
  write(ilun,format)"  real(dp):: epsilonlib=0.0            ! Fraction of energy absorbed by the prostostars at the accretion shock"
  write(ilun,format)"  real(dp):: mprotostar=0.0009546*Msun ! initial mass of the protostar (1 Mjup)"
  write(ilun,format)"  real(dp):: rstar_init=2.5            ! Initial radius of the protostar in Rsun"
  write(ilun,format)"  integer :: modell=0"
  write(ilun,format)"  integer :: modrestart=0              ! name of model you want to restart from, this is an input"
  write(ilun,format)"  real(dp):: facc_star_lum=0.75d0      ! fraction of the accretion luminosity radiated by the sinks"
  write(ilun,format)"  real(dp):: facc_star=0.5d0           ! fraction of the sink accreted mass actually accreted by the star"
  write(ilun,format)"  integer::nmdot_PMS,nm_PMS,ndata_PMS"
  write(ilun,format)"  integer ,allocatable,dimension(:)::nb_ligne_PMS"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:,:)::data_PMS"
  write(ilun,format)""
  write(ilun,format)"  ! Scale time by a factor? (e.g. t_ff)"
  write(ilun,format)"  real(dp)::scale_tout=1d0"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end module cloud_module"
  write(ilun,format)""
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)""
  write(ilun,format)"subroutine calc_dmin(d_c)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  ! NOTE!! - IS THIS REALLY NECESSARY? - SAM GEEN OCTOBER 2015"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: d_c, cont_ic, dmin"
  write(ilun,format)""
  write(ilun,format)"  cont_ic = 10."
  write(ilun,format)"  dmin = d_c / cont / cont_ic"
  write(ilun,format)""
  write(ilun,format)"  if (myid == 1) then"
  write(ilun,format)"    write(*,*) 'dmin = ', dmin"
  write(ilun,format)"  endif"
  write(ilun,format)"end subroutine calc_dmin"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine calc_boxlen"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"!  use const"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  !this routine calculate boxlen"
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer :: i"
  write(ilun,format)"  real(dp):: pi"
  write(ilun,format)"  real(dp):: d_c,zeta"
  write(ilun,format)"  real(dp):: res_int,r_0,C_s"
  write(ilun,format)"  integer::  np"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp),save:: first"
  write(ilun,format)"  real(dp):: mu=1.4d0 ! NOTE - MUST BE THE SAME AS IN units.f90!!"
  write(ilun,format)"!  real(dp)::myid"
  write(ilun,format)""
  write(ilun,format)"!   myid=1"
  write(ilun,format)""
  write(ilun,format)"    if (first .eq. 0.) then"
  write(ilun,format)""
  write(ilun,format)"    pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"    call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"    scale_T2 = scale_T2 * mu"
  write(ilun,format)""
  write(ilun,format)"    !calculate the mass in code units (Msolar / Mparticle / pc^3"
  write(ilun,format)"    mass_c = mass_c * (2.d33 / (scale_d * scale_l**3) )"
  write(ilun,format)""
  write(ilun,format)"    !calculate the sound speed"
  write(ilun,format)"    C_s = sqrt( T2_star / scale_T2)"
  write(ilun,format)""
  write(ilun,format)"    !calculate  zeta=r_ext/r_0"
  write(ilun,format)"    zeta = sqrt(cont - 1.)"
  write(ilun,format)""
  write(ilun,format)"    !calculate an integral used to compute the cloud radius"
  write(ilun,format)"    np=1000"
  write(ilun,format)"    res_int=0."
  write(ilun,format)"    do i=1,np"
  write(ilun,format)"     res_int = res_int + log(1.+(zeta/np*i)**2) * zeta/np"
  write(ilun,format)"    enddo"
  write(ilun,format)"    res_int = zeta*log(1.+zeta**2) - res_int"
  write(ilun,format)""
  write(ilun,format)"    !now we determine the central density and the external cloud radius"
  write(ilun,format)"    !we have mass = 2 pi rho_c r_0^2 z_0 * res_int"
  write(ilun,format)"    !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)"
  write(ilun,format)"    !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta"
  write(ilun,format)"    !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0)"
  write(ilun,format)"    !which just state the ratio of freefall time over sound crossing time"
  write(ilun,format)"    !from these 2 formula, rho_c and r_0 are found to be:"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    r_0 = mass_c / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2"
  write(ilun,format)""
  write(ilun,format)"    d_c = mass_c / (2.*pi*rap*res_int) / r_0**3"
  write(ilun,format)""
  write(ilun,format)"    !it is equal to twice the length of the major axis"
  write(ilun,format)"    boxlen = r_0 * zeta * max(rap,1.) * 4."
  write(ilun,format)""
  write(ilun,format)"    ! Multiply boxlen by an extra factor"
  write(ilun,format)"    boxlen = bl_fac * boxlen"
  write(ilun,format)""
  write(ilun,format)"    if (myid == 1) then"
  write(ilun,format)"    write(*,*) '** Cloud parameters estimated in calc-boxlen **'"
  write(ilun,format)"    write(*,*) 'inner radius (pc) ', r_0"
  write(ilun,format)"    write(*,*) 'peak density (cc) ', d_c"
  write(ilun,format)"    write(*,*) 'total box length (pc) ', boxlen"
  write(ilun,format)"    write(*,*) 'cloud mass (code units) ', mass_c"
  write(ilun,format)"    write(*,*) 'boxlen (code units) ',boxlen"
  write(ilun,format)"    write(*,*)"
  write(ilun,format)"    endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    first=1."
  write(ilun,format)"    endif"
  write(ilun,format)""
  write(ilun,format)"    call calc_dmin(d_c)"
  write(ilun,format)""
  write(ilun,format)"end subroutine calc_boxlen"
  write(ilun,format)""
  write(ilun,format)"subroutine read_cloud_params(nml_ok)"
  write(ilun,format)""
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use feedback_module"
  write(ilun,format)"  use clfind_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"  logical::nml_ok"
  write(ilun,format)"  real(dp)::cellsize"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp),parameter::pcincm=3.086d18"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Namelist definitions"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  namelist/cloud_params/mass_c,rap,cont,ff_sct,ff_rt,ff_act,ff_vct,thet_mag &"
  write(ilun,format)"       & ,bl_fac,switch_solv,turb,Height0,dens0,bx_bound,by_bound,bz_bound,Vshear,shear"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist file"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=cloud_params,END=101)"
  write(ilun,format)"101 continue                                   ! No harm if no namelist"
  write(ilun,format)""
  write(ilun,format)"  ! Get some units out there"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"!  ! Calculate boxlen"
  write(ilun,format)"!  if (mass_c .gt. 0) then"
  write(ilun,format)"!     call calc_boxlen"
  write(ilun,format)"!  end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  write(*,*) 'shear ',shear"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! normalise the shear in code units "
  write(ilun,format)"  Vshear = Vshear*1.e5/scale_v"
  write(ilun,format)""
  write(ilun,format)"  !since boxlen is not known initialy we must multiply the"
  write(ilun,format)"  !refining parameters by boxlen here"
  write(ilun,format)"  x_refine = x_refine*boxlen"
  write(ilun,format)"  y_refine = y_refine*boxlen"
  write(ilun,format)"  z_refine = z_refine*boxlen"
  write(ilun,format)"  r_refine = r_refine*boxlen"
  write(ilun,format)""
  write(ilun,format)"  ! Set the sink formation threshold based on the Jeans criterion"
  write(ilun,format)"!  cellsize = boxlen * 0.5**nlevelmax * pcincm / scale_l"
  write(ilun,format)"!  n_sink = 881.0 / cellsize**2 ! Scaled to give 1e6 for 30pc/1024"
  write(ilun,format)"!  n_clfind = 0.1 * n_sink"
  write(ilun,format)"!  if(myid==1) write(*,*) 'SETTING n_sink, n_clfind TO', n_sink, n_clfind"
  write(ilun,format)""
  write(ilun,format)"  ! Feedback parameters"
  write(ilun,format)"  call read_feedback_params(nml_ok)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine read_cloud_params"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"subroutine boundary_frig(ilevel)"
  write(ilun,format)"  Use amr_commons      !, ONLY: dp,ndim,nvector,boxlen,t"
  write(ilun,format)"!  use hydro_parameters !, ONLY: nvar,boundary_var,gamma,bx_bound,by_bound,bz_bound,turb,dens0,V0"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !----------------------------------------------------------"
  write(ilun,format)"  ! This routine set up open boundary conditions which deals properly with div B "
  write(ilun,format)"  ! it uses the 2 last cells of the domain"
  write(ilun,format)"  !----------------------------------------------------------"
  write(ilun,format)"  integer::igrid,ngrid,ncache,i,ind,iskip,ix,iy,iz,j"
  write(ilun,format)"  integer::info,ibound,nx_loc,idim,neul=5"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,d,u,v,w,A,B,C"
  write(ilun,format)"  real(kind=8)::rho_max_loc,rho_max_all,epot_loc,epot_all"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:3),save::vv"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3)::q   ! Primitive variables"
  write(ilun,format)"  real(dp)::pi,time"
  write(ilun,format)"  integer ::ivar,jgrid,ind_cell_vois"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2,Cwnm"
  write(ilun,format)"  real(dp)::dx_min, fact, Emag,Emag0"
  write(ilun,format)""
  write(ilun,format)"! STG HACK - ignore if not MHD"
  write(ilun,format)"! TODO: Take boundary cleaner and use for non-MHD solver"
  write(ilun,format)"#ifndef SOLVERmhd"
  write(ilun,format)"  return"
  write(ilun,format)"#endif "
  write(ilun,format)""
  write(ilun,format)"  !!PH introduced a return to fix boundary conditions"
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  Cwnm = sqrt(8000./scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  pi=ACOS(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"  time = t * Cwnm / boxlen"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel in coarse cell units"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  "
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=dble(nx_loc)/boxlen"
  write(ilun,format)"  dx_loc=dx/scale"
  write(ilun,format)""
  write(ilun,format)"  dx_min = (0.5D0**levelmin)/scale"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  !-------------------------------------"
  write(ilun,format)"  ! Compute analytical velocity field"
  write(ilun,format)"  !-------------------------------------"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  "
  write(ilun,format)"  ! Loop over grids by vector sweeps"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather cell indices"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather cell centre positions"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Rescale position from code units to user units"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              xx(i,idim)=(xx(i,idim)-skip_loc(idim))/scale"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)""
  write(ilun,format)"       do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        ! STG HACK CHECK FOR BORKED"
  write(ilun,format)"        if (uold(ind_cell(i),1) .lt. 0d0) then"
  write(ilun,format)"           write(*,*) 'DENSITY < 0 BEFORE VELOCITY_FINE, OH NO', ind_cell(i)"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"        if (uold(ind_cell(i),5) .lt. 0d0) then"
  write(ilun,format)"           write(*,*) 'TOTAL CELL ENERGY < 0 BEFORE VELOCITY_FINE, OH NO', ind_cell(i)"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"        do j=5,8"
  write(ilun,format)"           if (isnan(uold(ind_cell(i),j))) then"
  write(ilun,format)"              write(*,*) 'VARIABLE IS NAN BEFORE VELOCITY_FINE, OH NO', ind_cell(i),j,uold(ind_cell(i),1)"
  write(ilun,format)"              call clean_stop"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !impose vanishing gradient conditions at the y  faces"
  write(ilun,format)"        if(  xx(i,2) .lt. 2.*dx_min ) then "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"             !look for the grid neigbour of the top father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),4))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"             !we must add 2*ngridmax because the neighbour of 3 (1) is 4 (2)"
  write(ilun,format)"           if(ind .eq. 3 .or. ind .eq. 4 .or. ind .eq. 7 .or. ind .eq. 8) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois - 2*ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 3 .or. ind .eq. 4 .or. ind .eq. 7 .or. ind .eq. 8) then "
  write(ilun,format)"              uold(ind_cell(i),nvar+2) = uold(ind_cell_vois,7)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),7)  = uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3) - uold(ind_cell(i),6) - uold(ind_cell(i),8) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),7) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),nvar+2) =  uold(ind_cell(i),nvar+1 ) + uold(ind_cell_vois,7) + uold(ind_cell(i),nvar+3) - uold(ind_cell(i),6)  - uold(ind_cell(i),8) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),7) =  uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3)  -uold(ind_cell(i),6) - uold(ind_cell(i),8) "
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        if(  xx(i,2) .gt. boxlen-2.*dx_min ) then "
  write(ilun,format)"             !look for the grid neigbour of the bottom father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),3))"
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"             !we must add 2*ngridmax because the neighbour of 3 (4) is 1 (2)"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 2 .or. ind .eq. 5 .or. ind .eq. 6) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois + 2*ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 2 .or. ind .eq. 5 .or. ind .eq. 6) then "
  write(ilun,format)"              uold(ind_cell(i),7) = uold(ind_cell_vois,nvar+2)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),nvar+2)  = uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8) - uold(ind_cell(i),nvar+1) - uold(ind_cell(i),nvar+3) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),10) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),7) =  uold(ind_cell(i),6 ) + uold(ind_cell_vois,nvar+2) + uold(ind_cell(i),8) - uold(ind_cell(i),nvar+1)  - uold(ind_cell(i),nvar+3) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),nvar+2) =  uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8)  -uold(ind_cell(i),nvar+1) - uold(ind_cell(i),nvar+3) "
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        if(  xx(i,3) .lt. 2.*dx_min ) then "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"             !look for the grid neigbour of the bottom father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),6))"
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"             !we must add 2*ngridmax because the neighbour of 5 (6) is 1 (2)"
  write(ilun,format)"           if(ind .eq. 5 .or. ind .eq. 6 .or. ind .eq. 7 .or. ind .eq. 8) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois - 4*ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 5 .or. ind .eq. 6 .or. ind .eq. 7 .or. ind .eq. 8) then "
  write(ilun,format)"              uold(ind_cell(i),nvar+3) = uold(ind_cell_vois,8)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),8)  = uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3) - uold(ind_cell(i),6) - uold(ind_cell(i),7) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),8) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),nvar+3) =  uold(ind_cell(i), nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell_vois,8) - uold(ind_cell(i),6)  - uold(ind_cell(i),7) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),8) =  uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3)  -uold(ind_cell(i),6) - uold(ind_cell(i),7) "
  write(ilun,format)""
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        if(  xx(i,3) .gt. boxlen-2.*dx_min ) then "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"             !look for the grid neigbour of the bottom father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),5))"
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"             !we must add 2*ngridmax because the neighbour of 1 (2) is 5 (6)"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 2 .or. ind .eq. 3 .or. ind .eq. 4) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois + 4*ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 2 .or. ind .eq. 3 .or. ind .eq. 4) then "
  write(ilun,format)"              uold(ind_cell(i),8) = uold(ind_cell_vois,nvar+3)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),nvar+3)  = uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8) - uold(ind_cell(i),nvar+1) - uold(ind_cell(i),nvar+2) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),nvar+3) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),8) =  uold(ind_cell(i), 6) + uold(ind_cell(i),7) + uold(ind_cell_vois,nvar+3) - uold(ind_cell(i),nvar+1)  - uold(ind_cell(i),nvar+2) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),nvar+3) =  uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8)  -uold(ind_cell(i),nvar+1) - uold(ind_cell(i),nvar+2) "
  write(ilun,format)""
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"        ! STG HACK CHECK FOR BORKED"
  write(ilun,format)"        if (uold(ind_cell(i),5) .lt. 0d0) then"
  write(ilun,format)"           write(*,*) 'TOTAL ENERGY < 0 AFTER VELOCITY_FINE, OH NO', ind_cell(i)"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"        do j=5,8"
  write(ilun,format)"           if (isnan(uold(ind_cell(i),j))) then"
  write(ilun,format)"              write(*,*) 'VARIABLE IS NAN AFTER VELOCITY_FINE, OH NO', ind_cell(i),j"
  write(ilun,format)"              call clean_stop"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       "
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"end subroutine boundary_frig"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"../patch/rt/frig_main/frig_Gbox/condinit.f90"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine condinit(x,u,dx,nn)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::nn                            ! Number of cells"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3)::u ! Conservative variables"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine generates initial conditions for RAMSES."
  write(ilun,format)"  ! Positions are in user units:"
  write(ilun,format)"  ! x(i,1:3) are in [0,boxlen]**ndim."
  write(ilun,format)"  ! U is the conservative variable vector. Conventions are here:"
  write(ilun,format)"  ! U(i,1): d, U(i,2:4): d.u,d.v,d.w, U(i,5): E, U(i,6:8): Bleft, "
  write(ilun,format)"  ! U(i,nvar+1:nvar+3): Bright"
  write(ilun,format)"  ! Q is the primitive variable vector. Conventions are here:"
  write(ilun,format)"  ! Q(i,1): d, Q(i,2:4):u,v,w, Q(i,5): P, Q(i,6:8): Bleft, "
  write(ilun,format)"  ! Q(i,nvar+1:nvar+3): Bright"
  write(ilun,format)"  ! If nvar > 8, remaining variables (9:nvar) are treated as passive"
  write(ilun,format)"  ! scalars in the hydro solver."
  write(ilun,format)"  ! U(:,:) and Q(:,:) are in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::ivar,i,j,k"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3),save::q   ! Primitive variables"
  write(ilun,format)"  real(dp)::pi,xx,yy"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2,mag_norm"
  write(ilun,format)""
  write(ilun,format)"  real(dp),save:: first"
  write(ilun,format)"  real(dp),dimension(1:3,1:100,1:100,1:100),save::q_idl"
  write(ilun,format)"  real(dp),save::vx_tot,vy_tot,vz_tot,vx2_tot,vy2_tot,vz2_tot,vx,vy,vz,v_rms"
  write(ilun,format)"  integer,save:: n_size"
  write(ilun,format)"  integer:: ind_i, ind_j, ind_k"
  write(ilun,format)"  real(dp),save:: ind,seed1,seed2,seed3,xi,yi,zi"
  write(ilun,format)"  real(dp):: n_total"
  write(ilun,format)"  real(dp):: u_rf"
  write(ilun,format)"!  real(dp)::Vshear"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Call built-in initial condition generator"
  write(ilun,format)"!  call region_condinit(x,q,dx,nn)"
  write(ilun,format)""
  write(ilun,format)"  ! Add here, if you wish, some user-defined initial conditions"
  write(ilun,format)"  ! ........"
  write(ilun,format)"  pi=ACOS(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  mass_sph = 10. * (boxlen*(0.5**levelmin))**3"
  write(ilun,format)""
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"!  write(*,*) 'Echelle de temperature',scale_T2"
  write(ilun,format)"!  write(*,*) 'temperature du code',8000./scale_T2"
  write(ilun,format)"!  write(*,*) 'dens0 ',dens0"
  write(ilun,format)""
  write(ilun,format)"   mag_norm = sqrt(1.*8000./scale_T2*2.*1.5)"
  write(ilun,format)""
  write(ilun,format)"   if( first .eq. 0.) then "
  write(ilun,format)""
  write(ilun,format)"      temper = (8000. / scale_T2 ) / dens0"
  write(ilun,format)""
  write(ilun,format)"!     if (isothermal) temper = temper_iso / scale_T2"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    !now read the turbulent velocity field used as initial condition"
  write(ilun,format)"    if( myid ==1) write(*,*) 'Read the file which contains the initial turbulent velocity field'"
  write(ilun,format)"    open(20,file='ramses.data',form='formatted')"
  write(ilun,format)"    read(20,*) n_size, ind, seed1,seed2,seed3"
  write(ilun,format)""
  write(ilun,format)"     if(n_size .ne. 100) then "
  write(ilun,format)"       write(*,*) 'Unextected field size'"
  write(ilun,format)"       stop"
  write(ilun,format)"     endif"
  write(ilun,format)"     "
  write(ilun,format)"     v_rms=0."
  write(ilun,format)""
  write(ilun,format)"     vx_tot  = 0."
  write(ilun,format)"     vy_tot  = 0."
  write(ilun,format)"     vz_tot  = 0."
  write(ilun,format)"     vx2_tot = 0."
  write(ilun,format)"     vy2_tot = 0."
  write(ilun,format)"     vz2_tot = 0."
  write(ilun,format)""
  write(ilun,format)"     do k=1,n_size"
  write(ilun,format)"     do j=1,n_size"
  write(ilun,format)"     do i=1,n_size"
  write(ilun,format)"        read(20,*)xi,yi,zi,vx,vy,vz"
  write(ilun,format)"        q_idl(1,i,j,k) = vx"
  write(ilun,format)"        q_idl(2,i,j,k) = vy"
  write(ilun,format)"        q_idl(3,i,j,k) = vz"
  write(ilun,format)""
  write(ilun,format)"        xi = boxlen*((i-0.5)/n_size-0.5)"
  write(ilun,format)"        yi = boxlen*((j-0.5)/n_size-0.5)"
  write(ilun,format)"        zi = boxlen*((k-0.5)/n_size-0.5)"
  write(ilun,format)""
  write(ilun,format)"         vx_tot = vx_tot + vx"
  write(ilun,format)"         vy_tot = vy_tot + vy"
  write(ilun,format)"         vz_tot = vz_tot + vz"
  write(ilun,format)""
  write(ilun,format)"         vx2_tot = vx2_tot + vx**2"
  write(ilun,format)"         vy2_tot = vy2_tot + vy**2"
  write(ilun,format)"         vz2_tot = vz2_tot + vz**2"
  write(ilun,format)""
  write(ilun,format)"     enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"    close(20)"
  write(ilun,format)""
  write(ilun,format)"    n_total = n_size**3"
  write(ilun,format)""
  write(ilun,format)"     vx_tot = vx_tot / n_total"
  write(ilun,format)"     vy_tot = vy_tot / n_total"
  write(ilun,format)"     vz_tot = vz_tot / n_total"
  write(ilun,format)""
  write(ilun,format)"     vx2_tot = vx2_tot / n_total"
  write(ilun,format)"     vy2_tot = vy2_tot / n_total"
  write(ilun,format)"     vz2_tot = vz2_tot / n_total"
  write(ilun,format)""
  write(ilun,format)"     v_rms = sqrt( vx2_tot-vx_tot**2 + vy2_tot-vy_tot**2 + vz2_tot-vz_tot**2 ) "
  write(ilun,format)""
  write(ilun,format)"     "
  write(ilun,format)""
  write(ilun,format)"     !calculate now the coefficient by which the turbulence velocity needs"
  write(ilun,format)"     !to be multiplied "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     !turb is in km/s ,  1.d5 converts it in cm/s"
  write(ilun,format)"     v_rms =  turb*1.d5 / scale_v / v_rms"
  write(ilun,format)""
  write(ilun,format)"    if (myid ==1 ) write(*,*), 'turb ', turb, ', v_rms ', v_rms , 'first ',first"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    100 format(i5,4e10.5)"
  write(ilun,format)"    101 format(6e10.5)"
  write(ilun,format)"    102 format(i5)"
  write(ilun,format)""
  write(ilun,format)"    if (myid ==1)  write(*,*) 'Reading achieved'"
  write(ilun,format)"    first = 1."
  write(ilun,format)"   endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     !write(*,*), 'turb ', turb, ', v_rms ', v_rms , 'dens_0, mag_norm ',dens0,mag_norm"
  write(ilun,format)""
  write(ilun,format)"  do i=1,nn"
  write(ilun,format)""
  write(ilun,format)"     x(i,1) = x(i,1) - 0.5*boxlen"
  write(ilun,format)"     x(i,2) = x(i,2) - 0.5*boxlen"
  write(ilun,format)"     x(i,3) = x(i,3) - 0.5*boxlen"
  write(ilun,format)""
  write(ilun,format)"     !Bx component "
  write(ilun,format)"     q(i,6     ) = bx_bound * mag_norm * exp(-x(i,3)**2/(2.*Height0**2)) !exponential profile along z"
  write(ilun,format)"     q(i,nvar+1) = q(i,6)"
  write(ilun,format)""
  write(ilun,format)"     !By component"
  write(ilun,format)"     q(i,7     ) =  by_bound * mag_norm"
  write(ilun,format)"     q(i,nvar+2) =  by_bound * mag_norm"
  write(ilun,format)""
  write(ilun,format)"     !Bz component"
  write(ilun,format)"     q(i,8     ) =  bz_bound * mag_norm"
  write(ilun,format)"     q(i,nvar+3) =  bz_bound * mag_norm"
  write(ilun,format)""
  write(ilun,format)"     !en cgs"
  write(ilun,format)"        !densite"
  write(ilun,format)"     q(i,1) = dens0 * max(exp(-x(i,3)**2/(2.*Height0**2)),1.d-2) !exponential profile along z"
  write(ilun,format)"        !pression"
  write(ilun,format)"     q(i,5) =  q(i,1)*temper !(8000. / scale_T2 )"
  write(ilun,format)""
  write(ilun,format)"!     temper = q(i,5) / q(i,1)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       !initialise the turbulent velocity field"
  write(ilun,format)"       !make a zero order interpolation (should be improved)"
  write(ilun,format)"       ind_i = int((x(i,1)/boxlen+0.5)*n_size)+1"
  write(ilun,format)"       ind_j = int((x(i,2)/boxlen+0.5)*n_size)+1"
  write(ilun,format)"       ind_k = int((x(i,3)/boxlen+0.5)*n_size)+1"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       if( ind_i .lt. 1 .or. ind_i .gt. n_size) write(*,*) 'ind_i ',ind_i,boxlen,x(i,1),n_size"
  write(ilun,format)"       if( ind_j .lt. 1 .or. ind_j .gt. n_size) write(*,*) 'ind_j ',ind_j"
  write(ilun,format)"       if( ind_k .lt. 1 .or. ind_k .gt. n_size) write(*,*) 'ind_k ',ind_k"
  write(ilun,format)""
  write(ilun,format)"       q(i,2) = v_rms*(q_idl(1,ind_i,ind_j,ind_k)-vx_tot)"
  write(ilun,format)"       q(i,3) = v_rms*(q_idl(2,ind_i,ind_j,ind_k)-vy_tot)"
  write(ilun,format)"       q(i,4) = v_rms*(q_idl(3,ind_i,ind_j,ind_k)-vz_tot)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       !now add a shear along the x-axis"
  write(ilun,format)""
  write(ilun,format)"       q(i,2) = q(i,2) + Vshear*(x(i,2)/boxlen)!*max(exp(-x(i,3)**2/(2.*Height0**2)),1.e-2) "
  write(ilun,format)""
  write(ilun,format)"       ! CC 05/17 Nordita : Roberts flow"
  write(ilun,format)"       !u_rf = 20. "
  write(ilun,format)"       !q(i,2) = u_rf*sin(2.*pi*x(i,2)/boxlen)*cos(2.*pi*x(i,1)/boxlen)"
  write(ilun,format)"       !q(i,3) = u_rf*sin(2.*pi*x(i,1)/boxlen)*cos(2.*pi*x(i,2)/boxlen)"
  write(ilun,format)"       !q(i,4) = u_rf*(1./sqrt(2.))*cos(2.*pi*x(i,1)/boxlen)*cos(2.*pi*x(i,2)/boxlen)"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Convert primitive to conservative variables"
  write(ilun,format)"  ! density -> density"
  write(ilun,format)"  u(1:nn,1)=q(1:nn,1)"
  write(ilun,format)"  ! velocity -> momentum"
  write(ilun,format)"  u(1:nn,2)=q(1:nn,1)*q(1:nn,2)"
  write(ilun,format)"  u(1:nn,3)=q(1:nn,1)*q(1:nn,3)"
  write(ilun,format)"  u(1:nn,4)=q(1:nn,1)*q(1:nn,4)"
  write(ilun,format)"  ! kinetic energy"
  write(ilun,format)"  u(1:nn,5)=0.0d0"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,2)**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,3)**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,4)**2"
  write(ilun,format)"  ! pressure -> total fluid energy"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+q(1:nn,5)/(gamma-1.0d0)"
  write(ilun,format)"  ! magnetic energy -> total fluid energy"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,6)+q(1:nn,nvar+1))**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,7)+q(1:nn,nvar+2))**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,8)+q(1:nn,nvar+3))**2"
  write(ilun,format)"  u(1:nn,6:8)=q(1:nn,6:8)"
  write(ilun,format)"  u(1:nn,nvar+1:nvar+3)=q(1:nn,nvar+1:nvar+3)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  ! radiative pressure -> radiative energy"
  write(ilun,format)"  ! radiative energy -> total fluid energy"
  write(ilun,format)"  do ivar=1,nener"
  write(ilun,format)"     u(1:nn,8+ivar)=q(1:nn,8+ivar)/(gamma_rad(ivar)-1.0d0)"
  write(ilun,format)"     u(1:nn,5)=u(1:nn,5)+u(1:nn,8+ivar)"
  write(ilun,format)"  enddo"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NVAR>8+NENER"
  write(ilun,format)"  ! passive scalars"
  write(ilun,format)"  do ivar=9+nener,nvar"
  write(ilun,format)"     u(1:nn,ivar)=q(1:nn,1)*q(1:nn,ivar)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine condinit"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine velana(x,v,dx,t,ncell)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters  "
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ncell                         ! Size of input arrays"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp)::t                             ! Current time"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:3)::v    ! Velocity field"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine computes the user defined velocity fields."
  write(ilun,format)"  ! x(i,1:ndim) are cell center position in [0,boxlen] (user units)."
  write(ilun,format)"  ! v(i,1:3) is the imposed 3-velocity in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::i"
  write(ilun,format)"  real(dp)::xx,yy,zz,vx,vy,vz,rr,tt,omega,aa,twopi"
  write(ilun,format)""
  write(ilun,format)"  ! Add here, if you wish, some user-defined initial conditions"
  write(ilun,format)"  aa=1.0"
  write(ilun,format)"  twopi=2d0*ACOS(-1d0)"
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)""
  write(ilun,format)"     xx=x(i,1)"
  write(ilun,format)"#if NDIM > 1"
  write(ilun,format)"     yy=x(i,2)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM > 2"
  write(ilun,format)"     zz=x(i,3)"
  write(ilun,format)"#endif"
  write(ilun,format)"     ! ABC"
  write(ilun,format)"     vx=aa*(cos(twopi*yy)+sin(twopi*zz))"
  write(ilun,format)"     vy=aa*(sin(twopi*xx)+cos(twopi*zz))"
  write(ilun,format)"     vz=aa*(cos(twopi*xx)+sin(twopi*yy))"
  write(ilun,format)""
  write(ilun,format)"!!      ! 1D advection test"
  write(ilun,format)"!!      vx=1.0_dp"
  write(ilun,format)"!!      vy=0.0_dp"
  write(ilun,format)"!!      vz=0.0_dp"
  write(ilun,format)""
  write(ilun,format)"!!      ! Ponomarenko"
  write(ilun,format)"!!      xx=xx-boxlen/2.0"
  write(ilun,format)"!!      yy=yy-boxlen/2.0"
  write(ilun,format)"!!      rr=sqrt(xx**2+yy**2)"
  write(ilun,format)"!!      if(yy>0)then"
  write(ilun,format)"!!         tt=acos(xx/rr)"
  write(ilun,format)"!!      else"
  write(ilun,format)"!!         tt=-acos(xx/rr)+twopi"
  write(ilun,format)"!!      endif"
  write(ilun,format)"!!      if(rr<1.0)then"
  write(ilun,format)"!!         omega=0.609711"
  write(ilun,format)"!!         vz=0.792624"
  write(ilun,format)"!!      else"
  write(ilun,format)"!!         omega=0.0"
  write(ilun,format)"!!         vz=0.0"
  write(ilun,format)"!!      endif"
  write(ilun,format)"!!      vx=-sin(tt)*rr*omega"
  write(ilun,format)"!!      vy=+cos(tt)*rr*omega"
  write(ilun,format)"     "
  write(ilun,format)"     v(i,1)=vx"
  write(ilun,format)"#if NDIM > 1"
  write(ilun,format)"     v(i,2)=vy"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM > 2"
  write(ilun,format)"     v(i,3)=vz"
  write(ilun,format)"#endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine velana"
  write(ilun,format)"../patch/rt/frig_main/frig_Gbox/rho_ana.f90"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"subroutine rho_ana(x,d,dx,ncell)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ncell                         ! Number of cells"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector)       ::d ! Density"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine generates analytical Poisson source term."
  write(ilun,format)"  ! Positions are in user units:"
  write(ilun,format)"  ! x(i,1:3) are in [0,boxlen]**ndim."
  write(ilun,format)"  ! d(i) is the density field in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::i"
  write(ilun,format)"  real(dp)::dmass,emass,xmass,ymass,zmass,rr,rx,ry,rz,dd"
  write(ilun,format)"  real(dp):: a1,a2,z0,a1_rho,a2_rho,G,mp,pi,Myear_s"
  write(ilun,format)""
  write(ilun,format)"!!  emass=gravity_params(1) ! Softening length"
  write(ilun,format)"!!  xmass=gravity_params(2) ! Point mass coordinates"
  write(ilun,format)"!!  ymass=gravity_params(3)"
  write(ilun,format)"!!  zmass=gravity_params(4)"
  write(ilun,format)"!!  dmass=1.0/(emass*(1.0+emass)**2)"
  write(ilun,format)""
  write(ilun,format)"  pi=ACOS(-1.)"
  write(ilun,format)"  mp = 1.660531d-24  ! gramme"
  write(ilun,format)"  G = 6.67d-8"
  write(ilun,format)"  Myear_s=1.d6*365.*3600.*24."
  write(ilun,format)""
  write(ilun,format)"!! add the vertical galactic gravitational field"
  write(ilun,format)"!! Kuijken & Gilmore 1989 taken from Joung & MacLow (2006)"
  write(ilun,format)"  a1=1.42d-3 !!in kpc Myr-2 "
  write(ilun,format)"  a2=5.49d-4 !!in Myr-2"
  write(ilun,format)"  z0=0.18*1.d3 !!scale height in pc"
  write(ilun,format)""
  write(ilun,format)"!!the gravitational field is given by"
  write(ilun,format)"!! g = -a1 z / sqrt(z^2+z0^2) - a2 z"
  write(ilun,format)"!! rho = 1/(4piG) (a1 / z0) ( (z/z0)^2 + 1)^(-3/2) + a2/(4piG) "
  write(ilun,format)""
  write(ilun,format)"  a1_rho = a1 / (4.*pi*G) / (z0/1.d3) / (Myear_s)**2 / mp"
  write(ilun,format)""
  write(ilun,format)"  a2_rho = a2 / (4.*pi*G)             / (Myear_s)**2 / mp"
  write(ilun,format)""
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     rz=x(i,3)-0.5*boxlen"
  write(ilun,format)"     d(i)= a1_rho / (1.+(rz/z0)**2)**(1.5) + a2_rho"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine rho_ana"
  write(ilun,format)"../patch/rt/frig_main/cloud_module.f90"
  write(ilun,format)"module cloud_module"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters,only:Msun"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)""
  write(ilun,format)"  !initial temperature used for the isothermal run"
  write(ilun,format)"  real(dp)::temper"
  write(ilun,format)"  real(dp)::temper_iso"
  write(ilun,format)""
  write(ilun,format)"  !feedback from jet"
  write(ilun,format)"  logical:: jet = .false., rad_jet=.false. "
  write(ilun,format)"  real(dp)::Ucoef=1."
  write(ilun,format)"  real(dp):: mass_jet_sink=0. !mass above which a jets is included"
  write(ilun,format)""
  write(ilun,format)"  !Initial conditions parameter for the dense core"
  write(ilun,format)"  real(dp)::bx_bound=0."
  write(ilun,format)"  real(dp)::by_bound=0."
  write(ilun,format)"  real(dp)::bz_bound=0."
  write(ilun,format)"  real(dp)::turb=0."
  write(ilun,format)"  real(dp)::dens0=0."
  write(ilun,format)"  real(dp)::V0=0."
  write(ilun,format)"  real(dp)::Height0=0."
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  real(dp)::bl_fac=1.   !multiply calculated boxlen by this factor"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !Initial conditions parameters for the dense core"
  write(ilun,format)"  logical ::bb_test=.false. ! Activate Boss & Bodenheimer inital conditions instead of 1/R^2 density profile"
  write(ilun,format)"  logical ::uniform_bmag=.false. ! Activate uniform magnetic field initial conditions for BE-like initial density profile"
  write(ilun,format)"  real(dp)::mass_c=1.         !cloud mass in solar mass"
  write(ilun,format)"  real(dp)::contrast=100.d0   !density contrast (used when bb_test=.true.)"
  write(ilun,format)"  real(dp)::cont=1.           !density contrast (used when bb_test=.false.)"
  write(ilun,format)"  real(dp)::rap=1.            !axis ratio"
  write(ilun,format)"  real(dp)::ff_sct=1.         !freefall time / sound crossing time"
  write(ilun,format)"  real(dp)::ff_rt=1.          !freefall time / rotation time"
  write(ilun,format)"  real(dp)::ff_act=1.         !freefall time / Alfven crossing time"
  write(ilun,format)"  real(dp)::ff_vct=1.         !freefall time / Vrms crossing time"
  write(ilun,format)"  real(dp)::theta_mag=0.      !angle between magnetic field and rotation axis"
  write(ilun,format)"  real(dp)::thet_mag=0.      !angle between magnetic field and rotation axis"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: C2_vis=0.0d0 !Von Neumann & Richtmeyer artificial viscosity coefficient 3 en principe"
  write(ilun,format)"  real(dp):: alpha_dense_core=0.5d0"
  write(ilun,format)"  real(dp):: beta_dense_core=0.0d0"
  write(ilun,format)"  real(dp):: crit=0.0d0"
  write(ilun,format)"  real(dp):: delta_rho=0.0d0"
  write(ilun,format)"  real(dp):: Mach=0.0d0"
  write(ilun,format)""
  write(ilun,format)"  ! PMS evolution related stuff"
  write(ilun,format)"  logical :: rt_feedback=.false.       ! take into account RT feedback"
  write(ilun,format)"  logical :: PMS_evol=.false.          ! Take into account PMS evolution subgrid model"
  write(ilun,format)"  logical :: Hosokawa_track=.false.    ! Take into account PMS evolution subgrid model"
  write(ilun,format)"  real(dp):: dt_lsink_update=50        ! frequency of the sink luminosity update with PMS evolution (in yr)"
  write(ilun,format)"  real(dp):: epsilonlib=0.0            ! Fraction of energy absorbed by the prostostars at the accretion shock"
  write(ilun,format)"  real(dp):: mprotostar=0.0009546*Msun ! initial mass of the protostar (1 Mjup)"
  write(ilun,format)"  real(dp):: rstar_init=2.5            ! Initial radius of the protostar in Rsun"
  write(ilun,format)"  integer :: modell=0"
  write(ilun,format)"  integer :: modrestart=0              ! name of model you want to restart from, this is an input"
  write(ilun,format)"  real(dp):: facc_star_lum=0.75d0      ! fraction of the accretion luminosity radiated by the sinks"
  write(ilun,format)"  real(dp):: facc_star=0.5d0           ! fraction of the sink accreted mass actually accreted by the star"
  write(ilun,format)"  integer::nmdot_PMS,nm_PMS,ndata_PMS"
  write(ilun,format)"  integer ,allocatable,dimension(:)::nb_ligne_PMS"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:,:)::data_PMS"
  write(ilun,format)""
  write(ilun,format)"  ! Scale time by a factor? (e.g. t_ff)"
  write(ilun,format)"  real(dp)::scale_tout=1d0"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end module cloud_module"
  write(ilun,format)""
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)""
  write(ilun,format)"subroutine calc_dmin(d_c)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: d_c, cont_ic, dmin"
  write(ilun,format)""
  write(ilun,format)"  cont_ic = 10."
  write(ilun,format)"  dmin = d_c / cont / cont_ic"
  write(ilun,format)""
  write(ilun,format)"  if (myid == 1) then"
  write(ilun,format)"    write(*,*) 'dmin = ', dmin"
  write(ilun,format)"  endif"
  write(ilun,format)"end subroutine calc_dmin"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine calc_boxlen"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"!  use const"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  !this routine calculate boxlen"
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer :: i"
  write(ilun,format)"  real(dp):: pi"
  write(ilun,format)"  real(dp):: d_c,zeta"
  write(ilun,format)"  real(dp):: res_int,r_0,C_s"
  write(ilun,format)"  integer::  np"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp),save:: first"
  write(ilun,format)"  real(dp):: mu=1.4d0 ! NOTE - MUST BE THE SAME AS IN units.f90!!"
  write(ilun,format)"!  real(dp)::myid"
  write(ilun,format)""
  write(ilun,format)"!   myid=1"
  write(ilun,format)""
  write(ilun,format)"    if (first .eq. 0.) then"
  write(ilun,format)""
  write(ilun,format)"    pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"    call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"    scale_T2 = scale_T2 * mu"
  write(ilun,format)""
  write(ilun,format)"    !calculate the mass in code units (Msolar / Mparticle / pc^3"
  write(ilun,format)"    mass_c = mass_c * (2.d33 / (scale_d * scale_l**3) )"
  write(ilun,format)""
  write(ilun,format)"    !calculate the sound speed"
  write(ilun,format)"    C_s = sqrt( T2_star / scale_T2)"
  write(ilun,format)""
  write(ilun,format)"    !calculate  zeta=r_ext/r_0"
  write(ilun,format)"    zeta = sqrt(cont - 1.)"
  write(ilun,format)""
  write(ilun,format)"    !calculate an integral used to compute the cloud radius"
  write(ilun,format)"    np=1000"
  write(ilun,format)"    res_int=0."
  write(ilun,format)"    do i=1,np"
  write(ilun,format)"     res_int = res_int + log(1.+(zeta/np*i)**2) * zeta/np"
  write(ilun,format)"    enddo"
  write(ilun,format)"    res_int = zeta*log(1.+zeta**2) - res_int"
  write(ilun,format)""
  write(ilun,format)"    !now we determine the central density and the external cloud radius"
  write(ilun,format)"    !we have mass = 2 pi rho_c r_0^2 z_0 * res_int"
  write(ilun,format)"    !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)"
  write(ilun,format)"    !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta"
  write(ilun,format)"    !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0)"
  write(ilun,format)"    !which just state the ratio of freefall time over sound crossing time"
  write(ilun,format)"    !from these 2 formula, rho_c and r_0 are found to be:"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    r_0 = mass_c / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2"
  write(ilun,format)""
  write(ilun,format)"    d_c = mass_c / (2.*pi*rap*res_int) / r_0**3"
  write(ilun,format)""
  write(ilun,format)"    !it is equal to twice the length of the major axis"
  write(ilun,format)"    boxlen = r_0 * zeta * max(rap,1.) * 4."
  write(ilun,format)""
  write(ilun,format)"    ! Multiply boxlen by an extra factor"
  write(ilun,format)"    boxlen = bl_fac * boxlen"
  write(ilun,format)""
  write(ilun,format)"    if (myid == 1) then"
  write(ilun,format)"    write(*,*) '** Cloud parameters estimated in calc-boxlen **'"
  write(ilun,format)"    write(*,*) 'inner radius (pc) ', r_0"
  write(ilun,format)"    write(*,*) 'peak density (cc) ', d_c"
  write(ilun,format)"    write(*,*) 'total box length (pc) ', boxlen"
  write(ilun,format)"    write(*,*) 'cloud mass (code units) ', mass_c"
  write(ilun,format)"    write(*,*) 'boxlen (code units) ',boxlen"
  write(ilun,format)"    write(*,*)"
  write(ilun,format)"    endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    first=1."
  write(ilun,format)"    endif"
  write(ilun,format)""
  write(ilun,format)"    call calc_dmin(d_c)"
  write(ilun,format)""
  write(ilun,format)"end subroutine calc_boxlen"
  write(ilun,format)""
  write(ilun,format)"subroutine read_cloud_params(nml_ok)"
  write(ilun,format)""
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use feedback_module"
  write(ilun,format)"  use clfind_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"  logical::nml_ok"
  write(ilun,format)"  real(dp)::cellsize"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp),parameter::pcincm=3.086d18"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Namelist definitions"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  namelist/cloud_params/mass_c,rap,cont,ff_sct,ff_rt,ff_act,ff_vct,thet_mag &"
  write(ilun,format)"       & ,bl_fac, scale_tout"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist file"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=cloud_params,END=101)"
  write(ilun,format)"101 continue                                   ! No harm if no namelist"
  write(ilun,format)""
  write(ilun,format)"  ! Get some units out there"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Calculate boxlen"
  write(ilun,format)"  if (mass_c .gt. 0) then"
  write(ilun,format)"     call calc_boxlen"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !since boxlen is not known initialy we must multiply the"
  write(ilun,format)"  !refining parameters by boxlen here"
  write(ilun,format)"  x_refine = x_refine*boxlen"
  write(ilun,format)"  y_refine = y_refine*boxlen"
  write(ilun,format)"  z_refine = z_refine*boxlen"
  write(ilun,format)"  r_refine = r_refine*boxlen"
  write(ilun,format)""
  write(ilun,format)"  ! Also scale any RT sources"
  write(ilun,format)"  rt_src_x_center = rt_src_x_center * boxlen"
  write(ilun,format)"  rt_src_y_center = rt_src_y_center * boxlen"
  write(ilun,format)"  rt_src_z_center = rt_src_z_center * boxlen"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Set the sink formation threshold based on the Jeans criterion"
  write(ilun,format)"  cellsize = boxlen * 0.5**nlevelmax * pcincm / scale_l"
  write(ilun,format)"  n_sink = 881.0 / cellsize**2 ! Scaled to give 1e6 for 30pc/1024"
  write(ilun,format)"  n_clfind = 0.1 * n_sink"
  write(ilun,format)"  if(myid==1) write(*,*) 'SETTING n_sink, n_clfind TO', n_sink, n_clfind"
  write(ilun,format)""
  write(ilun,format)"  ! Feedback parameters"
  write(ilun,format)"  ! Removed - done in read_params instead"
  write(ilun,format)"  !call read_feedback_params(nml_ok)"
  write(ilun,format)""
  write(ilun,format)"  ! Use scale_tout parameter - allows scaling outputs to, e.g., t_ff"
  write(ilun,format)"  if (scale_tout.ne.1d0) then"
  write(ilun,format)"     tout = tout*scale_tout"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_cloud_params"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"subroutine boundary_frig(ilevel)"
  write(ilun,format)"  Use amr_commons      !, ONLY: dp,ndim,nvector,boxlen,t"
  write(ilun,format)"!  use hydro_parameters !, ONLY: nvar,boundary_var,gamma,bx_bound,by_bound,bz_bound,turb,dens0,V0"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !----------------------------------------------------------"
  write(ilun,format)"  ! This routine set up open boundary conditions which deals properly with div B "
  write(ilun,format)"  ! it uses the 2 last cells of the domain"
  write(ilun,format)"  !----------------------------------------------------------"
  write(ilun,format)"  integer::igrid,ngrid,ncache,i,ind,iskip,ix,iy,iz,j"
  write(ilun,format)"  integer::info,ibound,nx_loc,idim,neul=5"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,d,u,v,w,A,B,C"
  write(ilun,format)"  real(kind=8)::rho_max_loc,rho_max_all,epot_loc,epot_all"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:3),save::vv"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3)::q   ! Primitive variables"
  write(ilun,format)"  real(dp)::pi,time"
  write(ilun,format)"  integer ::ivar,jgrid,ind_cell_vois"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2,Cwnm"
  write(ilun,format)"  real(dp)::dx_min, fact, Emag,Emag0"
  write(ilun,format)""
  write(ilun,format)"! STG HACK - ignore if not MHD"
  write(ilun,format)"! TODO: Take boundary cleaner and use for non-MHD solver"
  write(ilun,format)"#ifndef SOLVERmhd"
  write(ilun,format)"  return"
  write(ilun,format)"#endif "
  write(ilun,format)""
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  Cwnm = sqrt(8000./scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  pi=ACOS(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"  time = t * Cwnm / boxlen"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel in coarse cell units"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  "
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=dble(nx_loc)/boxlen"
  write(ilun,format)"  dx_loc=dx/scale"
  write(ilun,format)""
  write(ilun,format)"  dx_min = (0.5D0**levelmin)/scale"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  !-------------------------------------"
  write(ilun,format)"  ! Compute analytical velocity field"
  write(ilun,format)"  !-------------------------------------"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  "
  write(ilun,format)"  ! Loop over grids by vector sweeps"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather cell indices"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather cell centre positions"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Rescale position from code units to user units"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              xx(i,idim)=(xx(i,idim)-skip_loc(idim))/scale"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)""
  write(ilun,format)"       do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        ! STG HACK CHECK FOR BORKED"
  write(ilun,format)"        if (uold(ind_cell(i),1) .lt. 0d0) then"
  write(ilun,format)"           write(*,*) 'DENSITY < 0 BEFORE VELOCITY_FINE, OH NO', ind_cell(i)"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"        if (uold(ind_cell(i),5) .lt. 0d0) then"
  write(ilun,format)"           write(*,*) 'TOTAL CELL ENERGY < 0 BEFORE VELOCITY_FINE, OH NO', ind_cell(i)"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"        do j=5,8"
  write(ilun,format)"           if (isnan(uold(ind_cell(i),j))) then"
  write(ilun,format)"              write(*,*) 'VARIABLE IS NAN BEFORE VELOCITY_FINE, OH NO', ind_cell(i),j,uold(ind_cell(i),1)"
  write(ilun,format)"              call clean_stop"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !impose vanishing gradient conditions at the x  faces"
  write(ilun,format)"        if(  xx(i,1) .lt. 2.*dx_min ) then "
  write(ilun,format)""
  write(ilun,format)"             !look for the grid neigbour of the top father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),2))"
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"           if(ind .eq. 2 .or. ind .eq. 4 .or. ind .eq. 6 .or. ind .eq. 8) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois - ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)"           ! Subtract non-thermal pressure terms"
  write(ilun,format)"!#if NENER>0"
  write(ilun,format)"!           do irad=1,nener"
  write(ilun,format)"!              uold(ind_cell(i),5) = uold(ind_cell(i),5) - uold(ind_cell(i),8+irad)"
  write(ilun,format)"!           end do"
  write(ilun,format)"!#endif"
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 2 .or. ind .eq. 4 .or. ind .eq. 6 .or. ind .eq. 8) then "
  write(ilun,format)"              uold(ind_cell(i),nvar+1) = uold(ind_cell_vois,6)"
  write(ilun,format)" "
  write(ilun,format)""
  write(ilun,format)"              uold(ind_cell(i),6)  = uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3) - uold(ind_cell(i),7) - uold(ind_cell(i),8) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),7) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),nvar+1) =  uold(ind_cell_vois,6) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3) - uold(ind_cell(i),7)  - uold(ind_cell(i),8) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),6) =  uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3)  -uold(ind_cell(i),7) - uold(ind_cell(i),8) "
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)"           ! Add back the non-thermal pressure"
  write(ilun,format)"!#if NENER>0"
  write(ilun,format)"!           do irad=1,nener"
  write(ilun,format)"!              uold(ind_cell(i),5) = uold(ind_cell(i),5) + uold(ind_cell(i),8+irad)"
  write(ilun,format)"!           end do"
  write(ilun,format)"!#endif"
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !impose vanishing gradient conditions at the x  faces"
  write(ilun,format)"        if(  xx(i,1) .gt. boxlen-2.*dx_min ) then "
  write(ilun,format)""
  write(ilun,format)"             !look for the grid neigbour of the top father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),1))"
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 3 .or. ind .eq. 5 .or. ind .eq. 7) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois + ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 3 .or. ind .eq. 5 .or. ind .eq. 7) then "
  write(ilun,format)"              uold(ind_cell(i),6) = uold(ind_cell_vois,nvar+1)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),nvar+1) = uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8) - uold(ind_cell(i),nvar+2) - uold(ind_cell(i),nvar+3) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),9) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),6) =  uold(ind_cell(i),7) + uold(ind_cell(i),8)  + uold(ind_cell_vois,nvar+1) - uold(ind_cell(i),nvar+2) - uold(ind_cell(i),nvar+3) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),nvar+1) = uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8) - uold(ind_cell(i),nvar+2) - uold(ind_cell(i),nvar+3) "
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !impose vanishing gradient conditions at the y  faces"
  write(ilun,format)"        if(  xx(i,2) .lt. 2.*dx_min ) then "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"             !look for the grid neigbour of the top father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),4))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"             !we must add 2*ngridmax because the neighbour of 3 (1) is 4 (2)"
  write(ilun,format)"           if(ind .eq. 3 .or. ind .eq. 4 .or. ind .eq. 7 .or. ind .eq. 8) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois - 2*ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 3 .or. ind .eq. 4 .or. ind .eq. 7 .or. ind .eq. 8) then "
  write(ilun,format)"              uold(ind_cell(i),nvar+2) = uold(ind_cell_vois,7)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),7)  = uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3) - uold(ind_cell(i),6) - uold(ind_cell(i),8) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),7) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),nvar+2) =  uold(ind_cell(i),nvar+1 ) + uold(ind_cell_vois,7) + uold(ind_cell(i),nvar+3) - uold(ind_cell(i),6)  - uold(ind_cell(i),8) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),7) =  uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3)  -uold(ind_cell(i),6) - uold(ind_cell(i),8) "
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        if(  xx(i,2) .gt. boxlen-2.*dx_min ) then "
  write(ilun,format)"             !look for the grid neigbour of the bottom father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),3))"
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"             !we must add 2*ngridmax because the neighbour of 3 (4) is 1 (2)"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 2 .or. ind .eq. 5 .or. ind .eq. 6) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois + 2*ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 2 .or. ind .eq. 5 .or. ind .eq. 6) then "
  write(ilun,format)"              uold(ind_cell(i),7) = uold(ind_cell_vois,nvar+2)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),nvar+2)  = uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8) - uold(ind_cell(i),nvar+1) - uold(ind_cell(i),nvar+3) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),10) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),7) =  uold(ind_cell(i),6 ) + uold(ind_cell_vois,nvar+2) + uold(ind_cell(i),8) - uold(ind_cell(i),nvar+1)  - uold(ind_cell(i),nvar+3) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),nvar+2) =  uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8)  -uold(ind_cell(i),nvar+1) - uold(ind_cell(i),nvar+3) "
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        if(  xx(i,3) .lt. 2.*dx_min ) then "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"             !look for the grid neigbour of the bottom father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),6))"
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"             !we must add 2*ngridmax because the neighbour of 5 (6) is 1 (2)"
  write(ilun,format)"           if(ind .eq. 5 .or. ind .eq. 6 .or. ind .eq. 7 .or. ind .eq. 8) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois - 4*ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 5 .or. ind .eq. 6 .or. ind .eq. 7 .or. ind .eq. 8) then "
  write(ilun,format)"              uold(ind_cell(i),nvar+3) = uold(ind_cell_vois,8)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),8)  = uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3) - uold(ind_cell(i),6) - uold(ind_cell(i),7) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),8) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),nvar+3) =  uold(ind_cell(i), nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell_vois,8) - uold(ind_cell(i),6)  - uold(ind_cell(i),7) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),8) =  uold(ind_cell(i),nvar+1) + uold(ind_cell(i),nvar+2) + uold(ind_cell(i),nvar+3)  -uold(ind_cell(i),6) - uold(ind_cell(i),7) "
  write(ilun,format)""
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        if(  xx(i,3) .gt. boxlen-2.*dx_min ) then "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"             !look for the grid neigbour of the bottom father"
  write(ilun,format)"             jgrid = son(nbor(ind_grid(i),5))"
  write(ilun,format)""
  write(ilun,format)"           ind_cell_vois = iskip + jgrid "
  write(ilun,format)"             !remember iskip is calculated above"
  write(ilun,format)"             !we must add 2*ngridmax because the neighbour of 1 (2) is 5 (6)"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 2 .or. ind .eq. 3 .or. ind .eq. 4) then "
  write(ilun,format)"             ind_cell_vois = ind_cell_vois + 4*ngridmax"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),1:nvar+3) =  uold(ind_cell_vois,1:nvar+3) "
  write(ilun,format)"           uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) = uold(ind_cell(i),5)  - Emag"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! we have to modify the 2 normal components of the magnetic field"
  write(ilun,format)"           if(ind .eq. 1 .or. ind .eq. 2 .or. ind .eq. 3 .or. ind .eq. 4) then "
  write(ilun,format)"              uold(ind_cell(i),8) = uold(ind_cell_vois,nvar+3)"
  write(ilun,format)" "
  write(ilun,format)"              uold(ind_cell(i),nvar+3)  = uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8) - uold(ind_cell(i),nvar+1) - uold(ind_cell(i),nvar+2) "
  write(ilun,format)"           else"
  write(ilun,format)"              !should be equal to uold(ind_cell(i),nvar+3) of the preceeding case "
  write(ilun,format)"              uold(ind_cell(i),8) =  uold(ind_cell(i), 6) + uold(ind_cell(i),7) + uold(ind_cell_vois,nvar+3) - uold(ind_cell(i),nvar+1)  - uold(ind_cell(i),nvar+2) "
  write(ilun,format)""
  write(ilun,format)"              !ensure div B"
  write(ilun,format)"              uold(ind_cell(i),nvar+3) =  uold(ind_cell(i),6) + uold(ind_cell(i),7) + uold(ind_cell(i),8)  -uold(ind_cell(i),nvar+1) - uold(ind_cell(i),nvar+2) "
  write(ilun,format)""
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           A=0.5*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"           B=0.5*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"           C=0.5*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)""
  write(ilun,format)"           Emag = 0.5*(A**2+B**2+C**2)"
  write(ilun,format)""
  write(ilun,format)"           uold(ind_cell(i),5) =  uold(ind_cell(i),5) + Emag "
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        uold(ind_cell(i),1) = MAX(uold(ind_cell(i),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"        ! STG HACK CHECK FOR BORKED"
  write(ilun,format)"        if (uold(ind_cell(i),5) .lt. 0d0) then"
  write(ilun,format)"           write(*,*) 'TOTAL ENERGY < 0 AFTER VELOCITY_FINE, OH NO', ind_cell(i)"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"        do j=5,8"
  write(ilun,format)"           if (isnan(uold(ind_cell(i),j))) then"
  write(ilun,format)"              write(*,*) 'VARIABLE IS NAN AFTER VELOCITY_FINE, OH NO', ind_cell(i),j"
  write(ilun,format)"              call clean_stop"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       "
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"end subroutine boundary_frig"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"../patch/rt/frig_main/condinit.f90"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine condinit(x,u,dx,nn)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"!  use const"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::nn                              ! Number of cells"
  write(ilun,format)"  real(dp)::dx                              ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3)::u ! Conservative variables"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine generates initial conditions for RAMSES."
  write(ilun,format)"  ! Positions are in user units:"
  write(ilun,format)"  ! x(i,1:3) are in [0,boxlen]**ndim."
  write(ilun,format)"  !TAKE CARE at this stage and  in this version this is not true for the"
  write(ilun,format)"  ! first time that condinit is called"
  write(ilun,format)"  ! because boxlen is determined in condinit"
  write(ilun,format)"  ! for the first call x(i,1:3) are in  [0.,1.]"
  write(ilun,format)"  ! U is the conservative variable vector. Conventions are here:"
  write(ilun,format)"  ! U(i,1): d, U(i,2:ndim+1): d.u,d.v,d.w and U(i,ndim+2): E."
  write(ilun,format)"  ! Q is the primitive variable vector. Conventions are here:"
  write(ilun,format)"  ! Q(i,1): d, Q(i,2:ndim+1):u,v,w and Q(i,ndim+2): P."
  write(ilun,format)"  ! If nvar >= ndim+3, remaining variables are treated as passive"
  write(ilun,format)"  ! scalars in the hydro solver."
  write(ilun,format)"  ! U(:,:) and Q(:,:) are in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer :: i,j,k,id,iu,iv,iw,ip"
  write(ilun,format)"  real(dp):: pi"
  write(ilun,format)"  integer :: ivar"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3),save::q   ! Primitive variables"
  write(ilun,format)""
  write(ilun,format)"  real(dp),save:: first"
  write(ilun,format)"  real(dp),dimension(1:3,1:100,1:100,1:100),save::q_idl"
  write(ilun,format)"  real(dp),save::vx_tot,vy_tot,vz_tot,vx2_tot,vy2_tot,vz2_tot"
  write(ilun,format)"  integer,save:: n_size"
  write(ilun,format)"  integer:: ind_i, ind_j, ind_k"
  write(ilun,format)"  real(dp),save:: d_c,B_c,ind,seed1,seed2,seed3,xi,yi,zi,zeta"
  write(ilun,format)"  real(dp),save:: res_int,r_0,C_s,omega,v_rms,cont_ic,mass_total,mass_tot2,min_col_d,max_col_d"
  write(ilun,format)"  real(dp):: col_d,eli,sph,vx,vy,vz"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp)::xl,yl,zl,xx,yy,zz,bx,by,bz,dxmin"
  write(ilun,format)"  integer:: ii,jj,kk,nticks"
  write(ilun,format)"  real(dp)::ener_rot,ener_grav,ener_therm,ener_grav2,ener_turb"
  write(ilun,format)"  real(dp),dimension(1000):: mass_rad"
  write(ilun,format)"  real(dp):: mu=1.4d0 ! NOTE - MUST BE THE SAME AS IN units.f90!!"
  write(ilun,format)"!  real(dp)::myid"
  write(ilun,format)"  real(dp)::P_WNM=0.0d0"
  write(ilun,format)"  logical :: turbvalid = .false."
  write(ilun,format)""
  write(ilun,format)"!    myid=1"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Call built-in initial condition generator"
  write(ilun,format)"  call region_condinit(x,q,dx,nn)"
  write(ilun,format)""
  write(ilun,format)"   !do various things which needs to be done only one time"
  write(ilun,format)"   if( first .eq. 0.) then"
  write(ilun,format)"    id=1; iu=2; iv=3; iw=4; ip=5"
  write(ilun,format)"    pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    if(myid==1) write(*,*) '** ENTER  in condinit **'"
  write(ilun,format)""
  write(ilun,format)"    call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"    scale_T2 = scale_T2 * mu"
  write(ilun,format)""
  write(ilun,format)"    !calculate the mass in code units (Msolar / Mparticle / pc^3"
  write(ilun,format)"!    mass_c = mass_c * (2.d33 / (scale_d * scale_l**3) )"
  write(ilun,format)"!    done in calc_boxlen"
  write(ilun,format)""
  write(ilun,format)"    if(myid ==1) write(*,*) 'cloud mass (code units) ',mass_c"
  write(ilun,format)""
  write(ilun,format)"    !calculate the sound speed"
  write(ilun,format)"    C_s = sqrt( T2_star / scale_T2 )"
  write(ilun,format)"    ! Set a WNM pressure with T=8000K and nH=0.5"
  write(ilun,format)"    P_WNM = 8000d0/scale_T2 * 0.5/scale_nH"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    if(myid == 1)  write(*,*) 'T2_star (K) ', T2_star"
  write(ilun,format)"    if(myid == 1)  write(*,*)  'C_s (code unist) ', C_s"
  write(ilun,format)""
  write(ilun,format)"    !cont_ic is the density contrast between the edge of the cloud and the intercloud medium"
  write(ilun,format)"    cont_ic = 10."
  write(ilun,format)""
  write(ilun,format)"    !calculate  zeta=r_ext/r_0"
  write(ilun,format)"    zeta = sqrt(cont - 1.)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    !calculate an integral used to compute the cloud radius"
  write(ilun,format)"    res_int=0."
  write(ilun,format)"    do i=1,1000"
  write(ilun,format)"     res_int = res_int + log(1.+(zeta/1000.*i)**2) * zeta/1000."
  write(ilun,format)"     mass_rad(i) = i*zeta/1000. * log(1+(zeta/1000.*i)**2) - res_int"
  write(ilun,format)"    enddo"
  write(ilun,format)"    res_int = zeta*log(1.+zeta**2) - res_int"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    !now we determine the central density and the external cloud radius"
  write(ilun,format)"    !we have mass = 2 pi rho_c r_0^2 z_0 * res_int"
  write(ilun,format)"    !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)"
  write(ilun,format)"    !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta"
  write(ilun,format)"    !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0 )"
  write(ilun,format)"    !which just state the ratio of freefall time over sound crossing time"
  write(ilun,format)"    !from these 2 formula, rho_c and r_0 are found to be:"
  write(ilun,format)""
  write(ilun,format)"    !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius"
  write(ilun,format)"    r_0 = mass_c / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2"
  write(ilun,format)""
  write(ilun,format)"    if (myid ==1) write(*,*) 'inner radius (pc) ',r_0"
  write(ilun,format)""
  write(ilun,format)"    d_c = mass_c / (2.*pi*rap*res_int) / r_0**3"
  write(ilun,format)""
  write(ilun,format)"    if(myid ==1) write(*,*) 'central density ',d_c"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    ener_therm = 3./2.*mass_c*C_s**2"
  write(ilun,format)"    ener_grav  = 3./5.*(mass_c**2)/(r_0*zeta)"
  write(ilun,format)"    ener_grav2=0."
  write(ilun,format)"    do i=1,1000"
  write(ilun,format)"     ener_grav2 = ener_grav2 + (i*zeta/1000.) / (1.+(zeta/1000.*i)**2) * zeta/1000. * mass_rad(i)"
  write(ilun,format)"    enddo"
  write(ilun,format)"    ener_grav2 = ener_grav2 * 8.*(pi**2)*(d_c**2)*(r_0**5)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    !angular velocity"
  write(ilun,format)"    omega = ff_rt * 2.*pi * sqrt( 32.*d_c/3./pi)"
  write(ilun,format)""
  write(ilun,format)"    !central value of magnetic field"
  write(ilun,format)"    !remember magnetic variable is B/sqrt(4pi)"
  write(ilun,format)""
  write(ilun,format)"    !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius"
  write(ilun,format)"    B_c = ff_act * sqrt( 32./3./pi) * d_c * r_0"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    mass_sph = d_c / cont * (boxlen*(0.5**levelmin))**3"
  write(ilun,format)""
  write(ilun,format)"    !the smallest initial column density"
  write(ilun,format)"    min_col_d = boxlen * d_c / cont / cont_ic"
  write(ilun,format)""
  write(ilun,format)"    !the largest initial column density"
  write(ilun,format)"    !obtained by integrating the density distribution through the box"
  write(ilun,format)"    max_col_d = r_0*d_c*atan(zeta) + (boxlen -2.*r_0*zeta) * d_c / cont / cont_ic"
  write(ilun,format)""
  write(ilun,format)"    if (myid==1) write(*,*) 'valeur du champ magnetique central non normalise B_c', B_c"
  write(ilun,format)"    if (myid==1) write(*,*) 'valeur du champ magnetique a l exterieur ', B_c*min_col_d/max_col_d"
  write(ilun,format)""
  write(ilun,format)"    !calculate the value of mu the mass to flux over critical mass to flux ratio"
  write(ilun,format)"    !from Mouschovias & Spitzer 1979 M/phi)_crit = 1/(3pi) * sqrt(5/G) * 0.53"
  write(ilun,format)"    !since B(r)=B_c * sig(r)/sig(0), phi = B_c * mass_c / sig(0)"
  write(ilun,format)"    !thus mass_c / phi = sig(0) / B_c"
  write(ilun,format)"    !taking into account the fact that B_c = champ mag / sqrt(4 pi)"
  write(ilun,format)"    ! we have in code units mu = sig(0) / (B_c*sqrt(4 pi)) / (sqrt(5)/(3 pi) * 0.53)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"    if (myid ==1) write(*,*) 'the mass to flux over critical mass to flux ratio in the case of a spheroidal cloud (not correct if rap ne 1)'"
  write(ilun,format)"    if (myid ==1) write(*,*) 'mu= ',max_col_d / (B_c*sqrt(4.*pi)) / (sqrt(5.)/(3.*pi) * 0.53)"
  write(ilun,format)"    !note here we make the approximation that max_col_d is equal to the column density through the cloud which is note exactly"
  write(ilun,format)"    !the case since the column density of the external medium is also taken into account"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    !now read the turbulent velocity field used as initial condition"
  write(ilun,format)"    if( myid ==1) write(*,*) 'Read the file which contains the initial turbulent velocity field'"
  write(ilun,format)"    open(20,file='ramses.data',form='formatted')"
  write(ilun,format)"    read(20,*) n_size, ind, seed1,seed2,seed3"
  write(ilun,format)""
  write(ilun,format)"     if(n_size .ne. 100) then"
  write(ilun,format)"       write(*,*) 'Unextected field size'"
  write(ilun,format)"       stop"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     v_rms=0."
  write(ilun,format)"     mass_total=0."
  write(ilun,format)"     mass_tot2 =0."
  write(ilun,format)"     do k=1,n_size"
  write(ilun,format)"     do j=1,n_size"
  write(ilun,format)"     do i=1,n_size"
  write(ilun,format)"        read(20,*)xi,yi,zi,vx,vy,vz"
  write(ilun,format)"        q_idl(1,i,j,k) = vx"
  write(ilun,format)"        q_idl(2,i,j,k) = vy"
  write(ilun,format)"        q_idl(3,i,j,k) = vz"
  write(ilun,format)""
  write(ilun,format)"        xi = boxlen/bl_fac*((i-0.5)/n_size-0.5)"
  write(ilun,format)"        yi = boxlen/bl_fac*((j-0.5)/n_size-0.5)"
  write(ilun,format)"        zi = boxlen/bl_fac*((k-0.5)/n_size-0.5)"
  write(ilun,format)"        eli =  (xi/r_0)**2+(yi/r_0)**2+(zi/(r_0*rap))**2"
  write(ilun,format)"        if( eli .lt. zeta**2) then"
  write(ilun,format)""
  write(ilun,format)"         vx_tot = vx_tot + d_c/(1.+eli)*vx"
  write(ilun,format)"         vy_tot = vy_tot + d_c/(1.+eli)*vy"
  write(ilun,format)"         vz_tot = vz_tot + d_c/(1.+eli)*vz"
  write(ilun,format)""
  write(ilun,format)"         vx2_tot = vx2_tot + d_c/(1.+eli)*vx**2"
  write(ilun,format)"         vy2_tot = vy2_tot + d_c/(1.+eli)*vy**2"
  write(ilun,format)"         vz2_tot = vz2_tot + d_c/(1.+eli)*vz**2"
  write(ilun,format)""
  write(ilun,format)"         ener_turb = ener_turb + d_c/(1.+eli)*(vx**2+vy**2+vz**2)"
  write(ilun,format)"         mass_total = mass_total +  d_c / (1.+eli)"
  write(ilun,format)"         ener_rot = ener_rot + d_c/(1.+eli) * omega**2 * (yi**2 + zi**2)"
  write(ilun,format)"        endif"
  write(ilun,format)"     enddo"
  write(ilun,format)"!       eli = (yi/r_0)**2 + (zi/r_0/rap)**2"
  write(ilun,format)"!        if( eli .lt. zeta**2) then"
  write(ilun,format)"!          col_d = r_0*d_c/sqrt(1.+eli)*atan( sqrt( (zeta**2-eli)/(1.+eli) ) )"
  write(ilun,format)"!          mass_tot2 = mass_tot2 + col_d"
  write(ilun,format)"!        endif"
  write(ilun,format)"     enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"    close(20)"
  write(ilun,format)""
  write(ilun,format)"     vx_tot = vx_tot / mass_total"
  write(ilun,format)"     vy_tot = vy_tot / mass_total"
  write(ilun,format)"     vz_tot = vz_tot / mass_total"
  write(ilun,format)""
  write(ilun,format)"     vx2_tot = vx2_tot / mass_total"
  write(ilun,format)"     vy2_tot = vy2_tot / mass_total"
  write(ilun,format)"     vz2_tot = vz2_tot / mass_total"
  write(ilun,format)""
  write(ilun,format)"     v_rms = sqrt( vx2_tot-vx_tot**2 + vy2_tot-vy_tot**2 + vz2_tot-vz_tot**2 )"
  write(ilun,format)""
  write(ilun,format)"     mass_total = mass_total*(boxlen/n_size)**3"
  write(ilun,format)"     if (myid ==1) write(*,*) 'We verify the calculation for the mass. The 2 following values must be very close:'"
  write(ilun,format)"     if (myid ==1) write(*,*) 'mass_total, mass_c ',mass_total, mass_c !,mass_tot2"
  write(ilun,format)""
  write(ilun,format)"     ener_rot  = 0.5 * ener_rot*(boxlen/n_size)**3"
  write(ilun,format)"     ener_turb = 0.5 * ener_turb*(boxlen/n_size)**3"
  write(ilun,format)""
  write(ilun,format)"     !estimate of the thermal over gravitational energy"
  write(ilun,format)"     if (myid == 1) write(*,*) 'estimate (uniform density is assumed) of the ratio of thermal over gravitational energy'"
  write(ilun,format)"     if (myid == 1) write(*,*)  ener_therm / ener_grav"
  write(ilun,format)""
  write(ilun,format)"     if (myid == 1) write(*,*) 'good estimate of the ratio of thermal over gravitational energy'"
  write(ilun,format)"     if (myid == 1) write(*,*)  ener_therm / ener_grav2"
  write(ilun,format)""
  write(ilun,format)"     !estimate of the rotational over gravitational energy ratio"
  write(ilun,format)"     if (myid .eq. 1) write(*,*) 'estimate of the rotational over gravitational energy ratio'"
  write(ilun,format)"     if (myid .eq. 1) write(*,*) 'ener_rot/ener_grav2 ', ener_rot / ener_grav2"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     !calculate now the coefficient by which the turbulence velocity needs"
  write(ilun,format)"     !to be multiplied"
  write(ilun,format)""
  write(ilun,format)"     if (myid .eq. 1) write(*,*) 'vrms non norm ',v_rms"
  write(ilun,format)""
  write(ilun,format)"    !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius"
  write(ilun,format)"     v_rms = ff_vct * sqrt(32.*d_c/3./pi)*r_0 / v_rms"
  write(ilun,format)""
  write(ilun,format)"     if (myid .eq. 1) write(*,*) 'vrms mult ',v_rms"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     !estimate of the turbulent over gravitational energy ratio"
  write(ilun,format)"     if (myid .eq. 1) write(*,*) 'estimate of the turbulent over gravitational energy ratio'"
  write(ilun,format)"     if (myid .eq. 1) write(*,*) 'ener_turb/ener_grav2 ', ener_turb*(v_rms**2) / ener_grav2"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    100 format(i5,4e12.5)"
  write(ilun,format)"    101 format(6e12.5)"
  write(ilun,format)"    102 format(i5)"
  write(ilun,format)""
  write(ilun,format)"    if (myid ==1)  write(*,*) 'Reading achieved'"
  write(ilun,format)"    first = 1."
  write(ilun,format)"   endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"   DO i=1,nn"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       x(i,1) = x(i,1) - 0.5*boxlen"
  write(ilun,format)"       x(i,2) = x(i,2) - 0.5*boxlen"
  write(ilun,format)"       x(i,3) = x(i,3) - 0.5*boxlen"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       !initialise the density field"
  write(ilun,format)"       eli =  (x(i,1)/r_0)**2+(x(i,2)/r_0)**2+(x(i,3)/(r_0*rap))**2"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       if( eli .le. zeta**2) then"
  write(ilun,format)"          ! Is inside the cloud"
  write(ilun,format)"          q(i,1) = d_c / (1.+eli)"
  write(ilun,format)"          q(i,5) = q(i,1) * C_s**2"
  write(ilun,format)"          q(i,5) = max(q(i,5),P_WNM)"
  write(ilun,format)"       else if (eli .le. 4*zeta**2) then"
  write(ilun,format)"          ! Is inside a circle of diameter boxlen"
  write(ilun,format)"          q(i,1) = d_c / cont / cont_ic"
  write(ilun,format)"          q(i,5) = q(i,1) * C_s**2"
  write(ilun,format)"          !if the cloud is in pressure equilibrium with the surrounding medium"
  write(ilun,format)"          !remove this line if the IC gas is isothermal as well"
  write(ilun,format)"          !        q(i,5) = q(i,5) * cont_ic"
  write(ilun,format)"          q(i,5) = max(q(i,5),P_WNM)"
  write(ilun,format)"       else"
  write(ilun,format)"          ! External medium"
  write(ilun,format)"          ! Is inside a circle of diameter boxlen"
  write(ilun,format)"          ! NOTE - Here we heat up the gas (by 1/0.8) so P_ext > P_cloud"
  write(ilun,format)"          ! This is to balance extra turbulent KE energy in the cloud"
  write(ilun,format)"          ! This is only an issue if B~0, otherwise B contains the cloud"
  write(ilun,format)"          q(i,1) = 1d0 !d_c / cont / cont_ic / 100d0"
  write(ilun,format)"          q(i,5) = q(i,1) * C_s**2"
  write(ilun,format)"          q(i,5) = max(q(i,5),P_WNM/0.8d0)"
  write(ilun,format)"       end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"       if(all(abs(x(i,:) / (boxlen / bl_fac)) <= 0.5)) then"
  write(ilun,format)"         !initialise the turbulent velocity field"
  write(ilun,format)"         !make a zero order interpolation (should be improved)"
  write(ilun,format)"         ind_i = int((x(i,1)/(boxlen/bl_fac)+0.5)*n_size)+1"
  write(ilun,format)"         ind_j = int((x(i,2)/(boxlen/bl_fac)+0.5)*n_size)+1"
  write(ilun,format)"         ind_k = int((x(i,3)/(boxlen/bl_fac)+0.5)*n_size)+1"
  write(ilun,format)""
  write(ilun,format)"         ! Is this a valid cell for the turbulence?"
  write(ilun,format)"         turbvalid = .true."
  write(ilun,format)"         !if( ind_i .lt. 1 .or. ind_i .gt. n_size) write(*,*) 'ind_i ',ind_i,boxlen,x(i,1),n_size"
  write(ilun,format)"         !if( ind_j .lt. 1 .or. ind_j .gt. n_size) write(*,*) 'ind_j ',ind_j"
  write(ilun,format)"         !if( ind_k .lt. 1 .or. ind_k .gt. n_size) write(*,*) 'ind_k ',ind_k"
  write(ilun,format)""
  write(ilun,format)"         !if( ind_i .lt. 1 .or. ind_i .gt. n_size) turbvalid=.false."
  write(ilun,format)"         !if( ind_j .lt. 1 .or. ind_j .gt. n_size) turbvalid=.false."
  write(ilun,format)"         !if( ind_k .lt. 1 .or. ind_k .gt. n_size) turbvalid=.false."
  write(ilun,format)"         ! Periodic hack"
  write(ilun,format)"         ind_i = 1+modulo(ind_i-1, n_size)"
  write(ilun,format)"         ind_j = 1+modulo(ind_j-1, n_size)"
  write(ilun,format)"         ind_k = 1+modulo(ind_k-1, n_size)"
  write(ilun,format)""
  write(ilun,format)"         !if (turbvalid) then"
  write(ilun,format)"         q(i,2) = v_rms*(q_idl(1,ind_i,ind_j,ind_k)-vx_tot)"
  write(ilun,format)"         q(i,3) = v_rms*(q_idl(2,ind_i,ind_j,ind_k)-vy_tot)"
  write(ilun,format)"         q(i,4) = v_rms*(q_idl(3,ind_i,ind_j,ind_k)-vz_tot)"
  write(ilun,format)"         !endif"
  write(ilun,format)""
  write(ilun,format)"         !add  rotation. x cos(thet_mag) + y sin(thet_mag) is the rotation axis"
  write(ilun,format)"         sph =  (x(i,1)/r_0)**2+(x(i,2)/r_0)**2+(x(i,3)/(r_0))**2"
  write(ilun,format)"         if( sph .lt. (zeta*rap)**2 ) then"
  write(ilun,format)""
  write(ilun,format)"         !to check these formulae one can verify that those arrays are perpendicular"
  write(ilun,format)"         !with (cos(thet_mag),sin(thet_mag),0) and that the norm of the vectorial product of"
  write(ilun,format)"         ! (cos(thet_mag),sin(thet_mag),0) by the above arrays is equal to the distance"
  write(ilun,format)"         !  (x sin(thet)-y cos(thet))^2 + z^2"
  write(ilun,format)"           q(i,2) = q(i,2) - (omega*x(i,3)*sin(thet_mag))"
  write(ilun,format)"           q(i,3) = q(i,3) + (omega*x(i,3)*cos(thet_mag))"
  write(ilun,format)"           q(i,4) = q(i,4) + (omega*(x(i,1)*sin(thet_mag)-x(i,2)*cos(thet_mag)))"
  write(ilun,format)"         endif"
  write(ilun,format)"       else"
  write(ilun,format)"         q(i, 2:4) = 0.0"
  write(ilun,format)"       endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ENDDO"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  dxmin=boxlen*0.5d0**(nlevelmax)"
  write(ilun,format)""
  write(ilun,format)"  if( dx .lt. dxmin) then"
  write(ilun,format)"    write(*,*) 'dxmin too large'"
  write(ilun,format)"    write(*,*) 'dx ',dx/boxlen"
  write(ilun,format)"    write(*,*) 'dxmin ',dxmin/boxlen"
  write(ilun,format)"    stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  nticks=dx/dxmin"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"! Set ionisation fraction to the floor value by hand"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  if (rt) then"
  write(ilun,format)"     DO i=1,nn"
  write(ilun,format)"        q(i,9:nvar) = 0d0"
  write(ilun,format)"     ENDDO ! LAYS EGGS"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"   DO i=1,nn"
  write(ilun,format)"   q(i,6)=0."
  write(ilun,format)""
  write(ilun,format)"     xl=x(i,1)-0.5*dx"
  write(ilun,format)"     yl=x(i,2)-0.5*dx"
  write(ilun,format)"     zl=x(i,3)-0.5*dx"
  write(ilun,format)""
  write(ilun,format)"     !the magnetic field in cells must be subdivided in order to insure that the magnetic"
  write(ilun,format)"     !flux is the same in coarse and refined grids"
  write(ilun,format)"     DO jj=1,nticks"
  write(ilun,format)"     DO kk=1,nticks"
  write(ilun,format)""
  write(ilun,format)"        yy=yl+(dble(jj)-0.5d0)*dxmin"
  write(ilun,format)"        zz=zl+(dble(kk)-0.5d0)*dxmin"
  write(ilun,format)""
  write(ilun,format)"       !this formula comes from the integration of the density distribution along x"
  write(ilun,format)"       eli = (yy/r_0)**2 + (zz/r_0/rap)**2"
  write(ilun,format)"        if( eli .lt. zeta**2) then"
  write(ilun,format)"         col_d = r_0*d_c/sqrt(1.+eli)*atan( sqrt( (zeta**2-eli)/(1.+eli) ) )"
  write(ilun,format)"         col_d = max(col_d,min_col_d)"
  write(ilun,format)"        else"
  write(ilun,format)"         col_d = min_col_d"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"       !Bx component"
  write(ilun,format)"       q(i,6     ) = q(i,6) + B_c * col_d / max_col_d"
  write(ilun,format)"       q(i,nvar+1) = q(i,6)"
  write(ilun,format)""
  write(ilun,format)"       !By component"
  write(ilun,format)"       q(i,7     ) = 0."
  write(ilun,format)"       q(i,nvar+2) = 0."
  write(ilun,format)""
  write(ilun,format)"       !Bz component"
  write(ilun,format)"       q(i,8     ) = 0."
  write(ilun,format)"       q(i,nvar+3) = 0."
  write(ilun,format)""
  write(ilun,format)"     ENDDO"
  write(ilun,format)"     ENDDO"
  write(ilun,format)""
  write(ilun,format)"       q(i,6:8)           = q(i,6:8)           / dble(nticks)**2"
  write(ilun,format)""
  write(ilun,format)"!new version rotates the rotation velocity"
  write(ilun,format)"     !rotates the magnetic field of an angle theta"
  write(ilun,format)"!       bx=q(i,6)"
  write(ilun,format)"!       by=q(i,7)"
  write(ilun,format)"!       q(i,6) =  bx*cos(thet_mag) + by*sin(thet_mag)"
  write(ilun,format)"!       q(i,7) =  bx*sin(thet_mag) - by*cos(thet_mag)"
  write(ilun,format)""
  write(ilun,format)"       q(i,nvar+1:nvar+3) = q(i,6:8)"
  write(ilun,format)"  ENDDO"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Convert primitive to conservative variables"
  write(ilun,format)"  ! density -> density"
  write(ilun,format)"  u(1:nn,1)=q(1:nn,1)"
  write(ilun,format)"  ! velocity -> momentum"
  write(ilun,format)"  u(1:nn,2)=q(1:nn,1)*q(1:nn,2)"
  write(ilun,format)"  u(1:nn,3)=q(1:nn,1)*q(1:nn,3)"
  write(ilun,format)"  u(1:nn,4)=q(1:nn,1)*q(1:nn,4)"
  write(ilun,format)"  ! kinetic energy"
  write(ilun,format)"  u(1:nn,5)=0.0d0"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,2)**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,3)**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,4)**2"
  write(ilun,format)"  !kinetic + magnetic energy"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125*(q(1:nn,6)+q(1:nn,nvar+1))**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125*(q(1:nn,7)+q(1:nn,nvar+2))**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125*(q(1:nn,8)+q(1:nn,nvar+3))**2"
  write(ilun,format)"#endif"
  write(ilun,format)"  ! thermal pressure -> total fluid energy"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+q(1:nn,5)/(gamma-1.0d0)"
  write(ilun,format)"  ! magnetic field"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  u(1:nn,6:8)=q(1:nn,6:8)"
  write(ilun,format)"  u(1:nn,nvar+1:nvar+3)=q(1:nn,nvar+1:nvar+3)"
  write(ilun,format)"  ! passive scalars"
  write(ilun,format)"  do ivar=9,nvar"
  write(ilun,format)"     u(1:nn,ivar)=q(1:nn,1)*q(1:nn,ivar)"
  write(ilun,format)"  end do"
  write(ilun,format)"#else"
  write(ilun,format)"  ! passive scalars"
  write(ilun,format)"  do ivar=6,nvar"
  write(ilun,format)"     u(1:nn,ivar)=q(1:nn,1)*q(1:nn,ivar)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine condinit"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)""
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine velana(x,v,dx,t,ncell)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ncell                         ! Size of input arrays"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp)::t                             ! Current time"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:3)::v    ! Velocity field"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine computes the user defined velocity fields."
  write(ilun,format)"  ! x(i,1:ndim) are cell center position in [0,boxlen] (user units)."
  write(ilun,format)"  ! v(i,1:3) is the imposed 3-velocity in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::i"
  write(ilun,format)"  real(dp)::xx,yy,zz,vx,vy,vz,rr,tt,omega,aa,twopi"
  write(ilun,format)""
  write(ilun,format)"  ! Add here, if you wish, some user-defined initial conditions"
  write(ilun,format)"  aa=1.0"
  write(ilun,format)"  twopi=2d0*ACOS(-1d0)"
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)""
  write(ilun,format)"     xx=x(i,1)"
  write(ilun,format)"     yy=x(i,2)"
  write(ilun,format)"     zz=x(i,3)"
  write(ilun,format)""
  write(ilun,format)"     ! ABC"
  write(ilun,format)"     vx=aa*(cos(twopi*yy)+sin(twopi*zz))"
  write(ilun,format)"     vy=aa*(sin(twopi*xx)+cos(twopi*zz))"
  write(ilun,format)"     vz=aa*(cos(twopi*xx)+sin(twopi*yy))"
  write(ilun,format)""
  write(ilun,format)"!!      ! 1D advection test"
  write(ilun,format)"!!      vx=1.0_dp"
  write(ilun,format)"!!      vy=0.0_dp"
  write(ilun,format)"!!      vz=0.0_dp"
  write(ilun,format)""
  write(ilun,format)"!!      ! Ponomarenko"
  write(ilun,format)"!!      xx=xx-boxlen/2.0"
  write(ilun,format)"!!      yy=yy-boxlen/2.0"
  write(ilun,format)"!!      rr=sqrt(xx**2+yy**2)"
  write(ilun,format)"!!      if(yy>0)then"
  write(ilun,format)"!!         tt=acos(xx/rr)"
  write(ilun,format)"!!      else"
  write(ilun,format)"!!         tt=-acos(xx/rr)+twopi"
  write(ilun,format)"!!      endif"
  write(ilun,format)"!!      if(rr<1.0)then"
  write(ilun,format)"!!         omega=0.609711"
  write(ilun,format)"!!         vz=0.792624"
  write(ilun,format)"!!      else"
  write(ilun,format)"!!         omega=0.0"
  write(ilun,format)"!!         vz=0.0"
  write(ilun,format)"!!      endif"
  write(ilun,format)"!!      vx=-sin(tt)*rr*omega"
  write(ilun,format)"!!      vy=+cos(tt)*rr*omega"
  write(ilun,format)""
  write(ilun,format)"     v(i,1)=vx"
  write(ilun,format)"     v(i,2)=vy"
  write(ilun,format)"     v(i,3)=vz"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine velana"
  write(ilun,format)"../patch/rt/frig_main/godunov_fine.f90"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine godunov_fine(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine is a wrapper to the second order Godunov solver."
  write(ilun,format)"  ! Small grids (2x2x2) are gathered from level ilevel and sent to the"
  write(ilun,format)"  ! hydro solver. On entry, hydro variables are gathered from array uold."
  write(ilun,format)"  ! On exit, unew has been updated. "
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  integer::i,ivar,igrid,ncache,ngrid"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(static)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over active grids by vector sweeps"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     call godfine1(ind_grid,ngrid,ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering godunov_fine for level ',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine godunov_fine"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine set_unew(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  use radiation_parameters,ONLY:eray_min"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"#endif"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine sets array unew to its initial value uold before calling"
  write(ilun,format)"  ! the hydro scheme. unew is set to zero in virtual boundaries."
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  integer::i,ivar,ind,icpu,iskip,irad"
  write(ilun,format)"  real(dp)::d,u,v,w,e,A,B,C"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Set unew to uold for myid cells"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"        do i=1,active(ilevel)%ngrid"
  write(ilun,format)"           unew(active(ilevel)%igrid(i)+iskip,ivar) = uold(active(ilevel)%igrid(i)+iskip,ivar)"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"           if(ngrp .gt. 0 .and. ivar .gt. firstindex_er .and.ivar .le. firstindex_er+ngrp)then"
  write(ilun,format)"              unew(active(ilevel)%igrid(i)+iskip,ivar)=max(unew(active(ilevel)%igrid(i)+iskip,ivar),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"           end if"
  write(ilun,format)"#endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(pressure_fix)then"
  write(ilun,format)"        do i=1,active(ilevel)%ngrid"
  write(ilun,format)"           divu(active(ilevel)%igrid(i)+iskip) = 0.0d0"
  write(ilun,format)"        end do"
  write(ilun,format)"        do i=1,active(ilevel)%ngrid"
  write(ilun,format)"           d=max(uold(active(ilevel)%igrid(i)+iskip,1),smallr)"
  write(ilun,format)"           u=uold(active(ilevel)%igrid(i)+iskip,2)/d"
  write(ilun,format)"           v=uold(active(ilevel)%igrid(i)+iskip,3)/d"
  write(ilun,format)"           w=uold(active(ilevel)%igrid(i)+iskip,4)/d"
  write(ilun,format)"           A=0.5d0*(uold(active(ilevel)%igrid(i)+iskip,6)+uold(active(ilevel)%igrid(i)+iskip,nvar+1))"
  write(ilun,format)"           B=0.5d0*(uold(active(ilevel)%igrid(i)+iskip,7)+uold(active(ilevel)%igrid(i)+iskip,nvar+2))"
  write(ilun,format)"           C=0.5d0*(uold(active(ilevel)%igrid(i)+iskip,8)+uold(active(ilevel)%igrid(i)+iskip,nvar+3))"
  write(ilun,format)"           e=uold(active(ilevel)%igrid(i)+iskip,5)-0.5d0*d*(u**2+v**2+w**2)-0.5d0*(A**2+B**2+C**2)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do irad=1,nener"
  write(ilun,format)"              e=e-uold(active(ilevel)%igrid(i)+iskip,8+irad)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif          "
  write(ilun,format)"           enew(active(ilevel)%igrid(i)+iskip)=e"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Set unew to 0 for virtual boundary cells"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"        do i=1,reception(icpu,ilevel)%ngrid"
  write(ilun,format)"           unew(reception(icpu,ilevel)%igrid(i)+iskip,ivar)=0.0d0"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(pressure_fix)then"
  write(ilun,format)"        do i=1,reception(icpu,ilevel)%ngrid"
  write(ilun,format)"           divu(reception(icpu,ilevel)%igrid(i)+iskip) = 0.0d0"
  write(ilun,format)"           enew(reception(icpu,ilevel)%igrid(i)+iskip) = 0.0d0"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering set_unew for level ',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine set_unew"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine set_uold(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH"
  write(ilun,format)"  use radiation_parameters,ONLY:mu_gas,Tr_floor"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine sets array uold to its new value unew after the"
  write(ilun,format)"  ! hydro step."
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  integer::i,ivar,ind,iskip,nx_loc,irad,ind_cell"
  write(ilun,format)"  real(dp)::scale,d,u,v,w,A,B,C"
  write(ilun,format)"  real(dp)::e_mag,e_kin,e_cons,e_prim,e_trunc,div,dx,fact,d_old"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::cv,dd,ee,TP_loc"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  nx_loc=icoarse_max-icoarse_min+1"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx=0.5d0**ilevel*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Add gravity source terms to unew"
  write(ilun,format)"  if(poisson)then"
  write(ilun,format)"     call add_gravity_source_terms(ilevel)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Add non conservative pdV terms to unew "
  write(ilun,format)"  ! for thermal and/or non-thermal energies"
  write(ilun,format)"  if(pressure_fix.OR.nener>0)then"
  write(ilun,format)"     call add_pdv_source_terms(ilevel)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Set uold to unew for myid cells"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"        do i=1,active(ilevel)%ngrid"
  write(ilun,format)"           uold(active(ilevel)%igrid(i)+iskip,ivar) = unew(active(ilevel)%igrid(i)+iskip,ivar)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(pressure_fix)then"
  write(ilun,format)"        fact=(gamma-1.0d0)"
  write(ilun,format)"        do i=1,active(ilevel)%ngrid"
  write(ilun,format)"           ind_cell=active(ilevel)%igrid(i)+iskip"
  write(ilun,format)"           d=max(uold(ind_cell,1),smallr)"
  write(ilun,format)"           u=uold(ind_cell,2)/d"
  write(ilun,format)"           v=uold(ind_cell,3)/d"
  write(ilun,format)"           w=uold(ind_cell,4)/d"
  write(ilun,format)"           A=0.5d0*(uold(ind_cell,6)+uold(ind_cell,nvar+1))"
  write(ilun,format)"           B=0.5d0*(uold(ind_cell,7)+uold(ind_cell,nvar+2))"
  write(ilun,format)"           C=0.5d0*(uold(ind_cell,8)+uold(ind_cell,nvar+3))"
  write(ilun,format)"           e_kin=0.5d0*d*(u**2+v**2+w**2)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do irad=1,nener"
  write(ilun,format)"              e_kin=e_kin+uold(ind_cell,8+irad)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif"
  write(ilun,format)"           e_mag=0.5d0*(A**2+B**2+C**2)"
  write(ilun,format)"           e_cons=uold(ind_cell,5)-e_kin-e_mag"
  write(ilun,format)"           e_prim=enew(ind_cell)"
  write(ilun,format)"           ! Note: here divu=-div.u*dt"
  write(ilun,format)"           div=abs(divu(ind_cell))*dx/dtnew(ilevel)"
  write(ilun,format)"           ! Estimate of the local truncation errors"
  write(ilun,format)"           e_trunc=beta_fix*d*max(div,3.0d0*hexp*dx)**2"
  write(ilun,format)"!           if(e_cons<e_trunc)then"
  write(ilun,format)"              uold(ind_cell,5)=e_prim+e_kin+e_mag"
  write(ilun,format)"!           end if"
  write(ilun,format)""
  write(ilun,format)"           e_prim = uold(ind_cell,5)-e_kin-e_mag ! uncomment this for radiative shock"
  write(ilun,format)"           if(energy_fix)then"
  write(ilun,format)"              e_prim = uold(ind_cell,nvar)"
  write(ilun,format)"           end if"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"           ! Compute temperature for perfect gas to prevent crash in the interpolation routine of the EOS"
  write(ilun,format)"           "
  write(ilun,format)"           ! Compute gas temperature in cgs"
  write(ilun,format)"           dd=d *scale_d"
  write(ilun,format)"           ee=e_prim *scale_d*scale_v**2"
  write(ilun,format)""
  write(ilun,format)"           Cv= dd*kB/(mu_gas*mH*(gamma-1.0d0))!(cgs)"
  write(ilun,format)"           Tp_loc =  ee/(Cv)"
  write(ilun,format)""
  write(ilun,format)"           if(Tp_loc .lt. 0.3d0*Tr_floor .and. ntestDADM.eq.0)then"
  write(ilun,format)"              e_prim = uold(ind_cell,nvar)"
  write(ilun,format)"              uold(ind_cell,5)=e_prim+e_kin+e_mag"
  write(ilun,format)"              ee=e_prim *scale_d*scale_v**2"
  write(ilun,format)"              Cv= dd*kB/(mu_gas*mH*(gamma-1.0d0))!(cgs)"
  write(ilun,format)"              Tp_loc =  ee/Cv"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           if(Tp_loc .lt. 0.3d0*Tr_floor.and. ntestDADM.eq.0)then"
  write(ilun,format)"              ! Prevent articifial cooling due to negligible internal energy (wto the total energy)"
  write(ilun,format)"              call enerint_eos(d,0.3d0*Tr_floor,e_prim)"
  write(ilun,format)"              if((.not.(barotrop)).and. (ntestDADM.eq.0))print*,'WARNING TP_LOC',tp_loc,e_trunc,e_prim,e_cons,dd"
  write(ilun,format)"              uold(ind_cell,5)=e_prim+e_kin+e_mag"
  write(ilun,format)"              uold(ind_cell,nvar)=e_prim"
  write(ilun,format)"           end if"
  write(ilun,format)"#endif"
  write(ilun,format)"           if(energy_fix)then"
  write(ilun,format)"              uold(ind_cell,5)=e_prim+e_kin+e_mag"
  write(ilun,format)"              uold(ind_cell,nvar)=e_prim"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering set_uold for level ',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine set_uold"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine add_gravity_source_terms(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine adds to unew the gravity source terms"
  write(ilun,format)"  ! with only half a time step. Only the momentum and the"
  write(ilun,format)"  ! total energy are modified in array unew."
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  integer::i,ivar,ind,iskip,nx_loc,ind_cell"
  write(ilun,format)"  real(dp)::d,u,v,w,e_kin,e_prim,d_old,fact"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Add gravity source term at time t with half time step"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do i=1,active(ilevel)%ngrid"
  write(ilun,format)"        ind_cell=active(ilevel)%igrid(i)+iskip"
  write(ilun,format)"        d=max(unew(ind_cell,1),smallr)"
  write(ilun,format)"        u=0.0; v=0.0; w=0.0"
  write(ilun,format)"        if(ndim>0)u=unew(ind_cell,2)/d"
  write(ilun,format)"        if(ndim>1)v=unew(ind_cell,3)/d"
  write(ilun,format)"        if(ndim>2)w=unew(ind_cell,4)/d"
  write(ilun,format)"        e_kin=0.5*d*(u**2+v**2+w**2)"
  write(ilun,format)"        e_prim=unew(ind_cell,5)-e_kin"
  write(ilun,format)"        d_old=max(uold(ind_cell,1),smallr)"
  write(ilun,format)"        fact=d_old/d*0.5*dtnew(ilevel)"
  write(ilun,format)"        if(ndim>0)then"
  write(ilun,format)"           u=u+f(ind_cell,1)*fact"
  write(ilun,format)"           unew(ind_cell,2)=d*u"
  write(ilun,format)"        endif"
  write(ilun,format)"        if(ndim>1)then"
  write(ilun,format)"           v=v+f(ind_cell,2)*fact"
  write(ilun,format)"           unew(ind_cell,3)=d*v"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(ndim>2)then"
  write(ilun,format)"           w=w+f(ind_cell,3)*fact"
  write(ilun,format)"           unew(ind_cell,4)=d*w"
  write(ilun,format)"        endif"
  write(ilun,format)"        e_kin=0.5*d*(u**2+v**2+w**2)"
  write(ilun,format)"        unew(ind_cell,5)=e_prim+e_kin"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering add_gravity_source_terms for level ',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine add_gravity_source_terms"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine add_pdv_source_terms(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:clight"
  write(ilun,format)"  use radiation_parameters,ONLY:eray_min,nu_min_hz,nu_max_hz,stellar_photon"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !---------------------------------------------------------"
  write(ilun,format)"  ! This routine adds the pdV source term to the internal"
  write(ilun,format)"  ! energy equation and to the non-thermal energy equations."
  write(ilun,format)"  !---------------------------------------------------------"
  write(ilun,format)"  integer::i,j,k,ivar,irad,ind,iskip,nx_loc,ind_cell1"
  write(ilun,format)"  integer::ncache,igrid,ngrid,idim,id1,ig1,ih1,id2,ig2,ih2"
  write(ilun,format)"  integer,dimension(1:3,1:2,1:8)::iii,jjj"
  write(ilun,format)"  real(dp)::scale,dx,dx_loc,d,u,v,w,eold,A,B,C"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector,0:twondim),save::igridn"
  write(ilun,format)"  integer ,dimension(1:nvector,1:ndim),save::ind_left,ind_right"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:ngrp),save::Erg,Erd"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:ndim),save::velg,veld"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::dx_g,dx_d"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:ndim),save::divu_loc"
  write(ilun,format)""
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:ndim,1:ngrp)::gradEr"
  write(ilun,format)""
  write(ilun,format)"  integer::igroup"
  write(ilun,format)"  real(dp)::usquare,emag,erad_loc,ekin,eps,cv,pp_eos"
  write(ilun,format)"  real(dp)::e_mag,e_kin,e_cons,e_prim,e_trunc,div,fact,e_r"
  write(ilun,format)"  real(dp)::rosseland_ana,radiation_source"
  write(ilun,format)"  real(dp)::Pgdivu,u_square,d_loc,Tp_loc,Tr_loc,cal_Teg"
  write(ilun,format)"  real(dp)::kappa_R,gradEr_norm,gradEr_norm2,R,lambda,lambda_fld,chi,PgmErdivu,gradEru"
  write(ilun,format)"  real(dp) ,dimension(1:ndim,1:ndim,1:ngrp)::Pg"
  write(ilun,format)"  real(dp) ,dimension(1:ndim       )::u_loc"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"  real(dp), dimension(3,3         ) :: Dedd,Dedd_dE"
  write(ilun,format)"  real(dp), dimension(3,3,3       ) :: Dedd_dF"
  write(ilun,format)"  real(dp), dimension(    1:3     ) :: Fr_temp"
  write(ilun,format)"  real(dp), dimension(3,3,3       ) :: Hr"
  write(ilun,format)"  real(dp), dimension(3,3,3,1:ngrp) :: Qg"
  write(ilun,format)"  real(dp), dimension(1:ndim      ) :: nuQrDivu"
  write(ilun,format)"  real(dp) :: nuQr,nuQl,Qr_nu"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp) :: nuPrDivu,nuPr,nuPl,Pr_nu"
  write(ilun,format)""
  write(ilun,format)"  !  EOS"
  write(ilun,format)"  real(dp) :: dd,ee,cmp_Cv_eos"
  write(ilun,format)"  integer  :: ht"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  nx_loc=icoarse_max-icoarse_min+1"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx=0.5d0**ilevel"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  velg=0.0; veld=0.0d0"
  write(ilun,format)""
  write(ilun,format)"  iii(1,1,1:8)=(/1,0,1,0,1,0,1,0/); jjj(1,1,1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"  iii(1,2,1:8)=(/0,2,0,2,0,2,0,2/); jjj(1,2,1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"  iii(2,1,1:8)=(/3,3,0,0,3,3,0,0/); jjj(2,1,1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"  iii(2,2,1:8)=(/0,0,4,4,0,0,4,4/); jjj(2,2,1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"  iii(3,1,1:8)=(/5,5,5,5,0,0,0,0/); jjj(3,1,1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"  iii(3,2,1:8)=(/0,0,0,0,6,6,6,6/); jjj(3,2,1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"   "
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Gather neighboring grids"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        igridn(i,0)=ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_left (i,idim)=nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           ind_right(i,idim)=nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1)=son(ind_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  )=son(ind_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        "
  write(ilun,format)"        ! Compute central cell index"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather all neighboring velocities"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           id1=jjj(idim,1,ind); ig1=iii(idim,1,ind)"
  write(ilun,format)"           ih1=ncoarse+(id1-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(igridn(i,ig1)>0)then"
  write(ilun,format)"                 velg(i,idim,1:ndim) = uold(igridn(i,ig1)+ih1,2:ndim+1)/max(uold(igridn(i,ig1)+ih1,1),smallr)"
  write(ilun,format)"                 dx_g(i,idim) = dx_loc"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)"                    Erg(i,idim,igroup) = max(uold(igridn(i,ig1)+ih1,firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif                "
  write(ilun,format)"              else"
  write(ilun,format)"                 velg(i,idim,1:ndim) = uold(ind_left(i,idim),2:ndim+1)/max(uold(ind_left(i,idim),1),smallr)"
  write(ilun,format)"                 dx_g(i,idim) = dx_loc*1.5_dp"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)"                    Erg(i,idim,igroup) = max(uold(ind_left(i,idim),firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)"              end if"
  write(ilun,format)"           enddo"
  write(ilun,format)"           id2=jjj(idim,2,ind); ig2=iii(idim,2,ind)"
  write(ilun,format)"           ih2=ncoarse+(id2-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(igridn(i,ig2)>0)then"
  write(ilun,format)"                 veld(i,idim,1:ndim)= uold(igridn(i,ig2)+ih2,2:ndim+1)/max(uold(igridn(i,ig2)+ih2,1),smallr)"
  write(ilun,format)"                 dx_d(i,idim)=dx_loc"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)"                    Erd(i,idim,igroup) = max(uold(igridn(i,ig2)+ih2,firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)"              else "
  write(ilun,format)"                 veld(i,idim,1:ndim)= uold(ind_right(i,idim),2:ndim+1)/max(uold(ind_right(i,idim),1),smallr)"
  write(ilun,format)"                 dx_d(i,idim)=dx_loc*1.5_dp"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)"                    Erd(i,idim,igroup) = max(uold(ind_right(i,idim),firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)"              end if"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over dimensions"
  write(ilun,format)"  "
  write(ilun,format)"        ! Compute divu"
  write(ilun,format)"        divu_loc(1:ngrid,1:ndim,1:ndim)=0.0d0"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           do j=1,ndim"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 divu_loc(i,j,idim) = (veld(i,j,idim)-velg(i,j,idim)) &"
  write(ilun,format)"                      &                    / (dx_g(i,j)     +dx_d(i,j))"
  write(ilun,format)"              end do"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"              do igroup=1,ngrp"
  write(ilun,format)"                 gradEr(i,j,igroup) = (Erd(i,j,igroup)-Erg(i,j,igroup))/(dx_g(i,j)+dx_d(i,j))"
  write(ilun,format)"              enddo"
  write(ilun,format)"#endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Update thermal internal energy "
  write(ilun,format)"        if(pressure_fix)then"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ! Compute old thermal energy"
  write(ilun,format)"              d=max(uold(ind_cell(i),1),smallr)"
  write(ilun,format)"              u=0.0; v=0.0; w=0.0"
  write(ilun,format)"              if(ndim>0)u=uold(ind_cell(i),2)/d"
  write(ilun,format)"              if(ndim>1)v=uold(ind_cell(i),3)/d"
  write(ilun,format)"              if(ndim>2)w=uold(ind_cell(i),4)/d"
  write(ilun,format)"              A=0.5d0*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"              B=0.5d0*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"              C=0.5d0*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)"              eold=uold(ind_cell(i),5)-0.5d0*d*(u**2+v**2+w**2)-0.5d0*(A**2+B**2+C**2)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"              do irad=1,nener"
  write(ilun,format)"                 eold=eold-uold(ind_cell(i),8+irad)"
  write(ilun,format)"              end do"
  write(ilun,format)"#endif"
  write(ilun,format)"              ! Add -pdV term"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 enew(ind_cell(i))=enew(ind_cell(i)) &"
  write(ilun,format)"                      & -(gamma-1.0d0)*eold*divu_loc(i,idim,idim)*dtnew(ilevel)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1 || USE_M_1==1"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           d_loc = uold(ind_cell(i),1)*scale_d"
  write(ilun,format)"           u_loc(1:ndim) = uold(ind_cell(i),2:ndim+1)/uold(ind_cell(i),1)"
  write(ilun,format)"           "
  write(ilun,format)"           usquare=0.0"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              usquare=usquare+(uold(ind_cell(i),idim+1)/uold(ind_cell(i),1))**2"
  write(ilun,format)"           end do"
  write(ilun,format)"           "
  write(ilun,format)"           ! Compute total magnetic energy"
  write(ilun,format)"           emag = 0.0d0"
  write(ilun,format)"           do ivar=1,3"
  write(ilun,format)"              emag = emag + 0.125d0*(uold(ind_cell(i),5+ivar) &"
  write(ilun,format)"                   &  +uold(ind_cell(i),nvar+ivar))**2"
  write(ilun,format)"           end do"
  write(ilun,format)"           erad_loc=0.0D0"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do igroup=1,nener"
  write(ilun,format)"              erad_loc = erad_loc + uold(ind_cell(i),8+igroup)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif"
  write(ilun,format)"           d     = uold(ind_cell(i),1)"
  write(ilun,format)"           ekin  = d*usquare/2.0"
  write(ilun,format)"           ! Compute gas temperature in cgs"
  write(ilun,format)"           eps   = uold(ind_cell(i),5)-ekin-emag-erad_loc"
  write(ilun,format)"           if(energy_fix)eps   = uold(ind_cell(i),nvar) "
  write(ilun,format)"           call temperature_eos(d,eps,Tp_loc,ht)"
  write(ilun,format)""
  write(ilun,format)"           ! Compute radiative pressure in all groups"
  write(ilun,format)"           do igroup=1,ngrp"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"              ! Compute radiative pressure"
  write(ilun,format)"              Tr_loc = cal_Teg(uold(ind_cell(i),firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"              kappa_R = rosseland_ana(d_loc,Tp_loc,Tr_loc,igroup)/scale_kappa"
  write(ilun,format)"              gradEr_norm2 = 0.0d0"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 gradEr_norm2 = gradEr_norm2 + gradEr(i,idim,igroup)**2"
  write(ilun,format)"              end do"
  write(ilun,format)"              gradEr_norm  = (gradEr_norm2)**0.5"
  write(ilun,format)"              R =  max(1.d-10,gradEr_norm/(max(uold(ind_cell(i),firstindex_er+igroup),eray_min/(scale_d*scale_v**2))*kappa_R))"
  write(ilun,format)"              lambda = lambda_fld(R)"
  write(ilun,format)"              chi = lambda + (lambda*R)**2"
  write(ilun,format)"              do j=1,ndim"
  write(ilun,format)"                 do k=1,ndim"
  write(ilun,format)"                    Pg(j,k,igroup)=0.0d0"
  write(ilun,format)"                    if(j .eq. k) Pg(j,k,igroup) = (1.0d0-chi)/2.0d0"
  write(ilun,format)"                    if(R .gt. 1.d-8)Pg(j,k,igroup) = Pg(j,k,igroup) + (3.0d0*chi-1.0d0)/2.0d0*gradEr(i,j,igroup)*gradEr(i,k,igroup)/gradEr_norm2"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              enddo"
  write(ilun,format)"              Pg(1:ndim,1:ndim,igroup)=Pg(1:ndim,1:ndim,igroup)*uold(ind_cell(i),firstindex_er+igroup)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"              Fr_temp=zero"
  write(ilun,format)"              do j=1,ndim"
  write(ilun,format)"                 Fr_temp(j)=uold(ind_cell(i),firstindex_er+j*ngrp+igroup)"
  write(ilun,format)"              enddo"
  write(ilun,format)"              ! NOTE: due to normalisation at the initialisation, we have to multiply F by (scale_v/clight)"
  write(ilun,format)"              !       due to the definition of F in cal_Dedd, we also have to divide F by an additional clight"
  write(ilun,format)"!!               call cal_Dedd(uold(ind_cell(i),firstindex_er+igroup),Fr_temp*scale_v/(clight*clight),Dedd,Dedd_dE,Dedd_dF)"
  write(ilun,format)"              call cal_Dedd(uold(ind_cell(i),firstindex_er+igroup),Fr_temp*scale_v/clight,Dedd,Dedd_dE,Dedd_dF)"
  write(ilun,format)"              Pg(1:ndim,1:ndim,igroup)=Dedd(1:ndim,1:ndim)*uold(ind_cell(i),firstindex_er+igroup)"
  write(ilun,format)""
  write(ilun,format)"              !WARNING WITH NORMALIZATION !!!"
  write(ilun,format)"!              print*,'normalization to be assessed cal_hr called in godunov_fine and qr_nu...'"
  write(ilun,format)"!              read(*,*)"
  write(ilun,format)"              call cal_Hr(uold(ind_cell(i),firstindex_er+igroup),Fr_temp*scale_v,Hr)"
  write(ilun,format)"              Qg(1:ndim,1:ndim,1:ndim,igroup)=Hr(1:ndim,1:ndim,1:ndim)*uold(ind_cell(i),firstindex_er+igroup)*clight/scale_v"
  write(ilun,format)"#endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"              "
  write(ilun,format)"           do igroup=1,ngrp"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"              ! Compute radiative pressure"
  write(ilun,format)"              Tr_loc = cal_Teg(uold(ind_cell(i),firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"              kappa_R = rosseland_ana(d_loc,Tp_loc,Tr_loc,igroup)/scale_kappa"
  write(ilun,format)"              gradEr_norm2 = 0.0d0"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 gradEr_norm2 = gradEr_norm2 + gradEr(i,idim,igroup)**2"
  write(ilun,format)"              end do"
  write(ilun,format)"              gradEr_norm  = (gradEr_norm2)**0.5"
  write(ilun,format)"              R =   max(1.d-10,gradEr_norm/(max(uold(ind_cell(i),firstindex_er+igroup),eray_min/(scale_d*scale_v**2))*kappa_R))"
  write(ilun,format)"              lambda = lambda_fld(R)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"              Pgdivu     = 0.0d0"
  write(ilun,format)"              PgmErdivu  = 0.0d0"
  write(ilun,format)"              gradEru    = 0.0d0"
  write(ilun,format)"              nuPrDivu   = 0.0d0 ! multig: this is the Doppler shift term"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"              nuQrDivu   = zero ! multig: this is the Doppler shift term"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"              do j=1,ndim"
  write(ilun,format)"                 do k=1,ndim"
  write(ilun,format)"                 "
  write(ilun,format)"                    ! compure Pr:divU term"
  write(ilun,format)"                    Pgdivu    = Pgdivu    + Pg(j,k,igroup)*divu_loc(i,j,k)"
  write(ilun,format)"                    PgmErdivu = PgmErdivu + Pg(j,k,igroup)*divu_loc(i,j,k)"
  write(ilun,format)"                    "
  write(ilun,format)"                    ! compute -[nu P]*Div(u) term"
  write(ilun,format)"                    if(divu_loc(i,j,k) > 0.0d0)then"
  write(ilun,format)""
  write(ilun,format)"                       if(igroup == ngrp)then"
  write(ilun,format)"                          nuPr = 0.0d0"
  write(ilun,format)"                       else"
  write(ilun,format)"                          nuPr = nu_max_hz(igroup)*Pr_nu(Pg(j,k,igroup+1),uold(ind_cell(i),firstindex_er+igroup+1),igroup+1,nu_max_hz(igroup),scale_d,scale_v)"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(igroup == 1 .or. (stellar_photon .and. igroup==2))then"
  write(ilun,format)"                          nuPl = 0.0d0"
  write(ilun,format)"                       else"
  write(ilun,format)"                          nuPl = nu_min_hz(igroup)*Pr_nu(Pg(j,k,igroup),uold(ind_cell(i),firstindex_er+igroup),igroup,nu_min_hz(igroup),scale_d,scale_v)"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                    else"
  write(ilun,format)""
  write(ilun,format)"                       if(igroup == ngrp)then"
  write(ilun,format)"                          nuPr = 0.0d0"
  write(ilun,format)"                       else"
  write(ilun,format)"                          nuPr = nu_max_hz(igroup)*Pr_nu(Pg(j,k,igroup),uold(ind_cell(i),firstindex_er+igroup),igroup,nu_max_hz(igroup),scale_d,scale_v)"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(igroup == 1 .or. (stellar_photon .and. igroup==2))then"
  write(ilun,format)"                          nuPl = 0.0d0"
  write(ilun,format)"                       else"
  write(ilun,format)"                          nuPl = nu_min_hz(igroup)*Pr_nu(Pg(j,k,igroup-1),uold(ind_cell(i),firstindex_er+igroup-1),igroup-1,nu_min_hz(igroup),scale_d,scale_v)"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                    endif"
  write(ilun,format)"                    "
  write(ilun,format)"                    nuPrDivu = nuPrDivu + (nuPr - nuPl)*divu_loc(i,j,k)"
  write(ilun,format)""
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"                    do l=1,ndim"
  write(ilun,format)""
  write(ilun,format)"                       ! compute [nu Q]*Div(u) term"
  write(ilun,format)"                       if(divu_loc(i,j,k) > zero)then"
  write(ilun,format)""
  write(ilun,format)"                          if(igroup == ngrp)then"
  write(ilun,format)"                             nuQr = zero"
  write(ilun,format)"                          else"
  write(ilun,format)"                             nuQr = nu_max_hz(igroup)*Qr_nu(Qg(j,k,l,igroup+1),uold(ind_cell(i),firstindex_er+igroup+1),igroup+1,nu_max_hz(igroup),scale_d,scale_v)"
  write(ilun,format)"                          endif"
  write(ilun,format)"                          if(igroup == 1 .or. (stellar_photon .and. igroup==2))then"
  write(ilun,format)"                             nuQl = zero"
  write(ilun,format)"                          else"
  write(ilun,format)"                             nuQl = nu_min_hz(igroup)*Qr_nu(Qg(j,k,l,igroup),uold(ind_cell(i),firstindex_er+igroup),igroup,nu_min_hz(igroup),scale_d,scale_v)"
  write(ilun,format)"                          endif"
  write(ilun,format)""
  write(ilun,format)"                       else"
  write(ilun,format)""
  write(ilun,format)"                          if(igroup == ngrp)then"
  write(ilun,format)"                             nuQr = zero"
  write(ilun,format)"                          else"
  write(ilun,format)"                             nuQr = nu_max_hz(igroup)*Qr_nu(Qg(j,k,l,igroup),uold(ind_cell(i),firstindex_er+igroup),igroup,nu_max_hz(igroup),scale_d,scale_v)"
  write(ilun,format)"                          endif"
  write(ilun,format)"                          if(igroup == 1 .or. (stellar_photon .and. igroup==2))then"
  write(ilun,format)"                             nuQl = zero"
  write(ilun,format)"                          else"
  write(ilun,format)"                             nuQl = nu_min_hz(igroup)*Qr_nu(Qg(j,k,l,igroup-1),uold(ind_cell(i),firstindex_er+igroup-1),igroup-1,nu_min_hz(igroup),scale_d,scale_v)"
  write(ilun,format)"                          endif"
  write(ilun,format)""
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                       nuQrDivu(l) = nuQrDivu(l) + (nuQr - nuQl)*divu_loc(i,j,k)"
  write(ilun,format)""
  write(ilun,format)"                    enddo"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"                 enddo"
  write(ilun,format)"                 PgmErdivu = PgmErdivu - uold(ind_cell(i),firstindex_er+igroup)/3.0d0*divu_loc(i,j,j)"
  write(ilun,format)"                 gradEru = gradEru + gradEr(i,j,igroup)*u_loc(j)"
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"              if(stellar_photon .and. igroup==1)nuPrdivu=0.0"
  write(ilun,format)"              unew(ind_cell(i),firstindex_er+igroup) = unew(ind_cell(i),firstindex_er+igroup)  - (Pgdivu - nuPrDivu)*dtnew(ilevel)"
  write(ilun,format)"              unew(ind_cell(i),firstindex_er+igroup)=max(unew(ind_cell(i),firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)""
  write(ilun,format)"              unew(ind_cell(i),5) = unew(ind_cell(i),5) - dtnew(ilevel)*( &"
  write(ilun,format)"                   & (lambda-1.0d0/3.0d0)*gradEru + &"
  write(ilun,format)"                   & PgmErdivu - nuPrDivu)"
  write(ilun,format)""
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 unew(ind_cell(i),idim+1) = unew(ind_cell(i),1+idim) - dtnew(ilevel)*( &"
  write(ilun,format)"                      & (lambda -1.0d0/3.0d0)*gradEr(i,idim,igroup))"
  write(ilun,format)"              enddo    "
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"              unew(ind_cell(i),5) = unew(ind_cell(i),5) - dtnew(ilevel)*(Pgdivu-nuPrDivu)"
  write(ilun,format)"              unew(ind_cell(i),firstindex_er+igroup) = unew(ind_cell(i),firstindex_er+igroup) - dtnew(ilevel)*(Pgdivu-nuPrDivu)"
  write(ilun,format)""
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 print*,'Warning in godunov_fine with M1, update/check Tr_loc for rosseland_ana'"
  write(ilun,format)"                 stop"
  write(ilun,format)""
  write(ilun,format)"                 unew(ind_cell(i),1+idim) = unew(ind_cell(i),1+idim) - dtnew(ilevel)*rosseland_ana(d_loc,Tp_loc,Tr_loc,igroup)/scale_kappa*uold(ind_cell(i),firstindex_er+idim*ngrp+igroup)*scale_v/clight"
  write(ilun,format)"                 unew(ind_cell(i),5) = unew(ind_cell(i),5) - dtnew(ilevel)*rosseland_ana(d_loc,Tp_loc,Tr_loc,igroup)/scale_kappa*uold(ind_cell(i),firstindex_er+idim*ngrp+igroup)*scale_v/clight*uold(ind_cell(i),1+idim)"
  write(ilun,format)""
  write(ilun,format)"                 do j = 1,ndim"
  write(ilun,format)"!                    unew(ind_cell(i),firstindex_er+idim*ngrp+igroup) = unew(ind_cell(i),firstindex_er+idim*ngrp+igroup) - dtnew(ilevel)*Fr_temp(j)*divu_loc(i,idim,j)"
  write(ilun,format)"                    unew(ind_cell(i),firstindex_er+idim*ngrp+igroup) = unew(ind_cell(i),firstindex_er+idim*ngrp+igroup) - dtnew(ilevel)*(Fr_temp(j)*divu_loc(i,j,idim)-nuQrDivu(j))"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              enddo"
  write(ilun,format)"#endif"
  write(ilun,format)"           enddo !end loop over rad groups"
  write(ilun,format)"        end do ! end loop over ngrid"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"        do irad=1,nent"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ! Add -pdV term"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 unew(ind_cell(i),8+irad)=unew(ind_cell(i),8+irad) &"
  write(ilun,format)"                      & -(gamma_rad(irad)-1.0d0)*uold(ind_cell(i),8+irad)*divu_loc(i,idim,idim)*dtnew(ilevel)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"        !update internal energy in unew(nvar)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)"           usquare=0.0"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              usquare=usquare+(uold(ind_cell(i),idim+1)/uold(ind_cell(i),1))**2"
  write(ilun,format)"           end do"
  write(ilun,format)"           "
  write(ilun,format)"           ! Compute total magnetic energy"
  write(ilun,format)"           emag = 0.0d0"
  write(ilun,format)"           do ivar=1,3"
  write(ilun,format)"              emag = emag + 0.125d0*(uold(ind_cell(i),5+ivar) &"
  write(ilun,format)"                   &  +uold(ind_cell(i),nvar+ivar))**2"
  write(ilun,format)"           end do"
  write(ilun,format)"           erad_loc=0.0D0"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do igroup=1,nener"
  write(ilun,format)"              erad_loc = erad_loc + uold(ind_cell(i),8+igroup)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"           d     = uold(ind_cell(i),1)"
  write(ilun,format)"           ekin  = d*usquare/2.0"
  write(ilun,format)"           ! Compute gas pressure in cgs"
  write(ilun,format)"           eps   = uold(ind_cell(i),5)-ekin-emag-erad_loc"
  write(ilun,format)"           if(energy_fix)eps   = uold(ind_cell(i),nvar) "
  write(ilun,format)"           call pressure_eos(d,eps,pp_eos)"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              unew(ind_cell(i),nvar) = unew(ind_cell(i),nvar) &"
  write(ilun,format)"                   & - pp_eos*divu_loc(i,idim,idim)*dtnew(ilevel)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"     enddo"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"!!   ! This is the old technique based on the 'pressure fix' option."
  write(ilun,format)"!! "
  write(ilun,format)"!!   ! Update thermal internal energy "
  write(ilun,format)"!!   if(pressure_fix)then"
  write(ilun,format)"!!      do ind=1,twotondim"
  write(ilun,format)"!!         iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"!!         do i=1,active(ilevel)%ngrid"
  write(ilun,format)"!!            ind_cell1=active(ilevel)%igrid(i)+iskip"
  write(ilun,format)"!!            ! Compute old thermal energy"
  write(ilun,format)"!!            d=max(uold(ind_cell1,1),smallr)"
  write(ilun,format)"!!            u=0.0; v=0.0; w=0.0"
  write(ilun,format)"!!            if(ndim>0)u=uold(ind_cell1,2)/d"
  write(ilun,format)"!!            if(ndim>1)v=uold(ind_cell1,3)/d"
  write(ilun,format)"!!            if(ndim>2)w=uold(ind_cell1,4)/d"
  write(ilun,format)"!!            eold=uold(ind_cell1,5)-0.5*d*(u**2+v**2+w**2)"
  write(ilun,format)"!! #if NENER>0"
  write(ilun,format)"!!            do irad=1,nener"
  write(ilun,format)"!!               eold=eold-uold(ind_cell1,8+irad)"
  write(ilun,format)"!!            end do"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!!            ! Add pdV term"
  write(ilun,format)"!!            enew(ind_cell1)=enew(ind_cell1) &"
  write(ilun,format)"!!                 & +(gamma-1.0d0)*eold*divu(ind_cell1) ! Note: here divu=-div.u*dt"
  write(ilun,format)"!!         end do"
  write(ilun,format)"!!      end do"
  write(ilun,format)"!!   end if"
  write(ilun,format)"!! "
  write(ilun,format)"!! #if NENER>0"
  write(ilun,format)"!!   do irad=1,nener"
  write(ilun,format)"!!      do ind=1,twotondim"
  write(ilun,format)"!!         iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"!!         do i=1,active(ilevel)%ngrid"
  write(ilun,format)"!!            ind_cell1=active(ilevel)%igrid(i)+iskip"
  write(ilun,format)"!!            unew(ind_cell1,8+irad)=unew(ind_cell1,8+irad) &"
  write(ilun,format)"!!                 & +(gamma_rad(irad)-1.0d0)*uold(ind_cell1,8+irad)*divu(ind_cell1) ! Note: here divu=-div.u*dt"
  write(ilun,format)"!!         end do"
  write(ilun,format)"!!      end do"
  write(ilun,format)"!!   end do"
  write(ilun,format)"!! #endif"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering add_pdv_source_terms for level ',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine add_pdv_source_terms"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine godfine1(ind_grid,ncache,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel,ncache"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  ! This routine gathers first hydro variables from neighboring grids"
  write(ilun,format)"  ! to set initial conditions in a 6x6x6 grid. It interpolate from"
  write(ilun,format)"  ! coarser level missing grid variables. It then calls the"
  write(ilun,format)"  ! Godunov solver that computes fluxes. These fluxes are zeroed at "
  write(ilun,format)"  ! coarse-fine boundaries, since contribution from finer levels has"
  write(ilun,format)"  ! already been taken into account. Conservative variables are updated "
  write(ilun,format)"  ! and stored in array unew(:), both at the current level and at the "
  write(ilun,format)"  ! coarser level if necessary."
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  integer ,dimension(1:nvector,1:threetondim     ),save::nbors_father_cells"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim       ),save::nbors_father_grids"
  write(ilun,format)"  integer ,dimension(1:nvector,0:twondim         ),save::ibuffer_father"
  write(ilun,format)"  integer ,dimension(1:nvector,0:twondim         ),save::ind1"
  write(ilun,format)"  real(dp),dimension(1:nvector,0:twondim  ,1:nvar+3),save::u1"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim,1:nvar+3),save::u2"
  write(ilun,format)"  real(dp),dimension(1:nvector,0:twondim  ,1:ndim),save::g1=0.0d0"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim,1:ndim),save::g2=0.0d0"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar+3),save::uloc"
  write(ilun,format)"  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:ndim),save::gloc=0.0d0"
  write(ilun,format)"  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:3),save::jcell=0.d0 "
  write(ilun,format)"  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2,1:nvar,1:ndim),save::flux"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:3,1:3,1:3),save::emfx=0.0d0,emfy=0.0d0,emfz=0.0d0"
  write(ilun,format)"  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2,1:2,1:ndim),save::tmp"
  write(ilun,format)"  logical ,dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2),save::ok"
  write(ilun,format)""
  write(ilun,format)"  integer,dimension(1:nvector),save::igrid_nbor,ind_cell,ind_buffer,ind_exist,ind_nexist"
  write(ilun,format)""
  write(ilun,format)"  integer::neul=5"
  write(ilun,format)"  integer::ind_buffer1,ind_buffer2,ind_buffer3"
  write(ilun,format)"  integer::ind_father1,ind_father2,ind_father3"
  write(ilun,format)"  integer::i,j,ivar,idim,ind_son,ind_father,iskip,nbuffer,ibuffer"
  write(ilun,format)"  integer::i0,j0,k0,i1,j1,k1,i2,j2,k2,i3,j3,k3,nx_loc,nb_noneigh,nexist"
  write(ilun,format)"  integer::i1min,i1max,j1min,j1max,k1min,k1max"
  write(ilun,format)"  integer::i2min,i2max,j2min,j2max,k2min,k2max"
  write(ilun,format)"  integer::i3min,i3max,j3min,j3max,k3min,k3max"
  write(ilun,format)"  real(dp)::dflux_x,dflux_y,dflux_z"
  write(ilun,format)"  real(dp)::dx,scale,oneontwotondim"
  write(ilun,format)"  real(dp)::dflux,weight"
  write(ilun,format)""
  write(ilun,format)"  oneontwotondim = 1.d0/dble(twotondim)"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=icoarse_max-icoarse_min+1"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx=0.5D0**ilevel*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Integer constants"
  write(ilun,format)"  i1min=0; i1max=0; i2min=0; i2max=0; i3min=1; i3max=1"
  write(ilun,format)"  j1min=0; j1max=0; j2min=0; j2max=0; j3min=1; j3max=1"
  write(ilun,format)"  k1min=0; k1max=0; k2min=0; k2max=0; k3min=1; k3max=1"
  write(ilun,format)"  if(ndim>0)then"
  write(ilun,format)"     i1max=2; i2max=1; i3max=2"
  write(ilun,format)"  end if"
  write(ilun,format)"  if(ndim>1)then"
  write(ilun,format)"     j1max=2; j2max=1; j3max=2"
  write(ilun,format)"  end if"
  write(ilun,format)"  if(ndim>2)then"
  write(ilun,format)"     k1max=2; k2max=1; k3max=2"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------"
  write(ilun,format)"  ! Gather 3^ndim neighboring father cells"
  write(ilun,format)"  !------------------------------------------"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_cell(i)=father(ind_grid(i))"
  write(ilun,format)"  end do"
  write(ilun,format)"  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ncache,ilevel)"
  write(ilun,format)"  "
  write(ilun,format)"  !---------------------------"
  write(ilun,format)"  ! Gather 6x6x6 cells stencil"
  write(ilun,format)"  !---------------------------"
  write(ilun,format)"  ! Loop over 3x3x3 neighboring father cells"
  write(ilun,format)"  do k1=k1min,k1max"
  write(ilun,format)"  do j1=j1min,j1max"
  write(ilun,format)"  do i1=i1min,i1max"
  write(ilun,format)"     "
  write(ilun,format)"     ! Check if neighboring grid exists"
  write(ilun,format)"     nbuffer=0"
  write(ilun,format)"     nexist=0"
  write(ilun,format)"     ind_father=1+i1+3*j1+9*k1"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        igrid_nbor(i)=son(nbors_father_cells(i,ind_father))"
  write(ilun,format)"        if(igrid_nbor(i)>0) then"
  write(ilun,format)"           nexist=nexist+1"
  write(ilun,format)"           ind_exist(nexist)=i"
  write(ilun,format)"        else"
  write(ilun,format)"          nbuffer=nbuffer+1"
  write(ilun,format)"          ind_nexist(nbuffer)=i"
  write(ilun,format)"          ind_buffer(nbuffer)=nbors_father_cells(i,ind_father)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! If not, interpolate variables from parent cells"
  write(ilun,format)"     if(nbuffer>0)then"
  write(ilun,format)"        call getnborfather(ind_buffer,ibuffer_father,nbuffer,ilevel)"
  write(ilun,format)"        do j=0,twondim"
  write(ilun,format)"           do ivar=1,nvar+3"
  write(ilun,format)"              do i=1,nbuffer"
  write(ilun,format)"                 u1(i,j,ivar)=uold(ibuffer_father(i,j),ivar)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           do i=1,nbuffer"
  write(ilun,format)"              ind1(i,j)=son(ibuffer_father(i,j))"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        call interpol_hydro(u1,ind1,u2,nbuffer)"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over 2x2x2 cells"
  write(ilun,format)"     do k2=k2min,k2max"
  write(ilun,format)"     do j2=j2min,j2max"
  write(ilun,format)"     do i2=i2min,i2max"
  write(ilun,format)""
  write(ilun,format)"        ind_son=1+i2+2*j2+4*k2"
  write(ilun,format)"        iskip=ncoarse+(ind_son-1)*ngridmax"
  write(ilun,format)"        do i=1,nexist"
  write(ilun,format)"           ind_cell(i)=iskip+igrid_nbor(ind_exist(i))"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        i3=1; j3=1; k3=1"
  write(ilun,format)"        if(ndim>0)i3=1+2*(i1-1)+i2"
  write(ilun,format)"        if(ndim>1)j3=1+2*(j1-1)+j2"
  write(ilun,format)"        if(ndim>2)k3=1+2*(k1-1)+k2"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather hydro variables"
  write(ilun,format)"        do ivar=1,nvar+3"
  write(ilun,format)"           do i=1,nexist"
  write(ilun,format)"              uloc(ind_exist(i),i3,j3,k3,ivar)=uold(ind_cell(i),ivar)"
  write(ilun,format)"           end do"
  write(ilun,format)"           do i=1,nbuffer"
  write(ilun,format)"              uloc(ind_nexist(i),i3,j3,k3,ivar)=u2(i,ind_son,ivar)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather gravitational acceleration"
  write(ilun,format)"        if(poisson)then"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,nexist"
  write(ilun,format)"                 gloc(ind_exist(i),i3,j3,k3,idim)=f(ind_cell(i),idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"              do i=1,nbuffer"
  write(ilun,format)"                 gloc(ind_nexist(i),i3,j3,k3,idim)=f(ibuffer_father(i,0),idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"        end if"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather refinement flag"
  write(ilun,format)"        do i=1,nexist"
  write(ilun,format)"           ok(ind_exist(i),i3,j3,k3)=son(ind_cell(i))>0"
  write(ilun,format)"        end do"
  write(ilun,format)"        do i=1,nbuffer"
  write(ilun,format)"           ok(ind_nexist(i),i3,j3,k3)=.false."
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over neighboring grids"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------"
  write(ilun,format)"  ! Compute flux using second-order Godunov method"
  write(ilun,format)"  !-----------------------------------------------"
  write(ilun,format)"  ! modif nimhd"
  write(ilun,format)"!  call mag_unsplit(uloc,gloc,flux,emfx,emfy,emfz,tmp,dx,dx,dx,dtnew(ilevel),ncache)"
  write(ilun,format)"  call mag_unsplit(uloc,gloc,flux,emfx,emfy,emfz,tmp,dx,dx,dx,dtnew(ilevel),ncache,ind_grid,jcell)"
  write(ilun,format)"  ! fin modif nimhd"
  write(ilun,format)""
  write(ilun,format)"  if(ischeme.eq.1)then"
  write(ilun,format)"  !---------------------------------"
  write(ilun,format)"  ! Reset all Euler variables fluxes"
  write(ilun,format)"  !---------------------------------"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"  do ivar=1,neul"
  write(ilun,format)"     do k3=k3min,k3max+1"
  write(ilun,format)"     do j3=j3min,j3max+1"
  write(ilun,format)"     do i3=i3min,i3max+1"
  write(ilun,format)"        do i=1,ncache"
  write(ilun,format)"           flux(i,i3,j3,k3,ivar,idim)=0.0d0"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! Reset flux along direction at refined interface    "
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     i0=0; j0=0; k0=0"
  write(ilun,format)"     if(idim==1)i0=1"
  write(ilun,format)"     if(idim==2)j0=1"
  write(ilun,format)"     if(idim==3)k0=1"
  write(ilun,format)"     do k3=k3min,k3max+k0"
  write(ilun,format)"     do j3=j3min,j3max+j0"
  write(ilun,format)"     do i3=i3min,i3max+i0"
  write(ilun,format)"        do ivar=1,nvar"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              if(ok(i,i3-i0,j3-j0,k3-k0) .or. ok(i,i3,j3,k3))then"
  write(ilun,format)"                 flux(i,i3,j3,k3,ivar,idim)=0.0d0"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        if(pressure_fix)then"
  write(ilun,format)"        do ivar=1,2"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              if(ok(i,i3-i0,j3-j0,k3-k0) .or. ok(i,i3,j3,k3))then"
  write(ilun,format)"                 tmp (i,i3,j3,k3,ivar,idim)=0.0d0"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  ! Reset Euler fluxes for Bx"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     i0=0; j0=0; k0=0"
  write(ilun,format)"     if(idim==1)i0=1"
  write(ilun,format)"     if(idim==2)j0=1"
  write(ilun,format)"     if(idim==3)k0=1"
  write(ilun,format)"     do k3=k3min,k3max+k0"
  write(ilun,format)"     do j3=j3min,j3max+j0"
  write(ilun,format)"     do i3=i3min,i3max+i0"
  write(ilun,format)"        do i=1,ncache"
  write(ilun,format)"           flux(i,i3,j3,k3,6,idim)=0.0d0"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  ! Reset electromotive force along direction z at refined edges"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  do k3=k3min,k3max"
  write(ilun,format)"  do j3=1,3"
  write(ilun,format)"  do i3=1,3"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        if(ok(i,i3  ,j3  ,k3) .or. ok(i,i3  ,j3-1,k3) .or.  &"
  write(ilun,format)"         & ok(i,i3-1,j3  ,k3) .or. ok(i,i3-1,j3-1,k3))then"
  write(ilun,format)"           emfz(i,i3,j3,k3)=0.0d0"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"           emfz(i,i3,j3,k3+1)=0.0d0"
  write(ilun,format)"#endif"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  ! Reset Euler fluxes for By"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     i0=0; j0=0; k0=0"
  write(ilun,format)"     if(idim==1)i0=1"
  write(ilun,format)"     if(idim==2)j0=1"
  write(ilun,format)"     if(idim==3)k0=1"
  write(ilun,format)"     do k3=k3min,k3max+k0"
  write(ilun,format)"     do j3=j3min,j3max+j0"
  write(ilun,format)"     do i3=i3min,i3max+i0"
  write(ilun,format)"        do i=1,ncache"
  write(ilun,format)"           flux(i,i3,j3,k3,7,idim)=0.0d0"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  ! Reset electromotive force along direction y at refined edges"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  do k3=1,3"
  write(ilun,format)"  do j3=1,2"
  write(ilun,format)"  do i3=1,3"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        if(ok(i,i3  ,j3,k3  ) .or. ok(i,i3  ,j3,k3-1) .or.  &"
  write(ilun,format)"         & ok(i,i3-1,j3,k3  ) .or. ok(i,i3-1,j3,k3-1))then"
  write(ilun,format)"           emfy(i,i3,j3,k3)=0.0d0"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  ! Reset electromotive force along direction x at refined edges"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  do k3=1,3"
  write(ilun,format)"  do j3=1,3"
  write(ilun,format)"  do i3=1,2"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        if(ok(i,i3,j3  ,k3  ) .or. ok(i,i3,j3  ,k3-1) .or.  &"
  write(ilun,format)"         & ok(i,i3,j3-1,k3  ) .or. ok(i,i3,j3-1,k3-1))then"
  write(ilun,format)"           emfx(i,i3,j3,k3)=0.0d0"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  ! Reset Euler fluxes for Bz"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     i0=0; j0=0; k0=0"
  write(ilun,format)"     if(idim==1)i0=1"
  write(ilun,format)"     if(idim==2)j0=1"
  write(ilun,format)"     if(idim==3)k0=1"
  write(ilun,format)"     do k3=k3min,k3max+k0"
  write(ilun,format)"     do j3=j3min,j3max+j0"
  write(ilun,format)"     do i3=i3min,i3max+i0"
  write(ilun,format)"        do i=1,ncache"
  write(ilun,format)"           flux(i,i3,j3,k3,8,idim)=0.0d0"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------"
  write(ilun,format)"  ! Conservative update at level ilevel for Euler system"
  write(ilun,format)"  !-----------------------------------------------------"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     i0=0; j0=0; k0=0"
  write(ilun,format)"     if(idim==1)i0=1"
  write(ilun,format)"     if(idim==2)j0=1"
  write(ilun,format)"     if(idim==3)k0=1"
  write(ilun,format)"     do k2=k2min,k2max"
  write(ilun,format)"     do j2=j2min,j2max"
  write(ilun,format)"     do i2=i2min,i2max"
  write(ilun,format)"        ind_son=1+i2+2*j2+4*k2"
  write(ilun,format)"        iskip=ncoarse+(ind_son-1)*ngridmax"
  write(ilun,format)"        do i=1,ncache"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        i3=1+i2"
  write(ilun,format)"        j3=1+j2"
  write(ilun,format)"        k3=1+k2"
  write(ilun,format)"        ! Update conservative variables new state vector"
  write(ilun,format)"        do ivar=1,nvar"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              unew(ind_cell(i),ivar)=unew(ind_cell(i),ivar)+ &"
  write(ilun,format)"                   & (flux(i,i3   ,j3   ,k3   ,ivar,idim) &"
  write(ilun,format)"                   & -flux(i,i3+i0,j3+j0,k3+k0,ivar,idim))"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        do ivar=1,3"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              unew(ind_cell(i),nvar+ivar)=unew(ind_cell(i),nvar+ivar)+ &"
  write(ilun,format)"                   & (flux(i,i3   ,j3   ,k3   ,neul+ivar,idim) &"
  write(ilun,format)"                   & -flux(i,i3+i0,j3+j0,k3+k0,neul+ivar,idim))"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        if(pressure_fix)then"
  write(ilun,format)"        ! Update velocity divergence"
  write(ilun,format)"        do i=1,ncache"
  write(ilun,format)"           divu(ind_cell(i))=divu(ind_cell(i))+ &"
  write(ilun,format)"                & (tmp(i,i3   ,j3   ,k3   ,1,idim) &"
  write(ilun,format)"                & -tmp(i,i3+i0,j3+j0,k3+k0,1,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Update internal energy"
  write(ilun,format)"        do i=1,ncache"
  write(ilun,format)"           enew(ind_cell(i))=enew(ind_cell(i))+ &"
  write(ilun,format)"                & (tmp(i,i3   ,j3   ,k3   ,2,idim) &"
  write(ilun,format)"                & -tmp(i,i3+i0,j3+j0,k3+k0,2,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  !----------------------------------------------------------------"
  write(ilun,format)"  ! Warning, this has to be done in a separate loop !"
  write(ilun,format)"  ! If merged with the previous loop, unew(nvar-3) and unew(nvar-2)"
  write(ilun,format)"  ! are overwritten with fluxes (when idim=2,3)"
  write(ilun,format)"  !----------------------------------------------------------------"
  write(ilun,format)"  if(radiative_nimhdheating .and. (nambipolar.eq.1 .or. nmagdiffu.eq.1))then"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do k2=k2min,k2max"
  write(ilun,format)"        do j2=j2min,j2max"
  write(ilun,format)"        do i2=i2min,i2max"
  write(ilun,format)"           ind_son=1+i2+2*j2+4*k2"
  write(ilun,format)"           iskip=ncoarse+(ind_son-1)*ngridmax"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           i3=1+i2"
  write(ilun,format)"           j3=1+j2"
  write(ilun,format)"           k3=1+k2"
  write(ilun,format)"           "
  write(ilun,format)"           ! update jcenter"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              unew(ind_cell(i),nvar-4+idim)=jcell(i,i3   ,j3   ,k3   ,idim)"
  write(ilun,format)"           end do"
  write(ilun,format)"        enddo"
  write(ilun,format)"        enddo"
  write(ilun,format)"        enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !---------------------------------------------------------"
  write(ilun,format)"  ! Conservative update at level ilevel for induction system"
  write(ilun,format)"  !---------------------------------------------------------"
  write(ilun,format)"  do k3=k3min,k3max"
  write(ilun,format)"  do j3=j3min,j3max"
  write(ilun,format)"  do i3=1,2"
  write(ilun,format)"     ind_son=i3+2*(j3-1)+4*(k3-1)"
  write(ilun,format)"     iskip=ncoarse+(ind_son-1)*ngridmax"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Update Bx using constraint transport"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        dflux_x=( emfy(i,i3,j3,k3)-emfy(i,i3,j3,k3+1) ) &"
  write(ilun,format)"          &    -( emfz(i,i3,j3,k3)-emfz(i,i3,j3+1,k3) )"
  write(ilun,format)"        unew(ind_cell(i),neul+1)=unew(ind_cell(i),neul+1)+dflux_x"
  write(ilun,format)"        dflux_x=( emfy(i,i3+1,j3,k3)-emfy(i,i3+1,j3,k3+1) ) &"
  write(ilun,format)"          &    -( emfz(i,i3+1,j3,k3)-emfz(i,i3+1,j3+1,k3) )  "
  write(ilun,format)"        unew(ind_cell(i),nvar+1)=unew(ind_cell(i),nvar+1)+dflux_x"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#if NDIM>1  "
  write(ilun,format)"  do k3=k3min,k3max"
  write(ilun,format)"  do j3=1,2"
  write(ilun,format)"  do i3=1,2"
  write(ilun,format)"     ind_son=i3+2*(j3-1)+4*(k3-1)"
  write(ilun,format)"     iskip=ncoarse+(ind_son-1)*ngridmax"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Update By using constraint transport"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        dflux_y=( emfz(i,i3,j3,k3)-emfz(i,i3+1,j3,k3) ) &"
  write(ilun,format)"          &    -( emfx(i,i3,j3,k3)-emfx(i,i3,j3,k3+1) )"
  write(ilun,format)"        unew(ind_cell(i),neul+2)=unew(ind_cell(i),neul+2)+dflux_y"
  write(ilun,format)"        dflux_y=( emfz(i,i3,j3+1,k3)-emfz(i,i3+1,j3+1,k3) ) &"
  write(ilun,format)"          &    -( emfx(i,i3,j3+1,k3)-emfx(i,i3,j3+1,k3+1) )"
  write(ilun,format)"        unew(ind_cell(i),nvar+2)=unew(ind_cell(i),nvar+2)+dflux_y"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  do k3=1,2"
  write(ilun,format)"  do j3=1,2"
  write(ilun,format)"  do i3=1,2"
  write(ilun,format)"     ind_son=i3+2*(j3-1)+4*(k3-1)"
  write(ilun,format)"     iskip=ncoarse+(ind_son-1)*ngridmax"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Update Bz using constraint transport"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        dflux_z=( emfx(i,i3,j3,k3)-emfx(i,i3,j3+1,k3) ) &"
  write(ilun,format)"          &    -( emfy(i,i3,j3,k3)-emfy(i,i3+1,j3,k3) )"
  write(ilun,format)"        unew(ind_cell(i),neul+3)=unew(ind_cell(i),neul+3)+dflux_z"
  write(ilun,format)"        dflux_z=( emfx(i,i3,j3,k3+1)-emfx(i,i3,j3+1,k3+1) ) &"
  write(ilun,format)"          &    -( emfy(i,i3,j3,k3+1)-emfy(i,i3+1,j3,k3+1) )"
  write(ilun,format)"        unew(ind_cell(i),nvar+3)=unew(ind_cell(i),nvar+3)+dflux_z"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(ilevel>levelmin)then"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------"
  write(ilun,format)"  ! Conservative update at level ilevel-1 for the Euler system"
  write(ilun,format)"  !-----------------------------------------------------------"
  write(ilun,format)"  ! Loop over dimensions"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     i0=0; j0=0; k0=0"
  write(ilun,format)"     if(idim==1)i0=1"
  write(ilun,format)"     if(idim==2)j0=1"
  write(ilun,format)"     if(idim==3)k0=1"
  write(ilun,format)"     "
  write(ilun,format)"     !----------------------"
  write(ilun,format)"     ! Left flux at boundary"
  write(ilun,format)"     !----------------------     "
  write(ilun,format)"     ! Check if grids sits near left boundary"
  write(ilun,format)"     ! and gather neighbor father cells index"
  write(ilun,format)"     nb_noneigh=0"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        if (son(nbor(ind_grid(i),2*idim-1))==0) then"
  write(ilun,format)"           nb_noneigh = nb_noneigh + 1"
  write(ilun,format)"           ind_buffer(nb_noneigh) = nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           ind_cell(nb_noneigh) = i"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Conservative update of new state variables"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"        ! Loop over boundary cells"
  write(ilun,format)"        do k3=k3min,k3max-k0"
  write(ilun,format)"        do j3=j3min,j3max-j0"
  write(ilun,format)"        do i3=i3min,i3max-i0"
  write(ilun,format)"           do i=1,nb_noneigh"
  write(ilun,format)"              unew(ind_buffer(i),ivar)=unew(ind_buffer(i),ivar) &"
  write(ilun,format)"                   & -flux(ind_cell(i),i3,j3,k3,ivar,idim)*oneontwotondim"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     do ivar=1,3"
  write(ilun,format)"        ! Loop over boundary cells"
  write(ilun,format)"        do k3=k3min,k3max-k0"
  write(ilun,format)"        do j3=j3min,j3max-j0"
  write(ilun,format)"        do i3=i3min,i3max-i0"
  write(ilun,format)"           do i=1,nb_noneigh"
  write(ilun,format)"              unew(ind_buffer(i),nvar+ivar)=unew(ind_buffer(i),nvar+ivar) &"
  write(ilun,format)"                   & -flux(ind_cell(i),i3,j3,k3,neul+ivar,idim)*oneontwotondim"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(pressure_fix)then"
  write(ilun,format)"     ! Update velocity divergence"
  write(ilun,format)"     do k3=k3min,k3max-k0"
  write(ilun,format)"     do j3=j3min,j3max-j0"
  write(ilun,format)"     do i3=i3min,i3max-i0"
  write(ilun,format)"        do i=1,nb_noneigh"
  write(ilun,format)"           divu(ind_buffer(i))=divu(ind_buffer(i)) &"
  write(ilun,format)"                & -tmp(ind_cell(i),i3,j3,k3,1,idim)*oneontwotondim"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Update internal energy"
  write(ilun,format)"     do k3=k3min,k3max-k0"
  write(ilun,format)"     do j3=j3min,j3max-j0"
  write(ilun,format)"     do i3=i3min,i3max-i0"
  write(ilun,format)"        do i=1,nb_noneigh"
  write(ilun,format)"           enew(ind_buffer(i))=enew(ind_buffer(i)) &"
  write(ilun,format)"                & -tmp(ind_cell(i),i3,j3,k3,2,idim)*oneontwotondim"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end if"
  write(ilun,format)"     "
  write(ilun,format)"     !-----------------------"
  write(ilun,format)"     ! Right flux at boundary"
  write(ilun,format)"     !-----------------------     "
  write(ilun,format)"     ! Check if grids sits near right boundary"
  write(ilun,format)"     ! and gather neighbor father cells index"
  write(ilun,format)"     nb_noneigh=0"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        if (son(nbor(ind_grid(i),2*idim))==0) then"
  write(ilun,format)"           nb_noneigh = nb_noneigh + 1"
  write(ilun,format)"           ind_buffer(nb_noneigh) = nbor(ind_grid(i),2*idim)"
  write(ilun,format)"           ind_cell(nb_noneigh) = i"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Conservative update of new state variables"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"        ! Loop over boundary cells"
  write(ilun,format)"        do k3=k3min+k0,k3max"
  write(ilun,format)"        do j3=j3min+j0,j3max"
  write(ilun,format)"        do i3=i3min+i0,i3max"
  write(ilun,format)"           do i=1,nb_noneigh"
  write(ilun,format)"              unew(ind_buffer(i),ivar)=unew(ind_buffer(i),ivar) &"
  write(ilun,format)"                   & +flux(ind_cell(i),i3+i0,j3+j0,k3+k0,ivar,idim)*oneontwotondim"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     do ivar=1,3"
  write(ilun,format)"        ! Loop over boundary cells"
  write(ilun,format)"        do k3=k3min+k0,k3max"
  write(ilun,format)"        do j3=j3min+j0,j3max"
  write(ilun,format)"        do i3=i3min+i0,i3max"
  write(ilun,format)"           do i=1,nb_noneigh"
  write(ilun,format)"              unew(ind_buffer(i),nvar+ivar)=unew(ind_buffer(i),nvar+ivar) &"
  write(ilun,format)"                   & +flux(ind_cell(i),i3+i0,j3+j0,k3+k0,neul+ivar,idim)*oneontwotondim"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(pressure_fix)then"
  write(ilun,format)"     ! Update velocity divergence"
  write(ilun,format)"     do k3=k3min+k0,k3max"
  write(ilun,format)"     do j3=j3min+j0,j3max"
  write(ilun,format)"     do i3=i3min+i0,i3max"
  write(ilun,format)"        do i=1,nb_noneigh"
  write(ilun,format)"           divu(ind_buffer(i))=divu(ind_buffer(i)) &"
  write(ilun,format)"                & +tmp(ind_cell(i),i3+i0,j3+j0,k3+k0,1,idim)*oneontwotondim"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Update internal energy"
  write(ilun,format)"     do k3=k3min+k0,k3max"
  write(ilun,format)"     do j3=j3min+j0,j3max"
  write(ilun,format)"     do i3=i3min+i0,i3max"
  write(ilun,format)"        do i=1,nb_noneigh"
  write(ilun,format)"           enew(ind_buffer(i))=enew(ind_buffer(i)) &"
  write(ilun,format)"                & +tmp(ind_cell(i),i3+i0,j3+j0,k3+k0,2,idim)*oneontwotondim"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over dimensions"
  write(ilun,format)""
  write(ilun,format)"#if NDIM>1  "
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  ! Conservative update at level ilevel-1 for the induction system"
  write(ilun,format)"  !---------------------------------------------------------------"
  write(ilun,format)"  i1=1; j1=0; k1=0"
  write(ilun,format)"  if(ndim>1)j1=1"
  write(ilun,format)"  if(ndim>2)k1=1"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------"
  write(ilun,format)"  ! Deal with 4 EMFz edges"
  write(ilun,format)"  !--------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse Bx and By using fine EMFz on X=0 and Y=0 grid edge"
  write(ilun,format)"  ind_father1=1+(i1  )+3*(j1-1)+9*(k1  )"
  write(ilun,format)"  ind_father2=1+(i1-1)+3*(j1-1)+9*(k1  )"
  write(ilun,format)"  ind_father3=1+(i1-1)+3*(j1  )+9*(k1  )"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfz(i,1,1,1)+emfz(i,1,1,2))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,1+neul)=unew(ind_buffer1,1+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer2,1+nvar)=unew(ind_buffer2,1+nvar)+dflux"
  write(ilun,format)"     unew(ind_buffer2,2+nvar)=unew(ind_buffer2,2+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer3,2+neul)=unew(ind_buffer3,2+neul)-dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,1+nvar)=unew(ind_buffer3,1+nvar)-dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,2+nvar)=unew(ind_buffer1,2+nvar)+dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse Bx and By using fine EMFz on X=0 and Y=1 grid edge"
  write(ilun,format)"  ind_father1=1+(i1-1)+3*(j1  )+9*(k1  )"
  write(ilun,format)"  ind_father2=1+(i1-1)+3*(j1+1)+9*(k1  )"
  write(ilun,format)"  ind_father3=1+(i1  )+3*(j1+1)+9*(k1  )"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfz(i,1,3,1)+emfz(i,1,3,2))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,2+nvar)=unew(ind_buffer1,2+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer2,2+neul)=unew(ind_buffer2,2+neul)-dflux"
  write(ilun,format)"     unew(ind_buffer2,1+nvar)=unew(ind_buffer2,1+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer3,1+neul)=unew(ind_buffer3,1+neul)-dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,2+neul)=unew(ind_buffer3,2+neul)+dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,1+nvar)=unew(ind_buffer1,1+nvar)+dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse Bx and By using fine EMFz on X=1 and Y=1 grid edge"
  write(ilun,format)"  ind_father1=1+(i1  )+3*(j1+1)+9*(k1  )"
  write(ilun,format)"  ind_father2=1+(i1+1)+3*(j1+1)+9*(k1  )"
  write(ilun,format)"  ind_father3=1+(i1+1)+3*(j1  )+9*(k1  )"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfz(i,3,3,1)+emfz(i,3,3,2))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,1+nvar)=unew(ind_buffer1,1+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer2,1+neul)=unew(ind_buffer2,1+neul)-dflux"
  write(ilun,format)"     unew(ind_buffer2,2+neul)=unew(ind_buffer2,2+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer3,2+nvar)=unew(ind_buffer3,2+nvar)+dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,1+neul)=unew(ind_buffer3,1+neul)+dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,2+neul)=unew(ind_buffer1,2+neul)-dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse Bx and By using fine EMFz on X=1 and Y=0 grid edge"
  write(ilun,format)"  ind_father1=1+(i1+1)+3*(j1  )+9*(k1  )"
  write(ilun,format)"  ind_father2=1+(i1+1)+3*(j1-1)+9*(k1  )"
  write(ilun,format)"  ind_father3=1+(i1  )+3*(j1-1)+9*(k1  )"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfz(i,3,1,1)+emfz(i,3,1,2))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,2+neul)=unew(ind_buffer1,2+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer2,2+nvar)=unew(ind_buffer2,2+nvar)+dflux"
  write(ilun,format)"     unew(ind_buffer2,1+neul)=unew(ind_buffer2,1+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer3,1+nvar)=unew(ind_buffer3,1+nvar)+dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,2+nvar)=unew(ind_buffer3,2+nvar)-dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,1+neul)=unew(ind_buffer1,1+neul)-dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"  !--------------------------------------"
  write(ilun,format)"  ! Deal with 4 EMFx edges"
  write(ilun,format)"  !--------------------------------------"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  ! Update coarse By and Bz using fine EMFx on Y=0 and Z=0 grid edge"
  write(ilun,format)"  ind_father1=1+(i1  )+3*(j1  )+9*(k1-1)"
  write(ilun,format)"  ind_father2=1+(i1  )+3*(j1-1)+9*(k1-1)"
  write(ilun,format)"  ind_father3=1+(i1  )+3*(j1-1)+9*(k1  )"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfx(i,1,1,1)+emfx(i,2,1,1))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,2+neul)=unew(ind_buffer1,2+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer2,2+nvar)=unew(ind_buffer2,2+nvar)+dflux"
  write(ilun,format)"     unew(ind_buffer2,3+nvar)=unew(ind_buffer2,3+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer3,3+neul)=unew(ind_buffer3,3+neul)-dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer1,3+nvar)=unew(ind_buffer1,3+nvar)+dflux*0.5"
  write(ilun,format)"        unew(ind_buffer3,2+nvar)=unew(ind_buffer3,2+nvar)-dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse By and Bz using fine EMFx on Y=0 and Z=1 grid edge"
  write(ilun,format)"  ind_father1=1+(i1  )+3*(j1-1)+9*(k1  )"
  write(ilun,format)"  ind_father2=1+(i1  )+3*(j1-1)+9*(k1+1)"
  write(ilun,format)"  ind_father3=1+(i1  )+3*(j1  )+9*(k1+1)"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfx(i,1,1,3)+emfx(i,2,1,3))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,3+nvar)=unew(ind_buffer1,3+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer2,3+neul)=unew(ind_buffer2,3+neul)-dflux"
  write(ilun,format)"     unew(ind_buffer2,2+nvar)=unew(ind_buffer2,2+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer3,2+neul)=unew(ind_buffer3,2+neul)-dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer1,2+nvar)=unew(ind_buffer1,2+nvar)+dflux*0.5"
  write(ilun,format)"        unew(ind_buffer3,3+neul)=unew(ind_buffer3,3+neul)+dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse By and Bz using fine EMFx on Y=1 and Z=1 grid edge"
  write(ilun,format)"  ind_father1=1+(i1  )+3*(j1  )+9*(k1+1)"
  write(ilun,format)"  ind_father2=1+(i1  )+3*(j1+1)+9*(k1+1)"
  write(ilun,format)"  ind_father3=1+(i1  )+3*(j1+1)+9*(k1  )"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfx(i,1,3,3)+emfx(i,2,3,3))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,2+nvar)=unew(ind_buffer1,2+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer2,2+neul)=unew(ind_buffer2,2+neul)-dflux"
  write(ilun,format)"     unew(ind_buffer2,3+neul)=unew(ind_buffer2,3+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer3,3+nvar)=unew(ind_buffer3,3+nvar)+dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,2+neul)=unew(ind_buffer3,2+neul)+dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,3+neul)=unew(ind_buffer1,3+neul)-dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse By and Bz using fine EMFx on Y=1 and Z=0 grid edge"
  write(ilun,format)"  ind_father1=1+(i1  )+3*(j1+1)+9*(k1  )"
  write(ilun,format)"  ind_father2=1+(i1  )+3*(j1+1)+9*(k1-1)"
  write(ilun,format)"  ind_father3=1+(i1  )+3*(j1  )+9*(k1-1)"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfx(i,1,3,1)+emfx(i,2,3,1))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,3+neul)=unew(ind_buffer1,3+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer2,3+nvar)=unew(ind_buffer2,3+nvar)+dflux"
  write(ilun,format)"     unew(ind_buffer2,2+neul)=unew(ind_buffer2,2+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer3,2+nvar)=unew(ind_buffer3,2+nvar)+dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,3+nvar)=unew(ind_buffer3,3+nvar)-dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,2+neul)=unew(ind_buffer1,2+neul)-dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------"
  write(ilun,format)"  ! Deal with 4 EMFy edges"
  write(ilun,format)"  !--------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse Bx and Bz using fine EMFy on X=0 and Z=0 grid edge"
  write(ilun,format)"  ind_father1=1+(i1  )+3*(j1  )+9*(k1-1)"
  write(ilun,format)"  ind_father2=1+(i1-1)+3*(j1  )+9*(k1-1)"
  write(ilun,format)"  ind_father3=1+(i1-1)+3*(j1  )+9*(k1  )"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfy(i,1,1,1)+emfy(i,1,2,1))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,1+neul)=unew(ind_buffer1,1+neul)-dflux"
  write(ilun,format)"     unew(ind_buffer2,1+nvar)=unew(ind_buffer2,1+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer2,3+nvar)=unew(ind_buffer2,3+nvar)+dflux"
  write(ilun,format)"     unew(ind_buffer3,3+neul)=unew(ind_buffer3,3+neul)+dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,1+nvar)=unew(ind_buffer3,1+nvar)+dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,3+nvar)=unew(ind_buffer1,3+nvar)-dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse Bx and Bz using fine EMFy on X=0 and Z=1 grid edge"
  write(ilun,format)"  ind_father1=1+(i1-1)+3*(j1  )+9*(k1  )"
  write(ilun,format)"  ind_father2=1+(i1-1)+3*(j1  )+9*(k1+1)"
  write(ilun,format)"  ind_father3=1+(i1  )+3*(j1  )+9*(k1+1)"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfy(i,1,1,3)+emfy(i,1,2,3))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,3+nvar)=unew(ind_buffer1,3+nvar)+dflux"
  write(ilun,format)"     unew(ind_buffer2,3+neul)=unew(ind_buffer2,3+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer2,1+nvar)=unew(ind_buffer2,1+nvar)+dflux"
  write(ilun,format)"     unew(ind_buffer3,1+neul)=unew(ind_buffer3,1+neul)+dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,3+neul)=unew(ind_buffer3,3+neul)-dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,1+nvar)=unew(ind_buffer1,1+nvar)-dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse Bx and Bz using fine EMFy on X=1 and Z=1 grid edge"
  write(ilun,format)"  ind_father1=1+(i1  )+3*(j1  )+9*(k1+1)"
  write(ilun,format)"  ind_father2=1+(i1+1)+3*(j1  )+9*(k1+1)"
  write(ilun,format)"  ind_father3=1+(i1+1)+3*(j1  )+9*(k1  )"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfy(i,3,1,3)+emfy(i,3,2,3))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,1+nvar)=unew(ind_buffer1,1+nvar)+dflux"
  write(ilun,format)"     unew(ind_buffer2,1+neul)=unew(ind_buffer2,1+neul)+dflux"
  write(ilun,format)"     unew(ind_buffer2,3+neul)=unew(ind_buffer2,3+neul)-dflux"
  write(ilun,format)"     unew(ind_buffer3,3+nvar)=unew(ind_buffer3,3+nvar)-dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,1+neul)=unew(ind_buffer3,1+neul)-dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,3+neul)=unew(ind_buffer1,3+neul)+dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update coarse Bx and Bz using fine EMFy on X=1 and Z=0 grid edge"
  write(ilun,format)"  ind_father1=1+(i1+1)+3*(j1  )+9*(k1  )"
  write(ilun,format)"  ind_father2=1+(i1+1)+3*(j1  )+9*(k1-1)"
  write(ilun,format)"  ind_father3=1+(i1  )+3*(j1  )+9*(k1-1)"
  write(ilun,format)"  do i=1,ncache"
  write(ilun,format)"     ind_buffer1=nbors_father_cells(i,ind_father1)"
  write(ilun,format)"     ind_buffer2=nbors_father_cells(i,ind_father2)"
  write(ilun,format)"     ind_buffer3=nbors_father_cells(i,ind_father3)"
  write(ilun,format)"     weight=1.0"
  write(ilun,format)"     if(son(ind_buffer1)>0.and.son(ind_buffer3)>0) cycle"
  write(ilun,format)"     if(son(ind_buffer1)>0.or.son(ind_buffer2)>0.or.son(ind_buffer3)>0)weight=0.5"
  write(ilun,format)"     dflux=(emfy(i,3,1,1)+emfy(i,3,2,1))*0.25*weight"
  write(ilun,format)"     unew(ind_buffer1,3+neul)=unew(ind_buffer1,3+neul)-dflux"
  write(ilun,format)"     unew(ind_buffer2,3+nvar)=unew(ind_buffer2,3+nvar)-dflux"
  write(ilun,format)"     unew(ind_buffer2,1+neul)=unew(ind_buffer2,1+neul)-dflux"
  write(ilun,format)"     unew(ind_buffer3,1+nvar)=unew(ind_buffer3,1+nvar)-dflux"
  write(ilun,format)"     if(son(ind_buffer1)==0.and.son(ind_buffer2)==0.and.son(ind_buffer3)==0) then"
  write(ilun,format)"        unew(ind_buffer3,3+nvar)=unew(ind_buffer3,3+nvar)+dflux*0.5"
  write(ilun,format)"        unew(ind_buffer1,1+neul)=unew(ind_buffer1,1+neul)+dflux*0.5"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine godfine1"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine rad_force_fine(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters,ONLY:mu_gas,Tr_floor,eray_min,nu_min_hz,nu_max_hz,frad"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine sets array uold to its new value unew after the"
  write(ilun,format)"  ! hydro step."
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  integer::i,j,k,ivar,ind,iskip,nx_loc,info"
  write(ilun,format)"  real(dp)::scale,d,u,v,w,A,B,C,d_old"
  write(ilun,format)"  real(dp)::e_mag,e_kin,e_cons,e_prim,e_trunc,div,dx,fact,e_r"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector,0:twondim),save::igridn"
  write(ilun,format)"  integer ,dimension(1:nvector,1:ndim),save::ind_left,ind_right"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:ngrp),save::Erg,Erd"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:ndim),save::velg,veld"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::dx_g,dx_d"
  write(ilun,format)"  real(dp)::rosseland_ana"
  write(ilun,format)"  real(dp)::Pgdivu,u_square,d_loc,Tp_loc,Tr_loc,cal_Teg"
  write(ilun,format)""
  write(ilun,format)"  integer::ncache,igrid,ngrid,idim,id1,ig1,ih1,id2,ig2,ih2,igroup"
  write(ilun,format)"  integer  ,dimension(1:3,1:2,1:8)::iii,jjj"
  write(ilun,format)"  real(dp)::dx_loc,surf_loc,vol_loc,usquare,emag,erad_loc,ekin,eps,cv,pp_eos"
  write(ilun,format)"  real(dp)::kappa_R,gradEr_norm,gradEr_norm2,R,lambda,lambda_fld,chi,PgmErdivu,gradEru"
  write(ilun,format)"  real(dp) ,dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp) ,dimension(1:ndim,1:ngrp)::gradEr"
  write(ilun,format)"  real(dp) ,dimension(1:ndim,1:ndim)::divu_loc"
  write(ilun,format)"  real(dp) ,dimension(1:ndim,1:ndim,1:ngrp)::Pg"
  write(ilun,format)"  real(dp) ,dimension(1:ndim       )::u_loc"
  write(ilun,format)"  real(dp) :: nuPrDivu,nuPr,nuPl,Pr_nu"
  write(ilun,format)"  real(dp), dimension(1:5) :: Pr_temp"
  write(ilun,format)""
  write(ilun,format)"  !  EOS"
  write(ilun,format)"  real(dp) :: dd,ee,cmp_Cv_eos"
  write(ilun,format)"  integer  :: ht "
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  nx_loc=icoarse_max-icoarse_min+1"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx=0.5d0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale ! Warning: scale factor already done in dx"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)"  surf_loc=dx_loc**(ndim-1)"
  write(ilun,format)""
  write(ilun,format)"  iii(1,1,1:8)=(/1,0,1,0,1,0,1,0/); jjj(1,1,1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"  iii(1,2,1:8)=(/0,2,0,2,0,2,0,2/); jjj(1,2,1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"  iii(2,1,1:8)=(/3,3,0,0,3,3,0,0/); jjj(2,1,1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"  iii(2,2,1:8)=(/0,0,4,4,0,0,4,4/); jjj(2,2,1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"  iii(3,1,1:8)=(/5,5,5,5,0,0,0,0/); jjj(3,1,1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"  iii(3,2,1:8)=(/0,0,0,0,6,6,6,6/); jjj(3,2,1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)""
  write(ilun,format)"if(fld)then    "
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector   "
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Gather neighboring grids"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        igridn(i,0)=ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_left (i,idim)=nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           ind_right(i,idim)=nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1)=son(ind_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  )=son(ind_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        "
  write(ilun,format)"        ! Compute central cell index"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"#if USE_FLD==1        "
  write(ilun,format)"        ! Gather neighboring temperature"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           id1=jjj(idim,1,ind); ig1=iii(idim,1,ind)"
  write(ilun,format)"           ih1=ncoarse+(id1-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(igridn(i,ig1)>0)then"
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)"                    Erg(i,idim,igroup) = max(uold(igridn(i,ig1)+ih1,firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 velg(i,idim,1:ndim) = uold(igridn(i,ig1)+ih1,2:ndim+1)/uold(igridn(i,ig1)+ih1,1)"
  write(ilun,format)"                 dx_g(i,idim) = dx_loc"
  write(ilun,format)"              else"
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)"                    Erg(i,idim,igroup) = max(uold(ind_left(i,idim),firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 velg(i,idim,1:ndim) = uold(ind_left(i,idim),2:ndim+1)/uold(ind_left(i,idim),1)"
  write(ilun,format)"                 dx_g(i,idim) = dx_loc*1.5_dp"
  write(ilun,format)"              end if"
  write(ilun,format)"           enddo"
  write(ilun,format)"           id2=jjj(idim,2,ind); ig2=iii(idim,2,ind)"
  write(ilun,format)"           ih2=ncoarse+(id2-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(igridn(i,ig2)>0)then"
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)"                    Erd(i,idim,igroup) = max(uold(igridn(i,ig2)+ih2,firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 veld(i,idim,1:ndim)= uold(igridn(i,ig2)+ih2,2:ndim+1)/uold(igridn(i,ig2)+ih2,1)"
  write(ilun,format)"                 dx_d(i,idim)=dx_loc"
  write(ilun,format)"              else "
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)"                    Erd(i,idim,igroup) = max(uold(ind_right(i,idim),firstindex_er+igroup),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 veld(i,idim,1:ndim)= uold(ind_right(i,idim),2:ndim+1)/uold(ind_right(i,idim),1)"
  write(ilun,format)"                 dx_d(i,idim)=dx_loc*1.5_dp"
  write(ilun,format)"              end if"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"       ! End loop over dimensions"
  write(ilun,format)"  "
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           !compute divu"
  write(ilun,format)"           do j=1,ndim"
  write(ilun,format)"              do k=1,ndim"
  write(ilun,format)"                 divu_loc(j,k) = (veld(i,j,k)-velg(i,j,k))/(dx_g(i,j)+dx_d(i,j))"
  write(ilun,format)"              enddo"
  write(ilun,format)"              do igroup=1,ngrp"
  write(ilun,format)"                 gradEr(j,igroup) = (Erd(i,j,igroup)-Erg(i,j,igroup))/(dx_g(i,j)+dx_d(i,j))"
  write(ilun,format)"              enddo"
  write(ilun,format)"           enddo"
  write(ilun,format)""
  write(ilun,format)"           d_loc = uold(ind_cell(i),1)*scale_d"
  write(ilun,format)"           u_loc(1:ndim) = uold(ind_cell(i),2:ndim+1)/uold(ind_cell(i),1)"
  write(ilun,format)"           "
  write(ilun,format)"           usquare=0.0"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              usquare=usquare+(uold(ind_cell(i),idim+1)/uold(ind_cell(i),1))**2"
  write(ilun,format)"           end do"
  write(ilun,format)"           "
  write(ilun,format)"           ! Compute total magnetic energy"
  write(ilun,format)"           emag = 0.0d0"
  write(ilun,format)"           do ivar=1,3"
  write(ilun,format)"              emag = emag + 0.125d0*(uold(ind_cell(i),5+ivar) &"
  write(ilun,format)"                   &  +uold(ind_cell(i),nvar+ivar))**2"
  write(ilun,format)"           end do"
  write(ilun,format)"           erad_loc=0.0D0"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do igroup=1,nener"
  write(ilun,format)"              erad_loc = erad_loc + uold(ind_cell(i),8+igroup)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif"
  write(ilun,format)"           d     = uold(ind_cell(i),1)"
  write(ilun,format)"           ekin  = d*usquare/2.0"
  write(ilun,format)"           ! Compute gas temperature in cgs"
  write(ilun,format)"           eps   = uold(ind_cell(i),5)-ekin-emag-erad_loc"
  write(ilun,format)"           if(energy_fix)eps   = uold(ind_cell(i),nvar) ! comment this for radiative shock"
  write(ilun,format)"           ! Compute gas temperature in cgs"
  write(ilun,format)"           call temperature_eos(d,eps,Tp_loc,ht)"
  write(ilun,format)""
  write(ilun,format)"           frad(ind_cell(i),1:ndim)=0.0d0"
  write(ilun,format)"           "
  write(ilun,format)"           ! Compute radiative pressure in all groups"
  write(ilun,format)"           do igroup=1,ngrp"
  write(ilun,format)"              "
  write(ilun,format)"              ! Compute radiative pressure"
  write(ilun,format)"              Tr_loc = cal_Teg(uold(ind_cell(i),firstindex_er+igroup)*scale_d*scale_v**2,igroup)              "
  write(ilun,format)"              kappa_R = rosseland_ana(d_loc,Tp_loc,Tr_loc,igroup)/scale_kappa"
  write(ilun,format)"              gradEr_norm2 = (sum(gradEr(1:ndim,igroup)**2))"
  write(ilun,format)"              gradEr_norm  = (gradEr_norm2)**0.5"
  write(ilun,format)"              R =   max(1.d-10,gradEr_norm/(max(uold(ind_cell(i),firstindex_er+igroup),eray_min/(scale_d*scale_v**2))*kappa_R))"
  write(ilun,format)"              lambda = lambda_fld(R)"
  write(ilun,format)"              chi = lambda + (lambda*R)**2"
  write(ilun,format)"              "
  write(ilun,format)"              frad(ind_cell(i),1:ndim) =  frad(ind_cell(i),1:ndim) + lambda*gradEr(1:ndim,igroup)/d"
  write(ilun,format)"           enddo !end loop over rad groups"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ! Compute density and temperature for opacity"
  write(ilun,format)"           d_loc = uold(ind_cell(i),1)*scale_d"
  write(ilun,format)"           "
  write(ilun,format)"           usquare=zero"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              usquare=usquare+(uold(ind_cell(i),idim+1)/uold(ind_cell(i),1))**2"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           emag = zero"
  write(ilun,format)"           do ivar=1,3"
  write(ilun,format)"              emag = emag + 0.125d0*(uold(ind_cell(i),5+ivar) &"
  write(ilun,format)"                   &  +uold(ind_cell(i),nvar+ivar))**2"
  write(ilun,format)"           end do"
  write(ilun,format)"           erad_loc=zero"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do igroup=1,nener"
  write(ilun,format)"              erad_loc = erad_loc + uold(ind_cell(i),8+igroup)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif"
  write(ilun,format)"           d     = uold(ind_cell(i),1)"
  write(ilun,format)"           ekin  = d*usquare/2.0"
  write(ilun,format)"           ! Compute gas temperature in cgs"
  write(ilun,format)"           eps   = uold(ind_cell(i),5)-ekin-emag-erad_loc"
  write(ilun,format)"           call temperature_eos(d,eps,Tp_loc,ht)"
  write(ilun,format)""
  write(ilun,format)"           frad(ind_cell(i),1:ndim)=zero"
  write(ilun,format)""
  write(ilun,format)"           do igroup=1,ngrp"
  write(ilun,format)""
  write(ilun,format)"              Tr_loc = cal_Teg(uold(ind_cell(i),firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"              kappa_R = rosseland_ana(d_loc,Tp_loc,Tr_loc,igroup)/scale_kappa"
  write(ilun,format)""
  write(ilun,format)"              ! divide by d because equation over u and not d*u"
  write(ilun,format)"              frad(ind_cell(i),1) =  frad(ind_cell(i),1) + kappa_R*uold(ind_cell(i),firstindex_fr+igroup)/(clight/scale_v)/d"
  write(ilun,format)"              frad(ind_cell(i),2) =  frad(ind_cell(i),2) + kappa_R*uold(ind_cell(i),firstindex_fr+igroup+ngrp)/(clight/scale_v)/d"
  write(ilun,format)"              frad(ind_cell(i),3) =  frad(ind_cell(i),3) + kappa_R*uold(ind_cell(i),firstindex_fr+igroup+2*ngrp)/(clight/scale_v)/d"
  write(ilun,format)""
  write(ilun,format)"           enddo !end loop over rad groups"
  write(ilun,format)"        enddo"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     enddo"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)"endif"
  write(ilun,format)"  "
  write(ilun,format)"111 format('   Entering rad_force_fine for level ',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine rad_force_fine"
  write(ilun,format)"../patch/rt/frig_main/old_sink_particle.f90"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine create_sink"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use clfind_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------------"
  write(ilun,format)"  ! sink creation routine"
  write(ilun,format)"  ! -remove all cloud particles, keep only global sink arrays"
  write(ilun,format)"  ! -call clumpfinder for potential relevant peaks"
  write(ilun,format)"  ! -flag peaks which are eligible for sink formation (flag 2)"
  write(ilun,format)"  ! -new sink particle are created "
  write(ilun,format)"  ! -new cloud particles are created"
  write(ilun,format)"  ! -cloud particles are scattered to grid"
  write(ilun,format)"  ! -accretion routine is called (with on_creation=.true.)"
  write(ilun,format)"  !----------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::ilevel,ivar"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)' Entering create_sink'"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Merge all particles to level 1"
  write(ilun,format)"  do ilevel=levelmin-1,1,-1"
  write(ilun,format)"     call merge_tree_fine(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Remove all particle clouds around old sinks (including the central one)"
  write(ilun,format)"  call kill_entire_cloud(1) "
  write(ilun,format)"  "
  write(ilun,format)"  ! DO NOT MODIFY FLAG2 BETWEEN CLUMP_FINDER AND MAKE_SINK_FROM_CLUMP     "
  write(ilun,format)"  if (create_sinks)then"
  write(ilun,format)"     "
  write(ilun,format)"     ! Run the clump finder,(produce no output, keep clump arrays allocated)"
  write(ilun,format)"     call clump_finder(.false.,.true.)"
  write(ilun,format)"     "
  write(ilun,format)"     ! Trim clumps down to R_accretion ball around peaks "
  write(ilun,format)"     if(clump_core)call trim_clumps"
  write(ilun,format)"     "
  write(ilun,format)"     ! Compute simple additive quantities and means (1st moments)"
  write(ilun,format)"     call compute_clump_properties(uold(1,1))"
  write(ilun,format)"     "
  write(ilun,format)"     ! Compute quantities relative to mean (2nd moments)"
  write(ilun,format)"     call compute_clump_properties_round2(uold(1,1))"
  write(ilun,format)"  "
  write(ilun,format)"     ! Apply all checks and flag cells for sink formation"
  write(ilun,format)"     call flag_formation_sites"
  write(ilun,format)""
  write(ilun,format)"     ! Create new sink particles if relevant"
  write(ilun,format)"     do ilevel=levelmin,nlevelmax"
  write(ilun,format)"        call make_sink_from_clump(ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Deallocate clump finder arrays"
  write(ilun,format)"     deallocate(npeaks_per_cpu)"
  write(ilun,format)"     deallocate(ipeak_start)"
  write(ilun,format)"     if (ntest>0)then"
  write(ilun,format)"        deallocate(icellp)"
  write(ilun,format)"        deallocate(levp)"
  write(ilun,format)"        deallocate(testp_sort)"
  write(ilun,format)"        deallocate(imaxp)"
  write(ilun,format)"     endif"
  write(ilun,format)"     call deallocate_all"
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Merge sink for smbh runs "
  write(ilun,format)"  if (smbh)then"
  write(ilun,format)"    call merge_smbh_sink"
  write(ilun,format)"  else"
  write(ilun,format)"     if(merging_timescale>0.d0)call merge_star_sink"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Create new cloud particles"
  write(ilun,format)"  call create_cloud_from_sink"
  write(ilun,format)""
  write(ilun,format)"  ! Scatter particle to the grid"
  write(ilun,format)"  ! Compute Bondi parameters"
  write(ilun,format)"  do ilevel=1,nlevelmax"
  write(ilun,format)"     call make_tree_fine(ilevel)"
  write(ilun,format)"     call kill_tree_fine(ilevel)"
  write(ilun,format)"     call virtual_tree_fine(ilevel)"
  write(ilun,format)"     call collect_acczone_avg(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Perform first accretion with seed mass"
  write(ilun,format)"  ! Gather particles to levelmin"
  write(ilun,format)"  do ilevel=nlevelmax,levelmin,-1"
  write(ilun,format)"     call grow_sink(ilevel,.true.)"
  write(ilun,format)"     call merge_tree_fine(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update hydro quantities for split cells"
  write(ilun,format)"  if(hydro)then"
  write(ilun,format)"     do ilevel=nlevelmax,levelmin,-1"
  write(ilun,format)"        call upload_fine(ilevel)"
  write(ilun,format)"        do ivar=1,nvar"
  write(ilun,format)"           call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Update boundaries "
  write(ilun,format)"        if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Update the cloud particle properties at levelmin"
  write(ilun,format)"  ! So they match their parent sink properties"
  write(ilun,format)"  call update_cloud(levelmin)"
  write(ilun,format)""
  write(ilun,format)"  ! Effective accretion rate during last coarse step"
  write(ilun,format)"  acc_rate(1:nsink)=acc_rate(1:nsink)/dtnew(levelmin)"
  write(ilun,format)"  ! ir_eff and 5 are ratio of infalling energy which is radiated and protostellar radius"
  write(ilun,format)"  if(ir_feedback)acc_lum(1:nsink)=ir_eff*acc_rate(1:nsink)*msink(1:nsink)/(5*6.955d10/scale_l)"
  write(ilun,format)""
  write(ilun,format)"  ! Compute and print accretion rates"
  write(ilun,format)"  call compute_accretion_rate(.true.)"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine create_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine create_cloud_from_sink"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! This routine creates the whole cloud of particles for each sink, "
  write(ilun,format)"  ! Particles are produced in the right MPI domain and inserted in the "
  write(ilun,format)"  ! linked list at level 1. "
  write(ilun,format)"  ! The cloud radius is dble(ir_cloud)*dx_min, where dx_min is "
  write(ilun,format)"  ! the cell size at levelmax. For cosmo runs, the cloud radius is "
  write(ilun,format)"  ! dx_min/aexp (therefore it is constant in *physical* units)."
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale,dx_min,rr,rmax,rmass"
  write(ilun,format)"  integer ::i,icpu,isink,indp,ii,jj,kk,nx_loc,idim"
  write(ilun,format)"  integer ::ntot,ntot_all,info"
  write(ilun,format)"  logical ::ok_free"
  write(ilun,format)"  real(dp),dimension(1:ndim)::xrel"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xtest"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_part,cc,ind_cloud"
  write(ilun,format)"  logical ,dimension(1:nvector)::ok_true"
  write(ilun,format)"  logical,dimension(1:ndim)::period"
  write(ilun,format)"  logical::in_box"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  "
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  "
  write(ilun,format)"  ok_true=.true."
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,1)==0) return"
  write(ilun,format)"  if(verbose)write(*,*)' Entering create_cloud_from_sink'"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  ! Level 1 linked list"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     if(numbl(icpu,1)>0)then"
  write(ilun,format)"        ind_grid(1)=headl(icpu,1)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  period(1)=(nx==1)"
  write(ilun,format)"  if(ndim>1)period(2)=(ny==1)"
  write(ilun,format)"  if(ndim>2)period(3)=(nz==1)"
  write(ilun,format)"  "
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)""
  write(ilun,format)"  rmax=dble(ir_cloud)*dx_min"
  write(ilun,format)"  rmass=dble(ir_cloud_massive)*dx_min"
  write(ilun,format)"  "
  write(ilun,format)"  do kk=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"     xrel(3)=dble(kk)*dx_min/2.0"
  write(ilun,format)"     do jj=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"        xrel(2)=dble(jj)*dx_min/2.0"
  write(ilun,format)"        do ii=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"           xrel(1)=dble(ii)*dx_min/2.0"
  write(ilun,format)"           rr=sqrt(sum(xrel**2))"
  write(ilun,format)"           if(rr<=rmax)then"
  write(ilun,format)"              do isink=1,nsink"
  write(ilun,format)"                 xtest(1,1:3)=xsink(isink,1:3)+xrel(1:3)"
  write(ilun,format)"                 in_box=.true."
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    if (period(idim) .and. xtest(1,idim)>boxlen)xtest(1,idim)=xtest(1,idim)-boxlen"
  write(ilun,format)"                    if (period(idim) .and. xtest(1,idim)<0.)xtest(1,idim)=xtest(1,idim)+boxlen"
  write(ilun,format)"                    if (xtest(1,idim)<0.0 .or. xtest(1,idim)>boxlen)in_box=.false."
  write(ilun,format)"                 end do"
  write(ilun,format)"                 cc(1)=0"
  write(ilun,format)"                 if(in_box)call cmp_cpumap(xtest,cc,1)"
  write(ilun,format)"                 if(cc(1).eq.myid)then                    "
  write(ilun,format)"                    call remove_free(ind_cloud,1)"
  write(ilun,format)"                    call add_list(ind_cloud,ind_grid,ok_true,1)"
  write(ilun,format)"                    indp=ind_cloud(1)"
  write(ilun,format)"                    idp(indp)=-isink"
  write(ilun,format)"                    levelp(indp)=levelmin"
  write(ilun,format)"                    if (rr<=rmass .and. msink(isink)<mass_sink_direct_force*1.9891d33/(scale_d*scale_l**3))then"
  write(ilun,format)"                       mp(indp)=msink(isink)/dble(ncloud_sink_massive)"
  write(ilun,format)"                    else"
  write(ilun,format)"                       mp(indp)=0."
  write(ilun,format)"                    end if"
  write(ilun,format)"                    xp(indp,1:3)=xtest(1,1:3)"
  write(ilun,format)"                    vp(indp,1:3)=vsink(isink,1:3)"
  write(ilun,format)"                    tp(indp)=tsink(isink)     ! Birth epoch"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     direct_force_sink(isink)=(msink(isink) .ge. mass_sink_direct_force*1.9891d33/(scale_d*scale_l**3))"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)"end subroutine create_cloud_from_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine kill_entire_cloud(ilevel)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine removes cloud particles (including the central one)."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,icpu,ncache,istart"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  logical,dimension(1:nvector)::ok=.true."
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)"  ! Gather sink and cloud particles."
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu+nboundary"
  write(ilun,format)"     if(icpu<=ncpu)then"
  write(ilun,format)"        ncache=numbl(icpu,ilevel)"
  write(ilun,format)"        istart=headl(icpu,ilevel)"
  write(ilun,format)"     else"
  write(ilun,format)"        ncache=numbb(icpu-ncpu,ilevel)"
  write(ilun,format)"        istart=headb(icpu-ncpu,ilevel)"
  write(ilun,format)"     end if"
  write(ilun,format)"     igrid=istart"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,ncache"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0        "
  write(ilun,format)"        ! Count sink and cloud particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif        "
  write(ilun,format)"        ! Gather sink and cloud particles"
  write(ilun,format)"        if(npart2>0)then        "
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only sink particles"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig   "
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                 call remove_list(ind_part,ind_grid_part,ok,ip)"
  write(ilun,format)"                 call add_free_cond(ind_part,ok,ip)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        "
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)then"
  write(ilun,format)"        call remove_list(ind_part,ind_grid_part,ok,ip)"
  write(ilun,format)"        call add_free_cond(ind_part,ok,ip)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"111 format('   Entering kill_cloud for level ',I2)"
  write(ilun,format)"end subroutine kill_entire_cloud"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine collect_acczone_avg(ilevel)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine is used to collect all relevant information to compute the "
  write(ilun,format)"  ! the accretion rates. The information is collected level-by-level when"
  write(ilun,format)"  ! going down in the call tree (leafs at the bottom), while accretion is "
  write(ilun,format)"  ! performed on the way up."
  write(ilun,format)"  ! - first, the volume of each particle is computed. The volume is reduced if"
  write(ilun,format)"  ! sinks are overlapping."
  write(ilun,format)"  ! - then a loop over all particles of ilevel (vectorized) is used to compute "
  write(ilun,format)"  ! the volume-weighted quantities."
  write(ilun,format)"  ! No gaussian accretion kernel is used anymore..."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part,info,ind"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,icpu,nx_loc,isink"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  real(dp)::dx_loc,dx_min,scale,factG"
  write(ilun,format)"  character(LEN=15)::action"
  write(ilun,format)""
  write(ilun,format)"  if(ilevel<levelmin)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)"  action='count'"
  write(ilun,format)"  call count_clouds(ilevel,action)"
  write(ilun,format)""
  write(ilun,format)"  call make_virtual_reverse_dp(rho(1),ilevel)"
  write(ilun,format)"  call make_virtual_fine_dp(rho(1),ilevel)"
  write(ilun,format)""
  write(ilun,format)"  action='weight'"
  write(ilun,format)"  call count_clouds(ilevel,action)"
  write(ilun,format)"  "
  write(ilun,format)"  level_sink_new(1:nsinkmax,ilevel)=.false."
  write(ilun,format)"  "
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx_loc=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)""
  write(ilun,format)"  ! compute (volume weighted) averages over accretion zone"
  write(ilun,format)"  wden=0d0; wvol=0d0; weth=0d0; wmom=0d0; wdiv=0d0"
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     igrid=headl(icpu,ilevel)"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)"        "
  write(ilun,format)"        ! Count sink and cloud particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather sink and cloud particles"
  write(ilun,format)"        if(npart2>0)then"
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only sink particles"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig   "
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                 call collect_acczone_avg_np(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)then"
  write(ilun,format)"        call collect_acczone_avg_np(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over cpus"
  write(ilun,format)""
  write(ilun,format)"  if(nsink>0)then"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(wden,wden_new,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(wvol,wvol_new,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(weth,weth_new,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(wmom,wmom_new,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(wdiv,wdiv_new,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(level_sink_new,level_sink,nsinkmax*(nlevelmax-levelmin+1),MPI_LOGICAL,MPI_LOR,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"     wden_new=wden"
  write(ilun,format)"     wvol_new=wvol"
  write(ilun,format)"     weth_new=weth"
  write(ilun,format)"     wmom_new=wmom"
  write(ilun,format)"     wdiv_new=wdiv"
  write(ilun,format)"     level_sink=level_sink_new"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     weighted_density(isink,ilevel)=wden_new(isink)"
  write(ilun,format)"     weighted_volume(isink,ilevel)=wvol_new(isink)"
  write(ilun,format)"     weighted_momentum(isink,ilevel,1:ndim)=wmom_new(isink,1:ndim)"
  write(ilun,format)"     weighted_ethermal(isink,ilevel)=weth_new(isink)"
  write(ilun,format)"     weighted_divergence(isink,ilevel)=wdiv_new(isink)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering collect_acczone_avg for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine collect_acczone_avg"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine collect_acczone_avg_np(ind_grid,ind_part,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! inner loop of collect_acczone_avg"
  write(ilun,format)"  ! weighted gas quantities and divergence for each particle are computed"
  write(ilun,format)"  ! -> replaces bondi_average and divergence_sink"
  write(ilun,format)"  ! no CIC averaging over quantities anymore as average over whole sink "
  write(ilun,format)"  ! accretion zone is computed"
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::j,irad,nx_loc,isink,divdim,idim,ind"
  write(ilun,format)"  real(dp)::d,u,v=0d0,w=0d0,e"
  write(ilun,format)"  real(dp)::scale,weight,dx_min,one_over_dx_min"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  real(dp)::bx1,bx2,by1,by2,bz1,bz2"
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:nvar+3),save::fluid_var_left,fluid_var_right,fluid_var"
  write(ilun,format)"#else"
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:nvar),save::fluid_var_left,fluid_var_right,fluid_var"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::egas,divpart"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xpart"
  write(ilun,format)"  integer ,dimension(1:nvector),save::cind,cind_right,cind_left"
  write(ilun,format)"  "
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xpart(j,idim)=xp(ind_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  call cic_get_vals(fluid_var,ind_grid,xpart,ind_grid_part,ng,np,ilevel,.true.)"
  write(ilun,format)""
  write(ilun,format)"  ! compute thermal energy"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     d=fluid_var(j,1)"
  write(ilun,format)"     if(d>0.)then"
  write(ilun,format)"        u=fluid_var(j,2)/d"
  write(ilun,format)"        v=fluid_var(j,3)/d"
  write(ilun,format)"        w=fluid_var(j,4)/d"
  write(ilun,format)"        e=fluid_var(j,5)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"        bx1=fluid_var(j,6)"
  write(ilun,format)"        by1=fluid_var(j,7)"
  write(ilun,format)"        bz1=fluid_var(j,8)"
  write(ilun,format)"        bx2=fluid_var(j,nvar+1)"
  write(ilun,format)"        by2=fluid_var(j,nvar+2)"
  write(ilun,format)"        bz2=fluid_var(j,nvar+3)"
  write(ilun,format)"        e=e-0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)"        e=e-0.5*d*(u*u+v*v+w*w)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"        do irad=1,nener"
  write(ilun,format)"           e=e-fluid_var(j,inener-1+irad)"
  write(ilun,format)"        end do"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(energy_fix)e=fluid_var(j,nvar)"
  write(ilun,format)"        egas(j)=e"
  write(ilun,format)"     else"
  write(ilun,format)"        egas(j)=0."
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"    "
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  one_over_dx_min=1./dx_min"
  write(ilun,format)"  "
  write(ilun,format)"  divpart(1:np)=0._dp"
  write(ilun,format)""
  write(ilun,format)"  do divdim=1,3"
  write(ilun,format)""
  write(ilun,format)"     !use min cell spacing to obtain right position, get right cell index"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xpart(j,divdim)=xpart(j,divdim)+0.5*dx_min"
  write(ilun,format)"     end do"
  write(ilun,format)"     call cic_get_vals(fluid_var_right,ind_grid,xpart,ind_grid_part,ng,np,ilevel,.false.)"
  write(ilun,format)""
  write(ilun,format)"     !use min cell spacing to obtain left position, get left cell index"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xpart(j,divdim)=xpart(j,divdim)-dx_min"
  write(ilun,format)"     end do"
  write(ilun,format)"     call cic_get_vals(fluid_var_left,ind_grid,xpart,ind_grid_part,ng,np,ilevel,.false.)"
  write(ilun,format)""
  write(ilun,format)"     !back to original position"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xpart(j,divdim)=xpart(j,divdim)+0.5*dx_min"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     !compute divergence of (rho*v - rho*vsink) in one go"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        isink=-idp(ind_part(j))"
  write(ilun,format)"        divpart(j)=divpart(j)+(fluid_var_right(j,divdim+1)-fluid_var_right(j,1)*vsink(isink,divdim)-&"
  write(ilun,format)"             fluid_var_left(j,divdim+1)+fluid_var_left(j,1)*vsink(isink,divdim))*one_over_dx_min"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     isink=-idp(ind_part(j))"
  write(ilun,format)"     weight=0._dp"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        weight=weight+weightp(ind_part(j),ind)"
  write(ilun,format)"     end do"
  write(ilun,format)"     wvol(isink)=wvol(isink)+weight"
  write(ilun,format)"     wden(isink)=wden(isink)+weight*fluid_var(j,1)"
  write(ilun,format)"     wmom(isink,1:3)=wmom(isink,1:3)+weight*fluid_var(j,2:4)"
  write(ilun,format)"     weth(isink)=weth(isink)+weight*egas(j)"
  write(ilun,format)"     wdiv(isink)=wdiv(isink)+weight*divpart(j)"
  write(ilun,format)"     if (weight>0.)level_sink_new(isink,ilevel)=.true."
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine collect_acczone_avg_np"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine grow_sink(ilevel,on_creation)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  logical::on_creation"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine performs accretion onto the sink. It vectorizes the loop"
  write(ilun,format)"  ! over all sink cloud particles and calls accrete_sink as soon as nvector "
  write(ilun,format)"  ! particles are collected"
  write(ilun,format)"  ! -> replaces grow_bondi and grow_jeans"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part,info"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,icpu,isink,lev,nx_loc"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  real(dp)::scale,dx_min,vol_min"
  write(ilun,format)"  real(dp),dimension(1:ndim)::old_loc,old_vel"
  write(ilun,format)"  logical::highest_level"
  write(ilun,format)""
  write(ilun,format)"  if(accretion_scheme=='none')return"
  write(ilun,format)"  if(.not. on_creation)then"
  write(ilun,format)"     ! Determine if on highest active level..."
  write(ilun,format)"     if (ilevel==nlevelmax)then"
  write(ilun,format)"        highest_level=.true."
  write(ilun,format)"     else if (numbtot(1,ilevel+1)==0)then"
  write(ilun,format)"        highest_level=.true."
  write(ilun,format)"     else"
  write(ilun,format)"        highest_level=.false."
  write(ilun,format)"     end if"
  write(ilun,format)"     if (.not. highest_level)return"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*(0.5D0**nlevelmax)/aexp"
  write(ilun,format)"  vol_min=dx_min**ndim"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  ! Compute sink accretion rates"
  write(ilun,format)"  call compute_accretion_rate(.false.)"
  write(ilun,format)""
  write(ilun,format)"  ! Reset new sink variables"
  write(ilun,format)"  msink_new=0d0; xsink_new=0.d0; vsink_new=0d0; delta_mass_new=0d0; lsink_new=0d0"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     igrid=headl(icpu,ilevel)"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)"        ! Count sink and cloud particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"        ! Gather sink and cloud particles"
  write(ilun,format)"        if(npart2>0)then        "
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only sink particles"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig   "
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                 call accrete_sink(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel,on_creation)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)call accrete_sink(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel,on_creation)"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over cpus"
  write(ilun,format)"  if(nsink>0)then"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(msink_new,msink_all,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(delta_mass_new,delta_mass_all,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(xsink_new,xsink_all,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(vsink_new,vsink_all,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(lsink_new,lsink_all,nsinkmax*3,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"     msink_all=msink_new"
  write(ilun,format)"     delta_mass_all=delta_mass_new"
  write(ilun,format)"     xsink_all=xsink_new"
  write(ilun,format)"     vsink_all=vsink_new"
  write(ilun,format)"     lsink_all=lsink_new"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     ! Reset jump in sink coordinates"
  write(ilun,format)"     do lev=levelmin,nlevelmax"
  write(ilun,format)"        sink_jump(isink,1:ndim,lev)=sink_jump(isink,1:ndim,lev)-xsink(isink,1:ndim)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     !save old velocity and location to compute deltas"
  write(ilun,format)"     old_loc(1:ndim)=xsink(isink,1:ndim)"
  write(ilun,format)"     old_vel(1:ndim)=vsink(isink,1:ndim)"
  write(ilun,format)"     "
  write(ilun,format)"     ! Change to conservative quantities"
  write(ilun,format)"     xsink(isink,1:ndim)=xsink(isink,1:ndim)*msink(isink)"
  write(ilun,format)"     vsink(isink,1:ndim)=vsink(isink,1:ndim)*msink(isink)"
  write(ilun,format)"     "
  write(ilun,format)""
  write(ilun,format)"     ! Accrete to sink variables"
  write(ilun,format)"     msink(isink)=msink(isink)+msink_all(isink)"
  write(ilun,format)"     xsink(isink,1:ndim)=xsink(isink,1:ndim)+xsink_all(isink,1:ndim)"
  write(ilun,format)"     vsink(isink,1:ndim)=vsink(isink,1:ndim)+vsink_all(isink,1:ndim)"
  write(ilun,format)"     !compute lsink with reference point of old xsink"
  write(ilun,format)"     lsink(isink,1:3)=lsink(isink,1:3)+lsink_all(isink,1:3)"
  write(ilun,format)"     "
  write(ilun,format)"     ! Change back"
  write(ilun,format)"     xsink(isink,1:ndim)=xsink(isink,1:ndim)/msink(isink)"
  write(ilun,format)"     vsink(isink,1:ndim)=vsink(isink,1:ndim)/msink(isink)"
  write(ilun,format)""
  write(ilun,format)"     !correct for new center of mass location/velocity"
  write(ilun,format)"     lsink(isink,1:3)=lsink(isink,1:3)-msink(isink)*cross((xsink(isink,1:ndim)-old_loc(1:ndim)),(vsink(isink,1:ndim)-old_vel(1:ndim)))"
  write(ilun,format)""
  write(ilun,format)"     ! Store jump in sink coordinates"
  write(ilun,format)"     do lev=levelmin,nlevelmax"
  write(ilun,format)"        sink_jump(isink,1:ndim,lev)=sink_jump(isink,1:ndim,lev)+xsink(isink,1:ndim)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Store accreted mass"
  write(ilun,format)"     acc_rate(isink)=acc_rate(isink)+msink_all(isink)"
  write(ilun,format)"     if (agn.and.ok_blast_agn(isink))then"
  write(ilun,format)"       delta_mass(isink)=delta_mass_all(isink) ! only the most recent accretion"
  write(ilun,format)"     else"
  write(ilun,format)"       delta_mass(isink)=delta_mass(isink)+delta_mass_all(isink)"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! introduced by PH 09/2013 to compute the feedback from sink"
  write(ilun,format)"     dmfsink(isink)=dmfsink(isink)+msink_all(isink)"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"#endif"
  write(ilun,format)"111 format('   Entering grow_sink for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine grow_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine accrete_sink(ind_grid,ind_part,ind_grid_part,ng,np,ilevel,on_creation)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid_part,ind_part"
  write(ilun,format)"  logical::on_creation"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! This routine is called by subroutine grow_sink. It performs accretion"
  write(ilun,format)"  ! for nvector particles. Routine is not very efficient. Optimize if taking too long..."
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::i,j,nx_loc,isink,ivar,irad,idim,ind,ht"
  write(ilun,format)"  real(dp)::v2,d,e,d_floor,density,volume,eint,trmp,ekin"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  real(dp)::bx1,bx2,by1,by2,bz1,bz2"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp),dimension(1:nvar)::z"
  write(ilun,format)"  real(dp)::factG,scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::dx,dx_loc,dx_min,scale,vol_min,vol_loc,weight,acc_mass,temp,d_jeans"
  write(ilun,format)"  ! Grid based arrays"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xpart"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:twotondim)::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim)::vol"
  write(ilun,format)"  integer ,dimension(1:nvector)::cell_lev"
  write(ilun,format)"  ! Particle based arrays"
  write(ilun,format)"  logical,dimension(1:nvector,1:twotondim)::ok"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim)::indp"
  write(ilun,format)"  real(dp),dimension(1:3)::vv"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:3)::r_rel,x_acc,p_acc,p_rel,p_rel_rad,p_rel_acc,p_rel_tan,delta_x,delta_p,drag"
  write(ilun,format)"  real(dp)::r_abs,fbk_ener_AGN,fbk_mom_AGN"
  write(ilun,format)"  logical,dimension(1:ndim)::period"
  write(ilun,format)"  real(dp)::virt_acc_mass,delta_e_tot,Mred,Macc"
  write(ilun,format)"  real(dp),dimension(1:nsinkmax)::delta_M"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::tan_theta,cone_dist,orth_dist"
  write(ilun,format)"  real(dp),dimension(1:3)::cone_dir"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::c2"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  "
  write(ilun,format)"  period(1)=(nx==1)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"  if(ndim>1)period(2)=(ny==1)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  if(ndim>2)period(3)=(nz==1)"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  "
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)"  "
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  vol_min=dx_min**ndim"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xpart(j,idim)=xp(ind_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  virt_acc_mass=0.d0; delta_M=0.d0"
  write(ilun,format)"  ! geometry safety net"
  write(ilun,format)"  cone_opening = max(tiny(0.0),cone_opening)"
  write(ilun,format)"  cone_opening = min(cone_opening, 180.d0)"
  write(ilun,format)"  tan_theta=tan(3.1415926/180.*cone_opening/2) ! tangent of half of the opening angle"
  write(ilun,format)""
  write(ilun,format)"  call cic_get_cells(indp,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(ok(j,ind))then"
  write(ilun,format)"           "
  write(ilun,format)"           ! Convert uold to primitive variables"
  write(ilun,format)"           d=max(uold(indp(j,ind),1),smallr)"
  write(ilun,format)"           vv(1)=uold(indp(j,ind),2)/d"
  write(ilun,format)"           vv(2)=uold(indp(j,ind),3)/d"
  write(ilun,format)"           vv(3)=uold(indp(j,ind),4)/d"
  write(ilun,format)"           e=uold(indp(j,ind),5)"
  write(ilun,format)""
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"           bx1=uold(indp(j,ind),6)"
  write(ilun,format)"           by1=uold(indp(j,ind),7)"
  write(ilun,format)"           bz1=uold(indp(j,ind),8)"
  write(ilun,format)"           bx2=uold(indp(j,ind),nvar+1)"
  write(ilun,format)"           by2=uold(indp(j,ind),nvar+2)"
  write(ilun,format)"           bz2=uold(indp(j,ind),nvar+3)"
  write(ilun,format)"           e=e-0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)"           v2=(vv(1)**2+vv(2)**2+vv(3)**2)"
  write(ilun,format)"           ekin=0.5d0*d*v2"
  write(ilun,format)"           e=e-ekin"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do irad=1,nener"
  write(ilun,format)"              e=e-uold(indp(j,ind),inener-1+irad)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif"
  write(ilun,format)"           e=e/d"
  write(ilun,format)"           if(energy_fix)e=uold(indp(j,ind),nvar)/d"
  write(ilun,format)"           eint=e*d"
  write(ilun,format)""
  write(ilun,format)"           call temperature_eos(d,eint,temp,ht)"
  write(ilun,format)""
  write(ilun,format)"           do ivar=imetal,lastindex_pscal"
  write(ilun,format)"              z(ivar)=uold(indp(j,ind),ivar)/d"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Get sink index"
  write(ilun,format)"           isink=-idp(ind_part(j))        "
  write(ilun,format)" "
  write(ilun,format)"           ! Drag force based on virtual accretion"
  write(ilun,format)"           Macc=0.d0; Mred=0.d0; delta_M(isink)=0.d0"
  write(ilun,format)"           if (sink_drag)then"
  write(ilun,format)"              Macc=max((dMBHoverdt(isink)-dMsink_overdt(isink))*dtnew(ilevel),0.d0)"
  write(ilun,format)"              Mred=msink(isink)*(rho_gas(isink)*volume_gas(isink))/(msink(isink)+(rho_gas(isink)*volume_gas(isink)))"
  write(ilun,format)"              delta_M(isink)=Mred*Macc/(Mred+Macc)"
  write(ilun,format)"           end if"
  write(ilun,format)"           delta_M(isink)=min(delta_M(isink),msink(isink)*dx_loc/(sum((xsink(isink,1:ndim)-xx(j,1:ndim,ind))**2)**0.5+tiny(0.d0)))"
  write(ilun,format)"           "
  write(ilun,format)"           ! Compute sink average density"
  write(ilun,format)"           weight=weightp(ind_part(j),ind)"
  write(ilun,format)"           density=rho_gas(isink)"
  write(ilun,format)"           volume=volume_gas(isink)"
  write(ilun,format)"           !!PH 5/2/2017 when threshold_accretion is used 'weight' can be 0"
  write(ilun,format)"           if ( (volume==0. .or. density==0.) .and. .not. threshold_accretion )print*,'something might be going wrong here...',weight,volume,density,ilevel,xsink(isink,1),xsink(isink,2),xsink(isink,3),isink"
  write(ilun,format)""
  write(ilun,format)"           if (on_creation)then"
  write(ilun,format)"              if (new_born(isink))then"
  write(ilun,format)"                 ! on sink creation, new sinks"
  write(ilun,format)"                 acc_mass=mseed(isink)*weight/volume*d/density"
  write(ilun,format)"              else"
  write(ilun,format)"                 ! on sink creation, preexisting sinks"
  write(ilun,format)"                 acc_mass=0.         "
  write(ilun,format)"              end if"
  write(ilun,format)"           else"
  write(ilun,format)"              if (flux_accretion .or. bondi_accretion)then              "
  write(ilun,format)"                 acc_mass=dMsink_overdt(isink)*dtnew(ilevel)*weight/volume*d/density"
  write(ilun,format)"                 virt_acc_mass=delta_M(isink)*weight/volume*d/density"
  write(ilun,format)"                 fbk_ener_AGN=min(delta_mass(isink)*T2_AGN/scale_T2*weight/volume*d/density,T2_max/scale_T2*weight*d)"
  write(ilun,format)"                 fbk_mom_AGN=min(delta_mass(isink)*v_AGN*(180./cone_opening)*1.e5/scale_v*weight/volume*d/density,v_max*1.e5/scale_v*weight*d)"
  write(ilun,format)"              end if"
  write(ilun,format)""
  write(ilun,format)"              if (threshold_accretion)then"
  write(ilun,format)"                 ! User defined density threshold"
  write(ilun,format)"                 d_floor=d_sink           "
  write(ilun,format)"                 ! Jeans length related density threshold  "
  write(ilun,format)"                 if(jeans_accretion)then"
  write(ilun,format)"                    !temp=max(e*(gamma-1.0),smallc**2)"
  write(ilun,format)"                    call soundspeed_eos(d,eint,c2)"
  write(ilun,format)"                    c2=c2**2"
  write(ilun,format)"                    d_jeans=c2*3.1415926/(4.0*dx_loc)**2/factG"
  write(ilun,format)"                    d_floor=d_jeans"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 acc_mass=c_acc*weight*(d-d_floor)"
  write(ilun,format)"              end if"
  write(ilun,format)""
  write(ilun,format)"              ! No neg accretion"
  write(ilun,format)"              acc_mass=max(acc_mass,0.0_dp)               "
  write(ilun,format)""
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           ! reference frame relative to the sink"
  write(ilun,format)"           r_rel(1:3)=xx(j,1:3,ind)-xsink(isink,1:3) "
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              if (period(idim) .and. r_rel(idim)>boxlen*0.5)xx(j,idim,ind)=xx(j,idim,ind)-boxlen"
  write(ilun,format)"              if (period(idim) .and. r_rel(idim)<boxlen*(-0.5))xx(j,idim,ind)=xx(j,idim,ind)+boxlen"
  write(ilun,format)"           end do"
  write(ilun,format)"           r_rel(1:3)=xx(j,1:3,ind)-xsink(isink,1:3) "
  write(ilun,format)"           r_abs=sum(r_rel(1:3)**2)**0.5      "
  write(ilun,format)""
  write(ilun,format)"           ! momentum in relative motion"
  write(ilun,format)"           p_rel=d*vol_loc*(vv(1:3)-vsink(isink,1:3))"
  write(ilun,format)"           p_rel_rad=sum(r_rel(1:3)*p_rel(1:3))*r_rel(1:3)/(r_abs**2+tiny(0.d0))"
  write(ilun,format)"           p_rel_tan=p_rel-p_rel_rad"
  write(ilun,format)""
  write(ilun,format)"           if(nol_accretion)then"
  write(ilun,format)"              p_rel_acc=p_rel_rad*acc_mass/(d*vol_loc)"
  write(ilun,format)"           else"
  write(ilun,format)"              p_rel_acc=p_rel*acc_mass/(d*vol_loc)"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           ! total accreted/deccreted momentum"
  write(ilun,format)"           drag=(virt_acc_mass*vsink(isink,1:ndim)*density/d-virt_acc_mass*vv(1:ndim)) "
  write(ilun,format)"           delta_p=-drag"
  write(ilun,format)"           p_acc(1:3)=p_rel_acc+vsink(isink,1:3)*acc_mass"
  write(ilun,format)"          "
  write(ilun,format)"           ! total accreted/deccreted energy"
  write(ilun,format)"           delta_e_tot=(virt_acc_mass*eps_sink(isink)*density/d-virt_acc_mass*e)+sum(drag(1:ndim)*vv(1:ndim))"
  write(ilun,format)""
  write(ilun,format)"           ! total accreted center of mass"
  write(ilun,format)"           x_acc(1:3)=acc_mass*xx(j,1:3,ind)"
  write(ilun,format)"           delta_x(1:3)=virt_acc_mass*(xx(j,1:3,ind)-xsink(isink,1:3))"
  write(ilun,format)"           "
  write(ilun,format)"           ! Add accreted properties to sink variables"
  write(ilun,format)"           msink_new(isink)=msink_new(isink)+acc_mass"
  write(ilun,format)"           delta_mass_new(isink)=delta_mass_new(isink)+acc_mass"
  write(ilun,format)"           xsink_new(isink,1:3)=xsink_new(isink,1:3)+x_acc(1:3)+delta_x(1:3)"
  write(ilun,format)"           vsink_new(isink,1:3)=vsink_new(isink,1:3)+p_acc(1:3)+delta_p(1:3)"
  write(ilun,format)"           lsink_new(isink,1:3)=lsink_new(isink,1:3)+cross(r_rel(1:3),p_rel_acc(1:3))"
  write(ilun,format)""
  write(ilun,format)"           ! Check for neg density inside sink accretion radius"
  write(ilun,format)"           if (8*acc_mass/vol_loc>d .and. (.not. on_creation))then "
  write(ilun,format)"              write(*,*)'====================================================='"
  write(ilun,format)"              write(*,*)'DANGER of neg density :-( at location'"
  write(ilun,format)"              write(*,*)xx(j,1:3,ind)"
  write(ilun,format)"              write(*,*)'due to',isink"
  write(ilun,format)"              write(*,*)acc_mass/vol_loc,d/d_sink,density/d_sink"
  write(ilun,format)"              write(*,*)indp(j,ind),myid"
  write(ilun,format)"              write(*,*)'nol_accretion: ',nol_accretion"
  write(ilun,format)"              do i=1,nsink"
  write(ilun,format)"                 write(*,*)i,' distance ',sum((xx(j,1:3,ind)-xsink(i,1:3))**2)**0.5/dx_min"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(*,*)'try to decrease c_acc in SINK_PARAMS'"
  write(ilun,format)"              write(*,*)'====================================================='"
  write(ilun,format)"              !           call clean_stop"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           if (on_creation)then"
  write(ilun,format)"              ! new born sinks accrete from uold"
  write(ilun,format)"              d=d-acc_mass/vol_loc"
  write(ilun,format)"              !new gas velocity"
  write(ilun,format)"              vv(1:3)=(d*vol_loc*vv(1:3)-p_acc(1:3))/(d*vol_loc-acc_mass)"
  write(ilun,format)"              !convert back to conservative variables"
  write(ilun,format)"              v2=(vv(1)**2+vv(2)**2+vv(3)**2)"
  write(ilun,format)"              call enerint_eos(d,temp,eint)"
  write(ilun,format)"              e=eint"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"              e=e+0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)"              e=e+0.5d0*d*v2"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"              do irad=1,nener"
  write(ilun,format)"                 e=e+uold(indp(j,ind),inener-1+irad)"
  write(ilun,format)"              end do"
  write(ilun,format)"#endif"
  write(ilun,format)"              uold(indp(j,ind),1)=d"
  write(ilun,format)"              uold(indp(j,ind),2)=d*vv(1)"
  write(ilun,format)"              uold(indp(j,ind),3)=d*vv(2)"
  write(ilun,format)"              uold(indp(j,ind),4)=d*vv(3)"
  write(ilun,format)"              uold(indp(j,ind),5)=e"
  write(ilun,format)"              if(energy_fix)uold(indp(j,ind),nvar)=eint"
  write(ilun,format)"              do ivar=imetal,lastindex_pscal"
  write(ilun,format)"                 uold(indp(j,ind),ivar)=d*z(ivar)"
  write(ilun,format)"              end do"
  write(ilun,format)"           else"
  write(ilun,format)"              ! regular accretion from unew"
  write(ilun,format)"              unew(indp(j,ind),1)=unew(indp(j,ind),1)-acc_mass/vol_loc-virt_acc_mass/vol_loc+virt_acc_mass/vol_loc*density/d"
  write(ilun,format)"              unew(indp(j,ind),2:4)=unew(indp(j,ind),2:4)-vv(1:3)*acc_mass/vol_loc-delta_p(1:3)/vol_loc"
  write(ilun,format)"              ! fix the energy equation to account for the work of the truly accreted material "
  write(ilun,format)"!              unew(indp(j,ind),5)=unew(indp(j,ind),5)-uold(indp(j,ind),5)*acc_mass/(d*vol_loc)+delta_e_tot/vol_loc"
  write(ilun,format)""
  write(ilun,format)"              unew(indp(j,ind),5)=unew(indp(j,ind),5)-ekin*acc_mass/(d*vol_loc)+delta_e_tot/vol_loc-eint"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"              do ivar=imetal,lastindex_pscal"
  write(ilun,format)"                 unew(indp(j,ind),ivar)=unew(indp(j,ind),ivar)-uold(indp(j,ind),ivar)*acc_mass/(d*vol_loc)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              d=unew(indp(j,ind),1)"
  write(ilun,format)"              call enerint_eos(d,temp,eint)"
  write(ilun,format)"              unew(indp(j,ind),5)=unew(indp(j,ind),5)+eint"
  write(ilun,format)"              if(energy_fix)then"
  write(ilun,format)"                 unew(indp(j,ind),nvar)=eint"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"              ! put the tangential momentum back into the gas"
  write(ilun,format)"              if(nol_accretion)then"
  write(ilun,format)"                 unew(indp(j,ind),2:4)=unew(indp(j,ind),2:4)+acc_mass/(d*vol_loc)*p_rel_tan(1:3)/vol_loc"
  write(ilun,format)"                 unew(indp(j,ind),5)=unew(indp(j,ind),5)+acc_mass/(d*vol_loc)*sum(p_rel_tan(1:3)*vv(1:3))/vol_loc"
  write(ilun,format)"              end if"
  write(ilun,format)"              "
  write(ilun,format)"              ! AGN feedback"
  write(ilun,format)"              if(agn)then"
  write(ilun,format)"                if(ok_blast_agn(isink).and.delta_mass(isink)>0.0)then"
  write(ilun,format)"                  if(feedback_scheme=='energy')then"
  write(ilun,format)"                    unew(indp(j,ind),5)=unew(indp(j,ind),5)+fbk_ener_AGN/vol_loc"
  write(ilun,format)"                  end if"
  write(ilun,format)"                  "
  write(ilun,format)"                  if(feedback_scheme=='momentum')then"
  write(ilun,format)"                     ! checking if particle is in cone"
  write(ilun,format)"                     cone_dir(1:3)=lsink(isink,1:3)/sqrt(sum(lsink(isink,1:3)**2))"
  write(ilun,format)"                     cone_dist=sum(r_rel(1:3)*cone_dir(1:3))"
  write(ilun,format)"                     orth_dist=sqrt(sum((r_rel(1:3)-cone_dist*cone_dir(1:3))**2))"
  write(ilun,format)"                     if (orth_dist.le.abs(cone_dist)*tan_theta)then"
  write(ilun,format)"                        unew(indp(j,ind),2:4)=unew(indp(j,ind),2:4)+fbk_mom_AGN*r_rel(1:3)/(ir_cloud*dx_min)/vol_loc"
  write(ilun,format)"                        unew(indp(j,ind),5)=unew(indp(j,ind),5)+sum(fbk_mom_AGN*r_rel(1:3)/(ir_cloud*dx_min)*vv(1:3))/vol_loc"
  write(ilun,format)"                     end if"
  write(ilun,format)"                  end if"
  write(ilun,format)"                end if"
  write(ilun,format)"              end if"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"end subroutine accrete_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine compute_accretion_rate(write_sinks)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  logical::write_sinks"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the accretion rate onto the sink particles based"
  write(ilun,format)"  ! on the information collected in collect accretion "
  write(ilun,format)"  ! It also creates output for the sink particle positions"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::i,nx_loc,isink"
  write(ilun,format)"  integer::imdot,im1,im2"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v,scale_m"
  write(ilun,format)"  real(dp)::factG,d_star,boost,fa_fact"
  write(ilun,format)"  real(dp)::r2,v2,c2,density,volume,ethermal,dx_min,scale,mgas,rho_inf,divergence,v_bondi"
  write(ilun,format)"  real(dp),dimension(1:3)::velocity"
  write(ilun,format)"  real(dp),dimension(1:nsinkmax)::dMEDoverdt"
  write(ilun,format)"  real(dp)::T2_gas,delta_mass_min"
  write(ilun,format)"  real(dp)::mass,log_mdot,mean_mdot,mass_reduced,star_mass,pi"
  write(ilun,format)"  real(dp)::de1,de2,dd1,dd2,mass_table,Lum,radius,mdot_real,y1,y2,z2,z1,a,b,surface"
  write(ilun,format)""
  write(ilun,format)"  dt_acc=huge(0._dp)"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/pi*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  scale_m=scale_d*scale_l**3d0"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  d_star=n_star/scale_nH"
  write(ilun,format)""
  write(ilun,format)"  ! Compute sink particle accretion rate by averaging contributions from all levels"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     density=0.d0; volume=0.d0; velocity=0.d0; ethermal=0d0"
  write(ilun,format)"     divergence=0.d0"
  write(ilun,format)"     do i=levelmin,nlevelmax"
  write(ilun,format)"        density=density+weighted_density(isink,i)"
  write(ilun,format)"        ethermal=ethermal+weighted_ethermal(isink,i)"
  write(ilun,format)"        velocity(1:3)=velocity(1:3)+weighted_momentum(isink,i,1:3)"
  write(ilun,format)"        volume=volume+weighted_volume(isink,i)"
  write(ilun,format)"        divergence=divergence+weighted_divergence(isink,i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     mgas=density"
  write(ilun,format)"     density=density/(volume+tiny(0.0_dp))"
  write(ilun,format)"     if (density>0)then"
  write(ilun,format)"        velocity(1:3)=velocity(1:3)/(density*volume+tiny(0.0_dp))"
  write(ilun,format)"        ethermal=ethermal/(density*volume+tiny(0.0_dp))"
  write(ilun,format)"        c2=MAX((gamma-1.0)*ethermal,smallc**2)"
  write(ilun,format)"        c2sink(isink)=c2"
  write(ilun,format)"        v2=SUM((velocity(1:3)-vsink(isink,1:3))**2)"
  write(ilun,format)"        v_bondi=sqrt(c2+v2)"
  write(ilun,format)"        "
  write(ilun,format)"        ! Compute Bondi-Hoyle accretion rate in code units"
  write(ilun,format)"        if (star.and.acc_sink_boost.lt.0.0)then"
  write(ilun,format)"           boost=max((density/d_star)**2,1.0_dp)"
  write(ilun,format)"        else"
  write(ilun,format)"           boost=abs(acc_sink_boost)"
  write(ilun,format)"        end if"
  write(ilun,format)"        "
  write(ilun,format)"        v_bondi=v_bondi*boost**(-1./3.)"
  write(ilun,format)"        "
  write(ilun,format)"        ! Bondi radius"
  write(ilun,format)"        r2=(factG*msink(isink)/v_bondi**2)**2"
  write(ilun,format)"        "
  write(ilun,format)"        ! extrapolate to rho_inf"
  write(ilun,format)"        rho_inf=density/(bondi_alpha(ir_cloud*0.5*dx_min/r2**0.5))"
  write(ilun,format)""
  write(ilun,format)"        ! use other values for lambda depending on the EOS, this is for isothermal"
  write(ilun,format)"        dMBHoverdt(isink)=4.*3.1415926*rho_inf*r2*v_bondi"
  write(ilun,format)"        dMEDoverdt(isink)=4.*3.1415926*6.67d-8*msink(isink)*1.66d-24/(0.1*6.652d-25*3d10)*scale_t"
  write(ilun,format)"        "
  write(ilun,format)"        ! set sink accretion rate to Bondi value"
  write(ilun,format)"        if(smbh.or.bondi_accretion)dMsink_overdt(isink)=dMBHoverdt(isink)"
  write(ilun,format)""
  write(ilun,format)"        ! limit accretion to Eddington rate"
  write(ilun,format)"        if(eddington_limit)then"
  write(ilun,format)"             dMsink_overdt(isink)=min(dMBHoverdt(isink),dMEDoverdt(isink))"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        ! accretion rate is based on mass flux onto the sink, bondirate is used for subsonic accretion"
  write(ilun,format)"        if (flux_accretion)then"
  write(ilun,format)""
  write(ilun,format)"           ! average divergence over all cloud particles and multiply by cloud volume"
  write(ilun,format)"           dMsink_overdt(isink)=-1.*divergence"
  write(ilun,format)""
  write(ilun,format)"           ! correct for some small factor to keep density close to threshold"
  write(ilun,format)"           fa_fact=(log10(density)-log10(d_sink))*0.1+1."
  write(ilun,format)"           dMsink_overdt(isink)=dMsink_overdt(isink)*fa_fact"
  write(ilun,format)""
  write(ilun,format)"           ! If accretion is subsonic (sonic radius smaller than accretion radius), use Bondi-rate instead."
  write(ilun,format)"           if ((0.5*msink(isink)/c2) < (ir_cloud*dx_min))then"
  write(ilun,format)"              dMsink_overdt(isink)=dMBHoverdt(isink)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        ! store average quantities for accretion and diagnostics"
  write(ilun,format)"        eps_sink(isink)=ethermal"
  write(ilun,format)"        rho_gas(isink)=density"
  write(ilun,format)"        volume_gas(isink)=volume"
  write(ilun,format)"        vel_gas(isink,1:ndim)=velocity(1:ndim)"
  write(ilun,format)""
  write(ilun,format)"        ! make sure, accretion rate is positive"
  write(ilun,format)"        dMsink_overdt(isink)=max(0.d0,dMsink_overdt(isink))"
  write(ilun,format)""
  write(ilun,format)"        ! compute maximum timestep allowed by sink"
  write(ilun,format)"        if (dMsink_overdt(isink)>0.0)then"
  write(ilun,format)""
  write(ilun,format)"           ! make sure that sink doesnt accrete more than the gas mass within one timestep"
  write(ilun,format)"           if (bondi_accretion .or. flux_accretion)dt_acc(isink)=c_acc*mgas/dMsink_overdt(isink)"
  write(ilun,format)"           ! make sure that sink doesnt accrete more than its own mass within one timestep"
  write(ilun,format)"           dt_acc(isink)=min(dt_acc(isink),(c_acc*msink(isink)/dMsink_overdt(isink)))"
  write(ilun,format)"           "
  write(ilun,format)"           ! make sure that agn feedback doesn't increase the thermal energy of the gas too much"
  write(ilun,format)"           if(agn)then"
  write(ilun,format)""
  write(ilun,format)"              ! check whether we should have AGN feedback"
  write(ilun,format)"              ok_blast_agn(isink)=.false."
  write(ilun,format)"              T2_gas=ethermal*scale_T2 ! in Kelvin"
  write(ilun,format)"              delta_mass_min = mgas*(T2_min-T2_gas)/(T2_AGN-T2_min)"
  write(ilun,format)"              if((T2_gas.ge.T2_min).or.(delta_mass(isink).ge.mgas*(T2_min-T2_gas)/(T2_AGN-T2_min)))then"
  write(ilun,format)"                ok_blast_agn(isink)=.true."
  write(ilun,format)"              end if"
  write(ilun,format)"              if(myid==1.and.verbose_AGN.and.ok_blast_agn(isink).and.delta_mass(isink).gt.0.)then"
  write(ilun,format)"                write(*,'('***BLAST***',I4,1X,4(1PE12.5,1X))')isink &"
  write(ilun,format)"                    & ,msink(isink)*scale_d*scale_l**3/2d33 &  "
  write(ilun,format)"                    & ,delta_mass(isink)*scale_d*scale_l**3/2d33 &"
  write(ilun,format)"                    & ,((delta_mass(isink)*T2_AGN+mgas*T2_gas) &"
  write(ilun,format)"                    & /(delta_mass(isink)+mgas))"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"              ! make sure that sink doesnt blast more than the gas internal energy within one timestep"
  write(ilun,format)"!              if((T2_gas.ge.T2_min).or.(delta_mass(isink).ge.delta_mass_min))then"
  write(ilun,format)"!                 dt_acc(isink)=min(dt_acc(isink),(c_acc*mgas*T2_gas/(dMsink_overdt(isink)*T2_AGN)))"
  write(ilun,format)"!              end if"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  if(PMS_evol .and. rt_feedback)then"
  write(ilun,format)"     if(Hosokawa_track)then"
  write(ilun,format)"        ! Compute internal luminosity from Hosokawa PMS tracks"
  write(ilun,format)"        do isink=1,nsink"
  write(ilun,format)"           star_mass=facc_star*msink(isink)"
  write(ilun,format)"!           if((star_mass*scale_m/Msun) .gt. 1.d-2)then! .and. (t-tsink(isink))*(scale_t/year) .gt. larson_lifetime)then "
  write(ilun,format)"              if(star_mass*scale_m/Msun .gt. 7.1d-2)then"
  write(ilun,format)"                 mean_mdot = star_mass/(t-tsink(isink))*scale_m/Msun &"
  write(ilun,format)"                      & /(scale_t/year) !in msun/year"
  write(ilun,format)"                 mass = star_mass*scale_m/Msun"
  write(ilun,format)"                 "
  write(ilun,format)"                 mass=log10(mass)"
  write(ilun,format)"                 log_mdot = log10(mean_mdot)"
  write(ilun,format)"                 imdot = floor(log_mdot) + 8"
  write(ilun,format)"                 "
  write(ilun,format)"                 if(imdot .lt. 1)then"
  write(ilun,format)"                    imdot=1              "
  write(ilun,format)"                    mass_table=-10.0"
  write(ilun,format)"                    i=1"
  write(ilun,format)"                    do while(mass_table .lt. mass)"
  write(ilun,format)"                       if((i+1) .gt. nb_ligne_PMS(imdot))then"
  write(ilun,format)"                          lum = data_PMS(imdot,i+1,3)"
  write(ilun,format)"                          radius = data_PMS(imdot,i+1,4)"
  write(ilun,format)"                          GOTO 110"
  write(ilun,format)"                       end if"
  write(ilun,format)"                       i=i+1"
  write(ilun,format)"                       mass_table = data_PMS(imdot,i,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"  "
  write(ilun,format)" !                   if(myid==1)print*,'imdot lt 1',i,imdot,star_mass*scale_m/Msun"
  write(ilun,format)"                  "
  write(ilun,format)"                    z1 = data_PMS(imdot,i  ,3)"
  write(ilun,format)"                    z2 = data_PMS(imdot,i-1,3)"
  write(ilun,format)"                    "
  write(ilun,format)"                    y1 = data_PMS(imdot,i  ,1)"
  write(ilun,format)"                    y2 = data_PMS(imdot,i-1,1)"
  write(ilun,format)"                    "
  write(ilun,format)"                    a = (z2-z1)/(y2-y1)"
  write(ilun,format)"                    b=z2-a*y2"
  write(ilun,format)"                 "
  write(ilun,format)"                    lum = a*mass + b"
  write(ilun,format)"                    "
  write(ilun,format)"                    z1 = data_PMS(imdot,i  ,4)"
  write(ilun,format)"                    z2 = data_PMS(imdot,i-1,4)"
  write(ilun,format)"                    a = (z2-z1)/(y2-y1)"
  write(ilun,format)"                    b=z2-a*y2"
  write(ilun,format)"                    "
  write(ilun,format)"                    radius = a*mass + b"
  write(ilun,format)"                    "
  write(ilun,format)"                    "
  write(ilun,format)" !          print*,'Luminosity=',lum,'Lsol',', mass=',mass,'Msol'"
  write(ilun,format)"                    "
  write(ilun,format)"                 else if(imdot .ge. 5)then"
  write(ilun,format)"                    imdot=5"
  write(ilun,format)"                    "
  write(ilun,format)"                    mass_table=-10.0"
  write(ilun,format)"                    i=1"
  write(ilun,format)"!                    if(myid==1)print*,i,mass_table,mass, nb_ligne_PMS(imdot),log_mdot"
  write(ilun,format)"                    do while(mass_table .lt. mass)"
  write(ilun,format)"                       if((i+1) .gt. nb_ligne_PMS(imdot))then"
  write(ilun,format)"                          lum = data_PMS(imdot,i+1,3)"
  write(ilun,format)"                          radius = data_PMS(imdot,i+1,4)"
  write(ilun,format)"                          GOTO 110"
  write(ilun,format)"                       end if"
  write(ilun,format)"                        i=i+1"
  write(ilun,format)"                        mass_table = data_PMS(imdot,i,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"!                    if(myid==1)print*,'imdot ge 5',i,imdot,star_mass*scale_m/Msun"
  write(ilun,format)"                    z1 = data_PMS(imdot,i  ,3)"
  write(ilun,format)"                    z2 = data_PMS(imdot,i-1,3)"
  write(ilun,format)"                    "
  write(ilun,format)"                    y1 = data_PMS(imdot,i  ,1)"
  write(ilun,format)"                    y2 = data_PMS(imdot,i-1,1)"
  write(ilun,format)"                    "
  write(ilun,format)"                    a = (z2-z1)/(y2-y1)"
  write(ilun,format)"                    b=z2-a*y2"
  write(ilun,format)"                    "
  write(ilun,format)"                    lum = a*mass + b"
  write(ilun,format)"                    "
  write(ilun,format)"                    z1 = data_PMS(imdot,i  ,4)"
  write(ilun,format)"                    z2 = data_PMS(imdot,i-1,4)"
  write(ilun,format)"                    a = (z2-z1)/(y2-y1)"
  write(ilun,format)"                    b=z2-a*y2"
  write(ilun,format)"                    "
  write(ilun,format)"                    radius = a*mass + b"
  write(ilun,format)"                    "
  write(ilun,format)"                 else !if(imdot .gt. 1 .and. imdot .lt. 5)then"
  write(ilun,format)"                    mdot_real = float(imdot-8)"
  write(ilun,format)"                    "
  write(ilun,format)"                    !   mdot=log10(mdot)"
  write(ilun,format)"                    dd1 = log_mdot - (mdot_real)"
  write(ilun,format)"                    "
  write(ilun,format)"                    i=1"
  write(ilun,format)"                    mass_table = data_PMS(imdot,i,1)"
  write(ilun,format)"                    do while(mass_table .lt. mass)"
  write(ilun,format)"                       if((i+1) .gt. nb_ligne_PMS(imdot))then"
  write(ilun,format)"                          GOTO 130"
  write(ilun,format)"                       end if"
  write(ilun,format)"                       i=i+1"
  write(ilun,format)"                       mass_table = data_PMS(imdot,i,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"130                 dd2 = mass - mass_table"
  write(ilun,format)"                    im1=i"
  write(ilun,format)"                    "
  write(ilun,format)"                    i=1"
  write(ilun,format)"                    mass_table = data_PMS(imdot+1,i,1)"
  write(ilun,format)"                    do while(mass_table .lt. mass)"
  write(ilun,format)"                       dd2 = mass - mass_table      "
  write(ilun,format)"                       if((i+1) .gt. nb_ligne_PMS(imdot))then"
  write(ilun,format)"                          GOTO 140"
  write(ilun,format)"                       end if"
  write(ilun,format)"                       i=i+1"
  write(ilun,format)"                       mass_table = data_PMS(imdot+1,i,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    "
  write(ilun,format)"140                 im2=i"
  write(ilun,format)"                    "
  write(ilun,format)"                    de1 = 1.0d0 - dd1"
  write(ilun,format)"                    de2 = 1.0d0 - dd2"
  write(ilun,format)"                    Lum = 0.d0"
  write(ilun,format)"                    "
  write(ilun,format)"!if(myid==1)print*,im1,im2,imdot,star_mass*scale_m/Msun"
  write(ilun,format)"                    Lum = Lum + de1*de2*data_PMS(imdot  ,im1  ,3)"
  write(ilun,format)"                    Lum = Lum + dd1*de2*data_PMS(imdot+1,im2  ,3)"
  write(ilun,format)"                    Lum = Lum + de1*dd2*data_PMS(imdot  ,im1-1,3)"
  write(ilun,format)"                    Lum = Lum + dd1*dd2*data_PMS(imdot+1,im2-1,3)"
  write(ilun,format)"                    "
  write(ilun,format)"                    radius = 0.d0"
  write(ilun,format)"                    "
  write(ilun,format)"                    radius = radius + de1*de2*data_PMS(imdot  ,im1  ,4)"
  write(ilun,format)"                    radius = radius + dd1*de2*data_PMS(imdot+1,im2  ,4)"
  write(ilun,format)"                    radius = radius + de1*dd2*data_PMS(imdot  ,im1-1,4)"
  write(ilun,format)"                    radius = radius + dd1*dd2*data_PMS(imdot+1,im2-1,4)"
  write(ilun,format)"                    "
  write(ilun,format)"                 end if"
  write(ilun,format)"                 "
  write(ilun,format)"110              int_lum(isink) = (10.0d0**(lum))*Lsun/(scale_d*scale_v**2*scale_l**3/scale_t)"
  write(ilun,format)"                 radius=(10.0d0**radius)*Rsun/scale_l"
  write(ilun,format)" !             end ifs"
  write(ilun,format)"!              acc_lum(isink) = facc_star_lum*star_mass*star_mass/(t-tsink(isink))/radius!acc_rate(isink)/radiu"
  write(ilun,format)"              acc_lum(isink) = facc_star_lum*star_mass*facc_star*acc_rate(isink)/radius"
  write(ilun,format)""
  write(ilun,format)"!              print*,'Acc_lum',facc_star_lum,star_mass,(t-tsink(isink)),radius!acc_rate(isink)/radius"
  write(ilun,format)"              lum_sink(isink)=acc_lum(isink)+int_lum(isink)"
  write(ilun,format)"              surface = 4.*pi*(radius*scale_l)**2 ! stellar surface in cgs"
  write(ilun,format)"              Teff_sink(isink) = (lum_sink(isink) *(scale_d*scale_v**2*scale_l**3/scale_t) /(5.6705d-5*surface))**0.25"
  write(ilun,format)"              rsink_star(isink) = radius"
  write(ilun,format)""
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     else ! compute luminosity following the empirical Mass-Luminosity relation (Cox & Giuli's book, p. 8) "
  write(ilun,format)"        do isink=1,nsink"
  write(ilun,format)"           star_mass=facc_star*msink(isink)"
  write(ilun,format)"           if((star_mass*scale_m/Msun) .gt. 1.d-2 .and. (t-tsink(isink))*(scale_t/year) .gt. 5000.)then "
  write(ilun,format)"              lum = -10."
  write(ilun,format)"              mass_reduced=star_mass*scale_m/Msun"
  write(ilun,format)"              if((mass_reduced .gt. 2.d-1) .and. (mass_reduced .lt. 6.d-1)  )then"
  write(ilun,format)"                 lum=-0.59d0+2.64d0*log10(mass_reduced)"
  write(ilun,format)"              else if((mass_reduced .gt. 6.d-1) .and. (mass_reduced .lt. 2.5)  )then"
  write(ilun,format)"                 lum=-0.13d0+4.55d0*log10(mass_reduced)"
  write(ilun,format)"              else if((mass_reduced .gt. 2.5) .and. (mass_reduced .lt. 20.0d0)  )then"
  write(ilun,format)"                 lum=0.27d0+3.60d0*log10(mass_reduced)"
  write(ilun,format)"              end if"
  write(ilun,format)"              "
  write(ilun,format)"              if(lum .ne. -10)then"
  write(ilun,format)"                 int_lum(isink)=(10.0d0**(lum))*Lsun/(scale_d*scale_v**2*scale_l**3/scale_t)"
  write(ilun,format)"              else"
  write(ilun,format)"                 int_lum(isink)=0.0d0"
  write(ilun,format)"              end if"
  write(ilun,format)"              "
  write(ilun,format)"              acc_lum(isink) = 0.0d0"
  write(ilun,format)"              radius=-0.66d0 ! Lower limit form Cox book, ~ 0.2 R_sol"
  write(ilun,format)"              mass_reduced=star_mass*scale_m/Msun"
  write(ilun,format)"              if((mass_reduced .gt. 2.d-1) .and. (mass_reduced .lt. 1.5)  )then"
  write(ilun,format)"                 radius=-0.03d0+0.9d0*log10(mass_reduced)"
  write(ilun,format)"              else if((mass_reduced .gt. 1.5d0) .and. (mass_reduced .lt. 5)  )then"
  write(ilun,format)"                 radius=0.05d0+0.51d0*log10(mass_reduced)"
  write(ilun,format)"              else if((mass_reduced .gt. 5.) .and. (mass_reduced .lt. 20.0d0)  )then"
  write(ilun,format)"                 radius=-0.13d0+0.78d0*log10(mass_reduced)"
  write(ilun,format)"              end if"
  write(ilun,format)"              radius=(10.0d0**radius)*Rsun/scale_l"
  write(ilun,format)"              acc_lum(isink) = facc_star_lum*star_mass*acc_rate(isink)/radius"
  write(ilun,format)"              "
  write(ilun,format)"              lum_sink(isink)=acc_lum(isink)+int_lum(isink)"
  write(ilun,format)""
  write(ilun,format)"              surface = 4.*pi*(radius*scale_l)**2 ! stellar surface in cgs"
  write(ilun,format)"              Teff_sink(isink) = (lum_sink(isink) *(scale_d*scale_v**2*scale_l**3/scale_t) /(5.6705d-5*surface))**0.25"
  write(ilun,format)"              rsink_star(isink) = radius ! code units"
  write(ilun,format)""
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if (write_sinks)then "
  write(ilun,format)"     call print_sink_properties(dMEDoverdt,rho_inf,r2,v_bondi)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"contains"
  write(ilun,format)"  ! Routine to return alpha, defined as rho/rho_inf, for a critical"
  write(ilun,format)"  ! Bondi accretion solution. The argument is x = r / r_Bondi."
  write(ilun,format)"  ! This is from Krumholz et al. (AJC)"
  write(ilun,format)"  REAL(dp) function bondi_alpha(x)"
  write(ilun,format)"    implicit none"
  write(ilun,format)"    REAL(dp) x"
  write(ilun,format)"    REAL(dp), PARAMETER :: XMIN=0.01, xMAX=2.0"
  write(ilun,format)"    INTEGER, PARAMETER :: NTABLE=51"
  write(ilun,format)"    REAL(dp) lambda_c, xtable, xtablep1, alpha_exp"
  write(ilun,format)"    integer idx"
  write(ilun,format)"    !     Table of alpha values. These correspond to x values that run from"
  write(ilun,format)"    !     0.01 to 2.0 with uniform logarithmic spacing. The reason for"
  write(ilun,format)"    !     this choice of range is that the asymptotic expressions are "
  write(ilun,format)"    !     accurate to better than 2% outside this range."
  write(ilun,format)"    REAL(dp), PARAMETER, DIMENSION(NTABLE) :: alphatable = (/ &"
  write(ilun,format)"         820.254, 701.882, 600.752, 514.341, 440.497, 377.381, 323.427, &"
  write(ilun,format)"         277.295, 237.845, 204.1, 175.23, 150.524, 129.377, 111.27, 95.7613, &"
  write(ilun,format)"         82.4745, 71.0869, 61.3237, 52.9498, 45.7644, 39.5963, 34.2989, &"
  write(ilun,format)"         29.7471, 25.8338, 22.4676, 19.5705, 17.0755, 14.9254, 13.0714, &"
  write(ilun,format)"         11.4717, 10.0903, 8.89675, 7.86467, 6.97159, 6.19825, 5.52812, &"
  write(ilun,format)"         4.94699, 4.44279, 4.00497, 3.6246, 3.29395, 3.00637, 2.75612, &"
  write(ilun,format)"         2.53827, 2.34854, 2.18322, 2.03912, 1.91344, 1.80378, 1.70804, &"
  write(ilun,format)"         1.62439 /)"
  write(ilun,format)"    !     Define a constant that appears in these formulae"
  write(ilun,format)"    lambda_c    = 0.25 * exp(1.5)"
  write(ilun,format)"    !     Deal with the off-the-table cases"
  write(ilun,format)"    if (x .le. XMIN) then"
  write(ilun,format)"       bondi_alpha = lambda_c / sqrt(2. * x**3)"
  write(ilun,format)"    else if (x .ge. XMAX) then"
  write(ilun,format)"       bondi_alpha = exp(1./x)"
  write(ilun,format)"    else"
  write(ilun,format)"       !     We are on the table"
  write(ilun,format)"       idx = floor ((NTABLE-1) * log(x/XMIN) / log(XMAX/XMIN))"
  write(ilun,format)"       xtable = exp(log(XMIN) + idx*log(XMAX/XMIN)/(NTABLE-1))"
  write(ilun,format)"       xtablep1 = exp(log(XMIN) + (idx+1)*log(XMAX/XMIN)/(NTABLE-1))"
  write(ilun,format)"       alpha_exp = log(x/xtable) / log(xtablep1/xtable)"
  write(ilun,format)"       !     Note the extra +1s below because of fortran 1 offset arrays"
  write(ilun,format)"       bondi_alpha = alphatable(idx+1) * (alphatable(idx+2)/alphatable(idx+1))**alpha_exp"
  write(ilun,format)"    end if"
  write(ilun,format)"  end function bondi_alpha"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine compute_accretion_rate"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine print_sink_properties(dMEDoverdt,rho_inf,r2,v_bondi)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp),dimension(1:nsinkmax)::dMEDoverdt  "
  write(ilun,format)"  integer::i,isink"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v,scale_m"
  write(ilun,format)"  real(dp)::l_abs"
  write(ilun,format)"  real(dp)::v_bondi,r2,rho_inf"
  write(ilun,format)""
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  scale_m=scale_d*scale_l**3d0"
  write(ilun,format)"  "
  write(ilun,format)"  if (smbh) then"
  write(ilun,format)"     if(myid==1.and.nsink>0)then"
  write(ilun,format)"        xmsink(1:nsink)=msink(1:nsink)"
  write(ilun,format)"        call quick_sort_dp(xmsink(1),idsink_sort(1),nsink)"
  write(ilun,format)"        write(*,*)'Number of sink = ',nsink"
  write(ilun,format)"        write(*,'(' ============================================================================================')')"
  write(ilun,format)"        write(*,'(' Id     Mass(Msol) Bondi(Msol/yr)   Edd(Msol/yr)              x              y              z')')"
  write(ilun,format)"        write(*,'(' ============================================================================================')')"
  write(ilun,format)"        do i=nsink,max(nsink-10,1),-1"
  write(ilun,format)"           isink=idsink_sort(i)"
  write(ilun,format)"           write(*,'(I3,10(1X,1PE14.7))')idsink(isink),msink(isink)*scale_m/2d33 &"
  write(ilun,format)"                & ,dMBHoverdt(isink)*scale_m/scale_t/(2d33/(365.*24.*3600.)) &"
  write(ilun,format)"                & ,dMEDoverdt(isink)*scale_m/scale_t/(2d33/(365.*24.*3600.)) &"
  write(ilun,format)"                & ,xsink(isink,1:ndim),delta_mass(isink)*scale_m/2d33"
  write(ilun,format)"        end do"
  write(ilun,format)"        write(*,'(' ============================================================================================')')"
  write(ilun,format)"        if(verbose_AGN)then"
  write(ilun,format)"          write(*,'(' Id     rho(H/cc)  rho_inf(H/cc) Mgas(Msol) cs(km/s) rBondi(pc)')')"
  write(ilun,format)"          write(*,'(' vgas(km/s):  x   y   z     vsink(km/s):  x   y   z')')"
  write(ilun,format)"          write(*,'(' ============================================================================================')')"
  write(ilun,format)"          do i=nsink,max(nsink-10,1),-1"
  write(ilun,format)"            isink=idsink_sort(i)"
  write(ilun,format)"            write(*,'(I3,12(1X,1PE14.7))')idsink(isink),rho_gas(isink)*scale_nH,rho_inf*scale_nH &"
  write(ilun,format)"                & ,rho_gas(isink)*volume_gas(isink)*scale_m/2d33,sqrt(c2sink(isink))*scale_v/1e5 &"
  write(ilun,format)"                & ,sqrt(r2)*scale_l/3.086e18"
  write(ilun,format)"            write(*,'(6(1X,1PE14.7))')vel_gas(isink,1:ndim)*scale_v/1e5,vsink(isink,1:ndim)*scale_v/1e5"
  write(ilun,format)"          end do"
  write(ilun,format)"          write(*,'(' ============================================================================================')')"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)"  if (.not. smbh)then    "
  write(ilun,format)"     if(myid==1.and.nsink>0.and. mod(nstep_coarse,ncontrol)==0)then"
  write(ilun,format)"        xmsink(1:nsink)=msink(1:nsink)"
  write(ilun,format)"        call quick_sort_dp(xmsink(1),idsink_sort(1),nsink)"
  write(ilun,format)"        write(*,*)'Number of sink = ',nsink"
  write(ilun,format)"        write(*,*)'Total mass in sink = ',sum(msink(1:nsink))*scale_m/Msun"
  write(ilun,format)"        write(*,*)'simulation time = ',t"
  write(ilun,format)"        write(*,'(' ============================================================================================================================================================================= ')')"
  write(ilun,format)"        write(*,'('   Id     M[Msol]          x             y             z            vx            vy            vz    acc_rate[Msol/y] acc_lum[Lsol]     age[y]    int_lum[Lsol]     Teff [K] ')')"
  write(ilun,format)"        write(*,'(' ============================================================================================================================================================================= ')')"
  write(ilun,format)"        do i=nsink,1,-1"
  write(ilun,format)"           isink=idsink_sort(i)"
  write(ilun,format)"           l_abs=(lsink(isink,1)**2+lsink(isink,2)**2+lsink(isink,3)**2)**0.5+1.d10*tiny(0.d0)"
  write(ilun,format)"           write(*,'(I5,12(2X,E12.5))')&"
  write(ilun,format)"                idsink(isink),msink(isink)*scale_m/Msun, &"
  write(ilun,format)"                xsink(isink,1:ndim),vsink(isink,1:ndim),&"
  write(ilun,format)"                acc_rate(isink)*scale_m/Msun/(scale_t)*year,acc_lum(isink)/scale_t**2*scale_l**3*scale_d*scale_l**2/scale_t/Lsun,&"
  write(ilun,format)"                (t-tsink(isink))*scale_t/year,&"
  write(ilun,format)"                int_lum(isink)*scale_d*scale_l**3*scale_v**2/scale_t/Lsun,Teff_sink(isink)"
  write(ilun,format)"        end do"
  write(ilun,format)"        write(*,'(' ============================================================================================================================================================================= ')')"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"end subroutine print_sink_properties"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine quenching(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine selects regions which are eligible for SMBH formation."
  write(ilun,format)"  ! It is based on a stellar density threshold and on a stellar velocity"
  write(ilun,format)"  ! dispersion threshold."
  write(ilun,format)"  ! On exit, flag2 array is set to 0 for AGN sites and to 1 otherwise."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc"
  write(ilun,format)"  real(dp)::str_d,tot_m,ave_u,ave_v,ave_w,sig_u,sig_v,sig_w"
  write(ilun,format)"  integer::igrid,ipart,jpart,next_part,ind_cell,iskip,ind"
  write(ilun,format)"  integer::i,npart1,npart2,nx_loc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  ! Gather star particles only."
  write(ilun,format)""
  write(ilun,format)"  ! Loop over grids"
  write(ilun,format)"  do i=1,active(ilevel)%ngrid"
  write(ilun,format)"     igrid=active(ilevel)%igrid(i)"
  write(ilun,format)"     ! Number of particles in the grid"
  write(ilun,format)"     npart1=numbp(igrid)"
  write(ilun,format)"     npart2=0"
  write(ilun,format)"     "
  write(ilun,format)"     ! Reset velocity moments"
  write(ilun,format)"     str_d=0.0"
  write(ilun,format)"     tot_m=0.0"
  write(ilun,format)"     ave_u=0.0"
  write(ilun,format)"     ave_v=0.0"
  write(ilun,format)"     ave_w=0.0"
  write(ilun,format)"     sig_u=0.0"
  write(ilun,format)"     sig_v=0.0"
  write(ilun,format)"     sig_w=0.0"
  write(ilun,format)"     "
  write(ilun,format)"     ! Count star particles"
  write(ilun,format)"     if(npart1>0)then"
  write(ilun,format)"        ipart=headp(igrid)"
  write(ilun,format)"        ! Loop over particles"
  write(ilun,format)"        do jpart=1,npart1"
  write(ilun,format)"           ! Save next particle   <--- Very important !!!"
  write(ilun,format)"           next_part=nextp(ipart)"
  write(ilun,format)"           if(idp(ipart).gt.0.and.tp(ipart).ne.0)then"
  write(ilun,format)"              npart2=npart2+1"
  write(ilun,format)"              tot_m=tot_m+mp(ipart)"
  write(ilun,format)"              ave_u=ave_u+mp(ipart)*vp(ipart,1)"
  write(ilun,format)"              ave_v=ave_v+mp(ipart)*vp(ipart,2)"
  write(ilun,format)"              ave_w=ave_w+mp(ipart)*vp(ipart,3)"
  write(ilun,format)"              sig_u=sig_u+mp(ipart)*vp(ipart,1)**2"
  write(ilun,format)"              sig_v=sig_v+mp(ipart)*vp(ipart,2)**2"
  write(ilun,format)"              sig_w=sig_w+mp(ipart)*vp(ipart,3)**2"
  write(ilun,format)"           endif"
  write(ilun,format)"           ipart=next_part  ! Go to next particle"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)"     "
  write(ilun,format)"     ! Normalize velocity moments"
  write(ilun,format)"     if(npart2.gt.0)then"
  write(ilun,format)"        ave_u=ave_u/tot_m"
  write(ilun,format)"        ave_v=ave_v/tot_m"
  write(ilun,format)"        ave_w=ave_w/tot_m"
  write(ilun,format)"        sig_u=sqrt(sig_u/tot_m-ave_u**2)*scale_v/1d5"
  write(ilun,format)"        sig_v=sqrt(sig_v/tot_m-ave_v**2)*scale_v/1d5"
  write(ilun,format)"        sig_w=sqrt(sig_w/tot_m-ave_w**2)*scale_v/1d5"
  write(ilun,format)"        str_d=tot_m/(2**ndim*vol_loc)*scale_nH"
  write(ilun,format)"     endif"
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        ind_cell=iskip+igrid"
  write(ilun,format)"        ! AGN formation sites"
  write(ilun,format)"        ! if n_star>0.1 H/cc and v_disp>100 km/s"
  write(ilun,format)"        if(str_d>0.1.and.MAX(sig_u,sig_v,sig_w)>100.)then"
  write(ilun,format)"           flag2(ind_cell)=0"
  write(ilun,format)"        else"
  write(ilun,format)"           flag2(ind_cell)=1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering quenching for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine quenching"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine make_sink_from_clump(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  use clfind_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! This routine uses creates a sink in every cell which was flagged (flag2)"
  write(ilun,format)"  ! The global sink variables are updated"
  write(ilun,format)"  ! The true RAMSES particle is NOT produced here..."
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer ::ncache,nnew,ivar,irad,ngrid,icpu,index_sink,index_sink_tot"
  write(ilun,format)"  integer ::igrid,ix,iy,iz,ind,i,iskip,isink,nx_loc"
  write(ilun,format)"  integer ::ntot,ntot_all,info"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid_new,ind_cell_new"
  write(ilun,format)"  integer ,dimension(1:ncpu)::ntot_sink_cpu,ntot_sink_all"
  write(ilun,format)"  integer::ipart,peak_nr,grid"
  write(ilun,format)"  logical ::ok_free"
  write(ilun,format)"  real(dp)::d,u,v,w,e,factG,delta_d,v2,eint"
  write(ilun,format)"  real(dp)::birth_epoch"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc"
  write(ilun,format)"  real(dp)::fourpi,threepi2,tff,tsal"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp)::d_ball,vol,mclump"
  write(ilun,format)"  real(dp),dimension(1:nlevelmax)::volume"
  write(ilun,format)"  real(dp),dimension(1:nvar)::z"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc,x,xcell,xpeak"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  real(dp)::bx1,bx2,by1,by2,bz1,bz2"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ht"
  write(ilun,format)"  real(dp)::temp"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'entering make_sink_from_clump for level ',ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel "
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Birth epoch as proper time"
  write(ilun,format)"  if(use_proper_time)then"
  write(ilun,format)"     birth_epoch=texp"
  write(ilun,format)"  else"
  write(ilun,format)"     birth_epoch=t"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Cells center position relative to grid center position"
  write(ilun,format)"  do ind=1,twotondim  "
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Set new sink variables to zero"
  write(ilun,format)"  msink_new=0d0; mseed_new=0d0; tsink_new=0d0; delta_mass_new=0d0; xsink_new=0d0; vsink_new=0d0"
  write(ilun,format)"  oksink_new=0d0; idsink_new=0; new_born_new=.false."
  write(ilun,format)"  dmfsink_new=0d0"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! and count number of new sinks (flagged cells)"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ntot=0"
  write(ilun,format)"  ntot_sink_cpu=0"
  write(ilun,format)"  if(numbtot(1,ilevel)>0)then"
  write(ilun,format)"     ncache=active(ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)"        do ind=1,twotondim  "
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(flag2(ind_cell(i))>0)then"
  write(ilun,format)"                 ntot=ntot+1"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !---------------------------------"
  write(ilun,format)"  ! Compute global sink statistics"
  write(ilun,format)"  !---------------------------------"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(ntot,ntot_all,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  ntot_all=ntot"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  ntot_sink_cpu=0; ntot_sink_all=0"
  write(ilun,format)"  ntot_sink_cpu(myid)=ntot"
  write(ilun,format)"  call MPI_ALLREDUCE(ntot_sink_cpu,ntot_sink_all,ncpu,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  ntot_sink_cpu(1)=ntot_sink_all(1)"
  write(ilun,format)"  do icpu=2,ncpu"
  write(ilun,format)"     ntot_sink_cpu(icpu)=ntot_sink_cpu(icpu-1)+ntot_sink_all(icpu)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"  nsink=nsink+ntot_all  "
  write(ilun,format)"  nindsink=nindsink+ntot_all"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     if(ntot_all.gt.0)then"
  write(ilun,format)"        write(*,'(' Level = ',I6,' New sinks produced from clumps= ',I6,' Total sinks =',I8)')&"
  write(ilun,format)"             & ilevel,ntot_all,nsink"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"  ! Check wether max number of sink is reached"
  write(ilun,format)"  !------------------------------------------"
  write(ilun,format)"  ok_free=(nsink+ntot_all<=nsinkmax)"
  write(ilun,format)"  if(.not. ok_free)then"
  write(ilun,format)"     if(myid==1)write(*,*)'global list of sink particles is too long'"
  write(ilun,format)"     if(myid==1)write(*,*)'New sink particles',ntot_all"
  write(ilun,format)"     if(myid==1)write(*,*)'Increase nsinkmax'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"   "
  write(ilun,format)"  !------------------------------"
  write(ilun,format)"  ! Create new sink particles"
  write(ilun,format)"  !------------------------------"
  write(ilun,format)"  ! Starting identity number"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     index_sink=nsink-ntot_all"
  write(ilun,format)"     index_sink_tot=nindsink-ntot_all"
  write(ilun,format)"  else"
  write(ilun,format)"     index_sink=nsink-ntot_all+ntot_sink_cpu(myid-1)"
  write(ilun,format)"     index_sink_tot=nindsink-ntot_all+ntot_sink_cpu(myid-1)"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"  ! Loop over grids"
  write(ilun,format)"  if(numbtot(1,ilevel)>0)then"
  write(ilun,format)"     ncache=active(ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Gather cells with a new sink"
  write(ilun,format)"           nnew=0"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if (flag2(ind_cell(i))>0)then"
  write(ilun,format)"                 nnew=nnew+1"
  write(ilun,format)"                 ind_grid_new(nnew)=ind_grid(i)"
  write(ilun,format)"                 ind_cell_new(nnew)=ind_cell(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Create new sink particles"
  write(ilun,format)"           do i=1,nnew"
  write(ilun,format)"              index_sink=index_sink+1"
  write(ilun,format)"              index_sink_tot=index_sink_tot+1"
  write(ilun,format)""
  write(ilun,format)"              ! Convert uold to primitive variables"
  write(ilun,format)"              d=max(uold(ind_cell_new(i),1),smallr)"
  write(ilun,format)"              u=uold(ind_cell_new(i),2)/d"
  write(ilun,format)"              v=uold(ind_cell_new(i),3)/d"
  write(ilun,format)"              w=uold(ind_cell_new(i),4)/d"
  write(ilun,format)"              e=uold(ind_cell_new(i),5)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"              bx1=uold(ind_cell_new(i),6)"
  write(ilun,format)"              by1=uold(ind_cell_new(i),7)"
  write(ilun,format)"              bz1=uold(ind_cell_new(i),8)"
  write(ilun,format)"              bx2=uold(ind_cell_new(i),nvar+1)"
  write(ilun,format)"              by2=uold(ind_cell_new(i),nvar+2)"
  write(ilun,format)"              bz2=uold(ind_cell_new(i),nvar+3)"
  write(ilun,format)"              e=e-0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)"              v2=(u**2+v**2+w**2)"
  write(ilun,format)"              e=e-0.5d0*d*v2"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"              do irad=1,nener"
  write(ilun,format)"                 e=e-uold(ind_cell_new(i),inener-1+irad)"
  write(ilun,format)"              end do"
  write(ilun,format)"#endif             "
  write(ilun,format)"              e=e/d"
  write(ilun,format)"              if(energy_fix)e=uold(ind_cell_new(i),nvar)/d"
  write(ilun,format)"              eint=e*d"
  write(ilun,format)"              call temperature_eos(d,eint,temp,ht)"
  write(ilun,format)""
  write(ilun,format)"              do ivar=imetal,lastindex_pscal"
  write(ilun,format)"                 z(ivar)=uold(ind_cell_new(i),ivar)/d"
  write(ilun,format)"              end do"
  write(ilun,format)"              "
  write(ilun,format)"              ! Get density maximum by quadratic expansion around cell center"
  write(ilun,format)"              x(1)=(xg(ind_grid_new(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"              x(2)=(xg(ind_grid_new(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"              x(3)=(xg(ind_grid_new(i),3)+xc(ind,3)-skip_loc(3))*scale              "
  write(ilun,format)"              call true_max(x(1),x(2),x(3),nlevelmax)"
  write(ilun,format)""
  write(ilun,format)"              ! Mass of the new sink"
  write(ilun,format)"              if(mass_sink_seed>=0.0)then"
  write(ilun,format)"                 mseed_new(index_sink)=mass_sink_seed*2d33/(scale_d*scale_l**3)"
  write(ilun,format)"              else"
  write(ilun,format)"                 if(smbh)then"
  write(ilun,format)"                    ! The SMBH/sink mass is the mass that will heat the gas to 10**7 K after creation"
  write(ilun,format)"                    fourpi=4.0d0*ACOS(-1.0d0)"
  write(ilun,format)"                    threepi2=3.0d0*ACOS(-1.0d0)**2"
  write(ilun,format)"                    if(cosmo)fourpi=1.5d0*omega_m*aexp"
  write(ilun,format)"                    tff=sqrt(threepi2/8./fourpi/max(d,smallr))"
  write(ilun,format)"                    tsal=0.1*6.652d-25*3d10/4./3.1415926/6.67d-8/1.66d-24/scale_t"
  write(ilun,format)"                    mclump=clump_mass4(flag2(ind_cell_new(i)))"
  write(ilun,format)"                    mseed_new(index_sink)=min(1.d-5/1.0*mclump*tsal/tff,mclump/2.0)"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 "
  write(ilun,format)"                 if(smbh.and.agn)then"
  write(ilun,format)"                    mclump=clump_mass4(flag2(ind_cell_new(i)))"
  write(ilun,format)"                    mseed_new(index_sink)=0.5*T2_min/T2_AGN*mclump"
  write(ilun,format)"                 end if"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"              ! Give a tiny bit of mass to the sink..."
  write(ilun,format)"              delta_d=d*1.d-10"
  write(ilun,format)"              msink_new(index_sink)=delta_d*vol_loc                    "
  write(ilun,format)"              delta_mass_new(index_sink)=msink_new(index_sink)"
  write(ilun,format)""
  write(ilun,format)"              ! introduced by PH 09/2013 to compute the feedback from sink"
  write(ilun,format)"              dmfsink_new(index_sink)=msink_new(index_sink)"
  write(ilun,format)""
  write(ilun,format)"              ! Global index of the new sink"
  write(ilun,format)"              oksink_new(index_sink)=1d0"
  write(ilun,format)"              idsink_new(index_sink)=index_sink_tot"
  write(ilun,format)""
  write(ilun,format)"              ! Store properties of the new sink"
  write(ilun,format)"              tsink_new(index_sink)=birth_epoch"
  write(ilun,format)"              xsink_new(index_sink,1:3)=x(1:3)"
  write(ilun,format)"              vsink_new(index_sink,1)=u"
  write(ilun,format)"              vsink_new(index_sink,2)=v"
  write(ilun,format)"              vsink_new(index_sink,3)=w"
  write(ilun,format)"              new_born_new(index_sink)=.true."
  write(ilun,format)""
  write(ilun,format)"              ! Convert back to conservative variable                                             "
  write(ilun,format)"              d=d-delta_d"
  write(ilun,format)"!              e=e*d"
  write(ilun,format)"              call enerint_eos(d,temp,e)"
  write(ilun,format)"              if(energy_fix)uold(ind_cell_new(i),nvar)=e"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"              e=e+0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)"              e=e+0.5d0*d*(u**2+v**2+w**2)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"              do irad=1,nener"
  write(ilun,format)"                 e=e+uold(ind_cell_new(i),inener-1+irad)"
  write(ilun,format)"              end do"
  write(ilun,format)"#endif              "
  write(ilun,format)"              uold(ind_cell_new(i),1)=d"
  write(ilun,format)"              uold(ind_cell_new(i),2)=d*u"
  write(ilun,format)"              uold(ind_cell_new(i),3)=d*v"
  write(ilun,format)"              uold(ind_cell_new(i),4)=d*w"
  write(ilun,format)"              uold(ind_cell_new(i),5)=e"
  write(ilun,format)"              do ivar=imetal,lastindex_pscal"
  write(ilun,format)"                 uold(ind_cell_new(i),ivar)=d*z(ivar)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over new sink particle cells"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(oksink_new,oksink_all,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(idsink_new,idsink_all,nsinkmax,MPI_INTEGER         ,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(msink_new ,msink_all ,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(mseed_new ,mseed_all ,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)""
  write(ilun,format)"  !introduced by PH 09/2013 to compute the feedback from sink"
  write(ilun,format)"  call MPI_ALLREDUCE(dmfsink_new, dmfsink_all, nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)""
  write(ilun,format)"  call MPI_ALLREDUCE(tsink_new ,tsink_all ,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(xsink_new ,xsink_all ,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(vsink_new ,vsink_all ,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(delta_mass_new,delta_mass_all,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(new_born_new,new_born_all,nsinkmax,MPI_LOGICAL,MPI_LOR,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  oksink_all=oksink_new"
  write(ilun,format)"  idsink_all=idsink_new"
  write(ilun,format)"  msink_all=msink_new"
  write(ilun,format)"  mseed_all=mseed_new"
  write(ilun,format)""
  write(ilun,format)"  !introduced by PH 09/2013 to compute the feedback from sink"
  write(ilun,format)"  dmfsink_all=dmfsink_new"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  tsink_all=tsink_new"
  write(ilun,format)"  xsink_all=xsink_new"
  write(ilun,format)"  vsink_all=vsink_new"
  write(ilun,format)"  delta_mass_all=delta_mass_new"
  write(ilun,format)"  new_born_all=new_born_new"
  write(ilun,format)"#endif"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     if(oksink_all(isink)==1)then"
  write(ilun,format)"        idsink(isink)=idsink_all(isink)"
  write(ilun,format)"        msink(isink)=msink_all(isink)"
  write(ilun,format)"        mseed(isink)=mseed_all(isink)"
  write(ilun,format)""
  write(ilun,format)"        !introduced by PH 09/2013 to follow the feedback from the sinks"
  write(ilun,format)"        dmfsink(isink)=dmfsink_all(isink)"
  write(ilun,format)""
  write(ilun,format)"        tsink(isink)=tsink_all(isink)"
  write(ilun,format)"        xsink(isink,1:ndim)=xsink_all(isink,1:ndim)"
  write(ilun,format)"        vsink(isink,1:ndim)=vsink_all(isink,1:ndim)"
  write(ilun,format)"        delta_mass(isink)=delta_mass_all(isink)"
  write(ilun,format)"        acc_rate(isink)=msink_all(isink)"
  write(ilun,format)"        new_born(isink)=new_born_all(isink)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_sink_from_clump"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine true_max(x,y,z,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use clfind_commons, only:ivar_clump"
  write(ilun,format)"  use poisson_commons, only:rho"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp)::x,y,z"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------------"
  write(ilun,format)"  ! Description: This subroutine takes the cell of maximum density and computes"
  write(ilun,format)"  ! the true maximum by expanding the density around the cell center to second order."
  write(ilun,format)"  !----------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::k,j,i,nx_loc,counter, ioft, n"
  write(ilun,format)"  integer,dimension(1:threetondim)::cell_index,cell_lev"
  write(ilun,format)"  real(dp)::det,dx,dx_loc,scale,disp_max,numerator"
  write(ilun,format)"  real(dp),dimension(-1:1,-1:1,-1:1)::cube3"
  write(ilun,format)"  real(dp),dimension(1:threetondim,1:ndim)::xtest"
  write(ilun,format)"  real(dp),dimension(1:ndim)::gradient,displacement"
  write(ilun,format)"  real(dp),dimension(1:ndim,1:ndim)::hess,minor"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  dx=0.5D0**ilevel "
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  counter=0"
  write(ilun,format)"  do i=-1,1"
  write(ilun,format)"     do j=-1,1"
  write(ilun,format)"        do k=-1,1"
  write(ilun,format)"           counter=counter+1"
  write(ilun,format)"           xtest(counter,1)=x+i*dx_loc"
  write(ilun,format)"           xtest(counter,2)=y+j*dx_loc"
  write(ilun,format)"           xtest(counter,3)=z+k*dx_loc"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do ioft = 0, threetondim - 1, nvector"
  write(ilun,format)"     n = min(threetondim - ioft, nvector)"
  write(ilun,format)"     call get_cell_index(cell_index(ioft + 1 : ioft + n), cell_lev(ioft + 1 : ioft + n), &"
  write(ilun,format)"          xtest(ioft + 1 : ioft + n, 1 : ndim), ilevel, n)"
  write(ilun,format)"  end do"
  write(ilun,format)"     "
  write(ilun,format)"     "
  write(ilun,format)"  counter=0"
  write(ilun,format)"  if(ivar_clump==0)then"
  write(ilun,format)"     do i=-1,1"
  write(ilun,format)"        do j=-1,1"
  write(ilun,format)"           do k=-1,1"
  write(ilun,format)"              counter=counter+1"
  write(ilun,format)"              cube3(i,j,k)=rho(cell_index(counter))"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  else if(hydro)then"
  write(ilun,format)"     do i=-1,1"
  write(ilun,format)"        do j=-1,1"
  write(ilun,format)"           do k=-1,1"
  write(ilun,format)"              counter=counter+1"
  write(ilun,format)"              cube3(i,j,k)=uold(cell_index(counter),1)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"     return   "
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"! compute gradient"
  write(ilun,format)"  gradient(1)=0.5*(cube3(1,0,0)-cube3(-1,0,0))/dx_loc"
  write(ilun,format)"  gradient(2)=0.5*(cube3(0,1,0)-cube3(0,-1,0))/dx_loc"
  write(ilun,format)"  gradient(3)=0.5*(cube3(0,0,1)-cube3(0,0,-1))/dx_loc"
  write(ilun,format)""
  write(ilun,format)"  if (maxval(abs(gradient(1:3)))==0.)return  "
  write(ilun,format)""
  write(ilun,format)"  ! compute hessian"
  write(ilun,format)"  hess(1,1)=(cube3(1,0,0)+cube3(-1,0,0)-2*cube3(0,0,0))/dx_loc**2."
  write(ilun,format)"  hess(2,2)=(cube3(0,1,0)+cube3(0,-1,0)-2*cube3(0,0,0))/dx_loc**2."
  write(ilun,format)"  hess(3,3)=(cube3(0,0,1)+cube3(0,0,-1)-2*cube3(0,0,0))/dx_loc**2."
  write(ilun,format)"  "
  write(ilun,format)"  hess(1,2)=0.25*(cube3(1,1,0)+cube3(-1,-1,0)-cube3(1,-1,0)-cube3(-1,1,0))/dx_loc**2."
  write(ilun,format)"  hess(2,1)=hess(1,2)"
  write(ilun,format)"  hess(1,3)=0.25*(cube3(1,0,1)+cube3(-1,0,-1)-cube3(1,0,-1)-cube3(-1,0,1))/dx_loc**2."
  write(ilun,format)"  hess(3,1)=hess(1,3)"
  write(ilun,format)"  hess(2,3)=0.25*(cube3(0,1,1)+cube3(0,-1,-1)-cube3(0,1,-1)-cube3(0,-1,1))/dx_loc**2."
  write(ilun,format)"  hess(3,2)=hess(2,3)"
  write(ilun,format)""
  write(ilun,format)"  !determinant"
  write(ilun,format)"  det=hess(1,1)*hess(2,2)*hess(3,3)+hess(1,2)*hess(2,3)*hess(3,1)+hess(1,3)*hess(2,1)*hess(3,2) &"
  write(ilun,format)"       -hess(1,1)*hess(2,3)*hess(3,2)-hess(1,2)*hess(2,1)*hess(3,3)-hess(1,3)*hess(2,2)*hess(3,1)"
  write(ilun,format)""
  write(ilun,format)"  !matrix of minors"
  write(ilun,format)"  minor(1,1)=hess(2,2)*hess(3,3)-hess(2,3)*hess(3,2)"
  write(ilun,format)"  minor(2,2)=hess(1,1)*hess(3,3)-hess(1,3)*hess(3,1)"
  write(ilun,format)"  minor(3,3)=hess(1,1)*hess(2,2)-hess(1,2)*hess(2,1)"
  write(ilun,format)""
  write(ilun,format)"  minor(1,2)=-1.*(hess(2,1)*hess(3,3)-hess(2,3)*hess(3,1))"
  write(ilun,format)"  minor(2,1)=minor(1,2)"
  write(ilun,format)"  minor(1,3)=hess(2,1)*hess(3,2)-hess(2,2)*hess(3,1)"
  write(ilun,format)"  minor(3,1)=minor(1,3)"
  write(ilun,format)"  minor(2,3)=-1.*(hess(1,1)*hess(3,2)-hess(1,2)*hess(3,1))"
  write(ilun,format)"  minor(3,2)=minor(2,3)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !displacement of the true max from the cell center"
  write(ilun,format)"  displacement=0."
  write(ilun,format)"  do i=1,3"
  write(ilun,format)"     do j=1,3"
  write(ilun,format)"        numerator = gradient(j)*minor(i,j)"
  write(ilun,format)"        if(numerator>0) displacement(i)=displacement(i)-numerator/(det+10.*numerator*tiny(0.d0))"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !clipping the displacement in order to keep max in the cell"
  write(ilun,format)"  disp_max=maxval(abs(displacement(1:3)))"
  write(ilun,format)"  if (disp_max > dx_loc*0.499999)then"
  write(ilun,format)"     displacement(1)=displacement(1)/disp_max*dx_loc*0.499999"
  write(ilun,format)"     displacement(2)=displacement(2)/disp_max*dx_loc*0.499999"
  write(ilun,format)"     displacement(3)=displacement(3)/disp_max*dx_loc*0.499999"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  x=x+displacement(1)"
  write(ilun,format)"  y=y+displacement(2)"
  write(ilun,format)"  z=z+displacement(3)"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)"end subroutine true_max"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine update_sink(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"! This routine is called at the leafs of the tree structure (right after    "
  write(ilun,format)"! update time). Here is where the global sink variables vsink and xsink are "
  write(ilun,format)"! updated by summing the conributions from all levels.                      "
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dteff"
  write(ilun,format)"  integer::lev,isink"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering update_sink for level ',ilevel"
  write(ilun,format)""
  write(ilun,format)"  fsink=0."
  write(ilun,format)"  call f_sink_sink"
  write(ilun,format)""
  write(ilun,format)"  vsold(1:nsink,1:ndim,ilevel)=vsnew(1:nsink,1:ndim,ilevel)"
  write(ilun,format)"  vsnew(1:nsink,1:ndim,ilevel)=vsink(1:nsink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over sinks"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)""
  write(ilun,format)"     ! sum force contributions from all levels and gather "
  write(ilun,format)"     do lev=levelmin,nlevelmax"
  write(ilun,format)"        fsink(isink,1:ndim)=fsink(isink,1:ndim)+fsink_partial(isink,1:ndim,lev)"
  write(ilun,format)"     end do"
  write(ilun,format)"     if (.not. direct_force_sink(isink))then"
  write(ilun,format)"        fsink(isink,1:ndim)=fsink(isink,1:ndim)/dble(ncloud_sink)"
  write(ilun,format)"     end if"
  write(ilun,format)"     "
  write(ilun,format)"     ! compute timestep for the synchronization"
  write(ilun,format)"     if (new_born(isink))then"
  write(ilun,format)"        ! no sync necessary for newly produced sink"
  write(ilun,format)"        dteff=0d0 "
  write(ilun,format)"     else"
  write(ilun,format)"        if(sinkint_level>ilevel)then"
  write(ilun,format)"           ! level at which sinks are integrated has increased"
  write(ilun,format)"           ! newdt_fine at coarser level has not been computed "
  write(ilun,format)"           ! -> use dtnew from coarse level"
  write(ilun,format)"           dteff=dtnew(sinkint_level)"
  write(ilun,format)"        else "
  write(ilun,format)"           ! normal case: finish timestep using dtold from current level."
  write(ilun,format)"           dteff=dtold(sinkint_level)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)"     "
  write(ilun,format)"     ! this is the kick-kick (half old half new timestep)"
  write(ilun,format)"     vsink(isink,1:ndim)=0.5D0*(dtnew(ilevel)+dteff)*fsink(isink,1:ndim)+vsink(isink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"     ! save the velocity"
  write(ilun,format)"     vsnew(isink,1:ndim,ilevel)=vsink(isink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"     ! this is the kick-kick (half old half new timestep)"
  write(ilun,format)"     vsink(isink,1:ndim)=0.5D0*(dtnew(ilevel)+dteff)*fsink(isink,1:ndim)+vsink(isink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"     ! save the velocity"
  write(ilun,format)"     vsnew(isink,1:ndim,ilevel)=vsink(isink,1:ndim)"
  write(ilun,format)"     "
  write(ilun,format)"     ! and this is the drift (only for the global sink variable)"
  write(ilun,format)"     xsink(isink,1:ndim)=xsink(isink,1:ndim)+vsink(isink,1:ndim)*dtnew(ilevel)"
  write(ilun,format)"     new_born(isink)=.false."
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over sinks"
  write(ilun,format)""
  write(ilun,format)"  ! Store deepest level"
  write(ilun,format)"  sinkint_level=ilevel  "
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine update_sink"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine update_cloud(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! update sink cloud particle properties"
  write(ilun,format)"  ! -the particles are moved whenever the level of the grid they sit in is updated"
  write(ilun,format)"  ! -the amount of drift they get is according to their levelp"
  write(ilun,format)"  ! -since this is happening on the way down, at level ilevel all particles with"
  write(ilun,format)"  ! level >= ilevel will be moved. Therefore, the sink_jump for all levels >= ilevel"
  write(ilun,format)"  ! is set ot zero on exit."
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part,ig,ip,npart1,isink,nx_loc"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel "
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Update particles position and velocity"
  write(ilun,format)"  ig=0"
  write(ilun,format)"  ip=0"
  write(ilun,format)"  ! Loop over grids "
  write(ilun,format)"  igrid=headl(myid,ilevel)"
  write(ilun,format)"  do jgrid=1,numbl(myid,ilevel)"
  write(ilun,format)"     npart1=numbp(igrid)  ! Number of particles in the grid "
  write(ilun,format)"     if(npart1>0)then"
  write(ilun,format)"        ig=ig+1"
  write(ilun,format)"        ind_grid(ig)=igrid"
  write(ilun,format)"        ipart=headp(igrid)"
  write(ilun,format)"        ! Loop over particles"
  write(ilun,format)"        do jpart=1,npart1"
  write(ilun,format)"           ! Save next particle  <---- Very important !!!"
  write(ilun,format)"           next_part=nextp(ipart) !move only particles which do actually belong to that level"
  write(ilun,format)"           if(ig==0)then"
  write(ilun,format)"              ig=1"
  write(ilun,format)"              ind_grid(ig)=igrid"
  write(ilun,format)"           end if"
  write(ilun,format)"           ip=ip+1"
  write(ilun,format)"           ind_part(ip)=ipart"
  write(ilun,format)"           ind_grid_part(ip)=ig"
  write(ilun,format)"           if(ip==nvector)then"
  write(ilun,format)"              call upd_cloud(ind_part,ip)"
  write(ilun,format)"              ip=0"
  write(ilun,format)"              ig=0"
  write(ilun,format)"           end if"
  write(ilun,format)"           ipart=next_part  ! Go to next particle"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over particles"
  write(ilun,format)"     end if"
  write(ilun,format)"     igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)"  if(ip>0)call upd_cloud(ind_part,ip)"
  write(ilun,format)"  "
  write(ilun,format)"  if (myid==1.and.verbose)then"
  write(ilun,format)"     write(*,*)'sink drift due to accretion relative to grid size at level ',ilevel"
  write(ilun,format)"     do isink=1,nsink"
  write(ilun,format)"        write(*,*)'#sink: ',isink,' drift: ',sink_jump(isink,1:ndim,ilevel)/dx_loc"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  sink_jump(1:nsink,1:ndim,ilevel:nlevelmax)=0.d0"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering update_cloud for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine update_cloud"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine upd_cloud(ind_part,np)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::np"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_part"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------"
  write(ilun,format)"  ! Vector loop called by update_cloud"
  write(ilun,format)"  !------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::j,idim,isink,lev"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::new_xp,new_vp"
  write(ilun,format)"  integer,dimension(1:nvector)::level_p"
  write(ilun,format)""
  write(ilun,format)"  ! Overwrite cloud particle mass with sink mass"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     isink=-idp(ind_part(j))"
  write(ilun,format)"     if(isink>0 .and. mp(ind_part(j))>0.)then"
  write(ilun,format)"        mp(ind_part(j))=msink(isink)/dble(ncloud_sink_massive)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! store velocity "
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        new_vp(j,idim)=vp(ind_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Overwrite cloud particle velocity with sink velocity  "
  write(ilun,format)"  ! is going to be overwritten again before move"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        isink=-idp(ind_part(j))"
  write(ilun,format)"        if(isink>0)then"
  write(ilun,format)"              new_vp(j,idim)=vsink(isink,idim)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! write back velocity"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        vp(ind_part(j),idim)=new_vp(j,idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! read level"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     level_p(j)=levelp(ind_part(j))"
  write(ilun,format)"  end do"
  write(ilun,format)" "
  write(ilun,format)"  ! Update position"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        new_xp(j,idim)=xp(ind_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        isink=-idp(ind_part(j))"
  write(ilun,format)"        if(isink>0)then"
  write(ilun,format)"           lev=level_p(j)"
  write(ilun,format)"           new_xp(j,idim)=new_xp(j,idim)+sink_jump(isink,idim,lev)"
  write(ilun,format)"        endif"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)" "
  write(ilun,format)" ! Write back postion"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xp(ind_part(j),idim)=new_xp(j,idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine upd_cloud"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine merge_star_sink"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine merges sink particles for the star formation case if "
  write(ilun,format)"  ! they are too close and one of them is younger than ~1000 years"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::j,isink,jsink,i,nx_loc,mergers"
  write(ilun,format)"  real(dp)::dx_loc,scale,dx_min,rr,rmax2,rmax,mnew,t_larson1"
  write(ilun,format)"  logical::iyoung,jyoung,merge"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp),dimension(1:3)::xcom,vcom,lcom"
  write(ilun,format)""
  write(ilun,format)"  if(nsink==0)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx_loc=0.5D0**nlevelmax"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  rmax=dble(ir_cloud)*dx_min ! Linking length in physical units"
  write(ilun,format)"  rmax2=rmax*rmax"
  write(ilun,format)""
  write(ilun,format)"  !lifetime of first larson core in code units "
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  t_larson1=merging_timescale*365.25*24*3600/scale_t"
  write(ilun,format)""
  write(ilun,format)"  mergers=0"
  write(ilun,format)"  !loop over all possible pairs (n-square, problematic when there are zilions of sinks)"
  write(ilun,format)"  do isink=1,nsink-1"
  write(ilun,format)"     if (msink(isink)>-1.)then"
  write(ilun,format)"        do jsink=isink+1,nsink"
  write(ilun,format)"           iyoung=(t-tsink(isink)<t_larson1)"
  write(ilun,format)"           jyoung=(t-tsink(jsink)<t_larson1)"
  write(ilun,format)""
  write(ilun,format)"           rr=(xsink(isink,1)-xsink(jsink,1))**2&"
  write(ilun,format)"                +(xsink(isink,2)-xsink(jsink,2))**2&"
  write(ilun,format)"                +(xsink(isink,3)-xsink(jsink,3))**2"
  write(ilun,format)"           "
  write(ilun,format)"           merge=(iyoung .or. jyoung).and.rr<rmax2"
  write(ilun,format)"           merge=merge .or. (iyoung .and. jyoung .and. rr<4*rmax2)"
  write(ilun,format)"           merge=merge .and. msink(jsink)>=0"
  write(ilun,format)"           "
  write(ilun,format)""
  write(ilun,format)"           if (merge)then"
  write(ilun,format)"              if (myid==1)write(*,*)'merged ', idsink(jsink),' to ',idsink(isink)"
  write(ilun,format)"              mergers=mergers+1"
  write(ilun,format)"              mnew=msink(isink)+msink(jsink)"
  write(ilun,format)"              ! COM"
  write(ilun,format)"              xcom(1:3)=(msink(isink)*xsink(isink,1:3)+msink(jsink)*xsink(jsink,1:3))/mnew"
  write(ilun,format)"              vcom(1:3)=(msink(isink)*vsink(isink,1:3)+msink(jsink)*vsink(jsink,1:3))/mnew"
  write(ilun,format)"              lcom(1:3)=msink(isink)*cross((xsink(isink,1:3)-xcom(1:3)),vsink(isink,1:3)-vcom(1:3))+ &"
  write(ilun,format)"                & msink(jsink)*cross((xsink(jsink,1:3)-xcom(1:3)),vsink(jsink,1:3)-vcom(1:3))"
  write(ilun,format)""
  write(ilun,format)"              xsink(isink,1:3)=(xsink(isink,1:3)*msink(isink)+xsink(jsink,1:3)*msink(jsink))/mnew"
  write(ilun,format)"              vsink(isink,1:3)=(vsink(isink,1:3)*msink(isink)+vsink(jsink,1:3)*msink(jsink))/mnew"
  write(ilun,format)"              lsink(isink,1:3)=lsink(isink,1:3)+lsink(jsink,1:3)+lcom(1:3)"
  write(ilun,format)"              msink(isink)=mnew"
  write(ilun,format)""
  write(ilun,format)"              acc_rate(isink)=acc_rate(isink)+msink(jsink)"
  write(ilun,format)"              !acc_lum is recomputed anyway before its used"
  write(ilun,format)"              if(ir_feedback)acc_lum(isink)=ir_eff*acc_rate(isink)/dtnew(levelmin)*msink(isink)/(5*6.955d10/scale_l)"
  write(ilun,format)""
  write(ilun,format)"              msink(jsink)=-10."
  write(ilun,format)"              tsink(isink)=min(tsink(isink),tsink(jsink))"
  write(ilun,format)"              idsink(isink)=min(idsink(isink),idsink(jsink))"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if (myid==1 .and. mergers>0)write(*,*)'merged ',mergers,' sinks'"
  write(ilun,format)""
  write(ilun,format)"  i=1"
  write(ilun,format)"  do while (mergers>0)"
  write(ilun,format)""
  write(ilun,format)"     if (msink(i)<-1.)then !if sink has been merged to another one        "
  write(ilun,format)""
  write(ilun,format)"        mergers=mergers-1"
  write(ilun,format)"        nsink=nsink-1"
  write(ilun,format)""
  write(ilun,format)"        !let them all slide back one index"
  write(ilun,format)"        do j=i,nsink"
  write(ilun,format)"           xsink(j,1:3)=xsink(j+1,1:3)"
  write(ilun,format)"           vsink(j,1:3)=vsink(j+1,1:3)"
  write(ilun,format)"           lsink(j,1:3)=lsink(j+1,1:3)"
  write(ilun,format)"           msink(j)=msink(j+1)"
  write(ilun,format)"           mseed(j)=mseed(j+1)"
  write(ilun,format)""
  write(ilun,format)"           !introduced by PH 09/2013 to follow the feedback from the sinks"
  write(ilun,format)"           dmfsink(j)=dmfsink(j+1)"
  write(ilun,format)""
  write(ilun,format)"           new_born(j)=new_born(j+1)"
  write(ilun,format)"           tsink(j)=tsink(j+1)"
  write(ilun,format)"           idsink(j)=idsink(j+1)"
  write(ilun,format)"           acc_rate(j)=acc_rate(j+1)"
  write(ilun,format)"           acc_lum(j)=acc_lum(j+1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        !whipe last position in the sink list"
  write(ilun,format)"        xsink(nsink+1,1:3)=0."
  write(ilun,format)"        vsink(nsink+1,1:3)=0."
  write(ilun,format)"        lsink(nsink+1,1:3)=0."
  write(ilun,format)"        msink(nsink+1)=0."
  write(ilun,format)"        mseed(nsink+1)=0."
  write(ilun,format)""
  write(ilun,format)"        !introduced by PH 09/2013 to follow the feedback from the sinks"
  write(ilun,format)"        dmfsink(nsink+1)=0."
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        new_born(nsink+1)=.false."
  write(ilun,format)"        tsink(nsink+1)=0."
  write(ilun,format)"        idsink(nsink+1)=0"
  write(ilun,format)"        acc_rate(nsink+1)=0."
  write(ilun,format)"        acc_lum(nsink+1)=0."
  write(ilun,format)""
  write(ilun,format)"     else"
  write(ilun,format)"        i=i+1"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine merge_star_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine merge_smbh_sink"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons,ONLY:mass_sph"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine merges sink particles for the smbh formation case if "
  write(ilun,format)"  ! they are too close"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::j,isink,jsink,i,nx_loc,mergers"
  write(ilun,format)"  real(dp)::dx_loc,scale,dx_min,rr,rmax2,rmax,mnew,v1_v2,factG"
  write(ilun,format)"  logical::merge"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp),dimension(1:3)::xcom,vcom,lcom"
  write(ilun,format)""
  write(ilun,format)"  if(nsink==0)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx_loc=0.5D0**nlevelmax"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  rmax=dble(ir_cloud)*dx_min ! Linking length in physical units"
  write(ilun,format)"  rmax2=rmax*rmax"
  write(ilun,format)"  ssoft=sink_soft*dx_min"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  mergers=0"
  write(ilun,format)"  !loop over all possible pairs (n-square, problematic when there are zilions of sinks)"
  write(ilun,format)"  do isink=1,nsink-1"
  write(ilun,format)"     if (msink(isink)>-1)then"
  write(ilun,format)"        do jsink=isink+1,nsink"
  write(ilun,format)"           "
  write(ilun,format)"           ! spacing check"
  write(ilun,format)"           rr=     (xsink(isink,1)-xsink(jsink,1))**2&"
  write(ilun,format)"                & +(xsink(isink,2)-xsink(jsink,2))**2&"
  write(ilun,format)"                & +(xsink(isink,3)-xsink(jsink,3))**2"
  write(ilun,format)"           "
  write(ilun,format)"           merge=rr<4*ssoft**2"
  write(ilun,format)"           merge=merge .and. msink(jsink)>0"
  write(ilun,format)"           "
  write(ilun,format)"           ! escape velocity check"
  write(ilun,format)"           if (mass_merger_vel_check_AGN>0)then"
  write(ilun,format)"              if((msink(isink)+msink(jsink)).ge.mass_merger_vel_check_AGN*2d33/(scale_d*scale_l**3)) then"
  write(ilun,format)"                 v1_v2=(vsink(isink,1)-vsink(jsink,1))**2+(vsink(isink,2)-vsink(jsink,2))**2+(vsink(isink,3)-vsink(jsink,3))**2"
  write(ilun,format)"                 merge=merge .and. 2*factG*(msink(isink)+msink(jsink))/sqrt(rr)>v1_v2"
  write(ilun,format)"              end if"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           if (merge)then"
  write(ilun,format)"              if (myid==1)write(*,*)'merged ', idsink(jsink),' to ',idsink(isink)"
  write(ilun,format)"              mergers=mergers+1"
  write(ilun,format)"              mnew=msink(isink)+msink(jsink)"
  write(ilun,format)"              ! COM"
  write(ilun,format)"              xcom(1:3)=(msink(isink)*xsink(isink,1:3)+msink(jsink)*xsink(jsink,1:3))/mnew"
  write(ilun,format)"              vcom(1:3)=(msink(isink)*vsink(isink,1:3)+msink(jsink)*vsink(jsink,1:3))/mnew"
  write(ilun,format)"              lcom(1:3)=msink(isink)*cross((xsink(isink,1:3)-xcom(1:3)),vsink(isink,1:3)-vcom(1:3))+ &"
  write(ilun,format)"                & msink(jsink)*cross((xsink(jsink,1:3)-xcom(1:3)),vsink(jsink,1:3)-vcom(1:3))"
  write(ilun,format)""
  write(ilun,format)"              xsink(isink,1:3)=(xsink(isink,1:3)*msink(isink)+xsink(jsink,1:3)*msink(jsink))/mnew"
  write(ilun,format)"              vsink(isink,1:3)=(vsink(isink,1:3)*msink(isink)+vsink(jsink,1:3)*msink(jsink))/mnew"
  write(ilun,format)"              lsink(isink,1:3)=lsink(isink,1:3)+lsink(jsink,1:3)+lcom(1:3)"
  write(ilun,format)"              msink(isink)=mnew"
  write(ilun,format)""
  write(ilun,format)"              !introduced by PH 09/2013 to follow the feedback from the sinks"
  write(ilun,format)"              dmfsink(isink)=dmfsink(isink)+dmfsink(jsink)"
  write(ilun,format)""
  write(ilun,format)"              acc_rate(isink)=acc_rate(isink)+acc_rate(jsink)"
  write(ilun,format)"              delta_mass(isink)=delta_mass(isink)+delta_mass(jsink)"
  write(ilun,format)"              !acc_lum is recomputed anyway before its used"
  write(ilun,format)"              if(ir_feedback)acc_lum(isink)=ir_eff*acc_rate(isink)/dtnew(levelmin)*msink(isink)/(5*6.955d10/scale_l)"
  write(ilun,format)""
  write(ilun,format)"              msink(jsink)=-10."
  write(ilun,format)"              tsink(isink)=min(tsink(isink),tsink(jsink))"
  write(ilun,format)"              idsink(isink)=min(idsink(isink),idsink(jsink))"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if (myid==1 .and. mergers>0)write(*,*)'merged ',mergers,' sinks'"
  write(ilun,format)""
  write(ilun,format)"  i=1"
  write(ilun,format)"  do while (mergers>0)"
  write(ilun,format)""
  write(ilun,format)"     if (msink(i)<-1.)then !if sink has been merged to another one        "
  write(ilun,format)""
  write(ilun,format)"        mergers=mergers-1"
  write(ilun,format)"        nsink=nsink-1"
  write(ilun,format)""
  write(ilun,format)"        !let them all slide back one index"
  write(ilun,format)"        do j=i,nsink"
  write(ilun,format)"           xsink(j,1:3)=xsink(j+1,1:3)"
  write(ilun,format)"           vsink(j,1:3)=vsink(j+1,1:3)"
  write(ilun,format)"           lsink(j,1:3)=lsink(j+1,1:3)"
  write(ilun,format)"           msink(j)=msink(j+1)"
  write(ilun,format)"           mseed(j)=mseed(j+1)"
  write(ilun,format)"           new_born(j)=new_born(j+1)"
  write(ilun,format)"           tsink(j)=tsink(j+1)"
  write(ilun,format)"           idsink(j)=idsink(j+1)"
  write(ilun,format)"           acc_rate(j)=acc_rate(j+1)"
  write(ilun,format)"           delta_mass(j)=delta_mass(j+1)"
  write(ilun,format)"           acc_lum(j)=acc_lum(j+1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        !whipe last position in the sink list"
  write(ilun,format)"        xsink(nsink+1,1:3)=0."
  write(ilun,format)"        vsink(nsink+1,1:3)=0."
  write(ilun,format)"        lsink(nsink+1,1:3)=0."
  write(ilun,format)"        msink(nsink+1)=0."
  write(ilun,format)"        mseed(nsink+1)=0."
  write(ilun,format)"        new_born(nsink+1)=.false."
  write(ilun,format)"        tsink(nsink+1)=0."
  write(ilun,format)"        idsink(nsink+1)=0"
  write(ilun,format)"        acc_rate(nsink+1)=0."
  write(ilun,format)"        delta_mass(nsink+1)=0."
  write(ilun,format)"        acc_lum(nsink+1)=0."
  write(ilun,format)""
  write(ilun,format)"     else"
  write(ilun,format)"        i=i+1"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine merge_smbh_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine f_gas_sink(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif "
  write(ilun,format)" integer::ilevel"
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! "
  write(ilun,format)"  ! In this subroutine the sink-gas force contributions are calculated.  "
  write(ilun,format)"  ! A plummer-sphere with radius ssoft is used for softening   "
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! "
  write(ilun,format)"  integer::igrid,ngrid,ncache,i,ind,iskip,ix,iy,iz,isink"
  write(ilun,format)"  integer::info,nx_loc,idim"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc,dx_min,factG"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  "
  write(ilun,format)"  logical ,dimension(1:nvector)::ok"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_cell"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xx,ff"
  write(ilun,format)"  real(dp),dimension(1:nvector)::d2,mcell,denom"
  write(ilun,format)"  real(dp)::rho_tff,rho_tff_tot,d_min"
  write(ilun,format)"  logical,dimension(1:ndim)::period"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  !  Cell spacing at that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  ssoft=sink_soft*dx_min"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid centre"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  rho_tff=0."
  write(ilun,format)""
  write(ilun,format)"  fsink_new=0."
  write(ilun,format)""
  write(ilun,format)"  period(1)=(nx==1)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"  if(ndim>1)period(2)=(ny==1)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  if(ndim>2)period(3)=(nz==1)"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"  ! Loop over sinks "
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     if (direct_force_sink(isink))then"
  write(ilun,format)""
  write(ilun,format)"        d_min=boxlen"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over myid grids by vector sweeps"
  write(ilun,format)"        ncache=active(ilevel)%ngrid"
  write(ilun,format)"        do igrid=1,ncache,nvector"
  write(ilun,format)"           ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Loop over cells"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Check if cell is refined"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Gas and dark matter mass in cell"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 mcell(i)=rho(ind_cell(i))*vol_loc"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Cell center"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    xx(i,idim)=(xg(ind_grid(i),idim)+xc(ind,idim)-skip_loc(idim))*scale"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Relative position and distance"
  write(ilun,format)"              d2=0.d0"
  write(ilun,format)"              do idim=1,ndim    "
  write(ilun,format)"                 if (period(idim))then"
  write(ilun,format)"                    do i=1,ngrid    "
  write(ilun,format)"                       ! zero order Ewald sum"
  write(ilun,format)"                       ff(i,idim)=xsink(isink,idim)-xx(i,idim)"
  write(ilun,format)"                       if(ff(i,idim)>0.5*boxlen)ff(i,idim)=ff(i,idim)-boxlen"
  write(ilun,format)"                       if(ff(i,idim)<-0.5*boxlen)ff(i,idim)=ff(i,idim)+boxlen"
  write(ilun,format)"                       d2(i)=d2(i)+ff(i,idim)**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 else"
  write(ilun,format)"                    do i=1,ngrid"
  write(ilun,format)"                       ff(i,idim)=xsink(isink,idim)-xx(i,idim)"
  write(ilun,format)"                       d2(i)=d2(i)+ff(i,idim)**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Store minimum distance of cell in current level to isink"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 d_min=min(d_min,d2(i))"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Compute sqrt(1/(ssoft**2+d2(i))) to save time"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 denom(i)=(ssoft**2+d2(i))**(-1.5)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Compute gas acceleration due to sink"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ff(i,1:ndim)=denom(i)*ff(i,1:ndim)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Add gas acceleration due to sink"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 f(ind_cell(i),1:ndim)=f(ind_cell(i),1:ndim)+factG*msink(isink)*ff(i,1:ndim)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Add sink acceleration due to gas"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(ok(i))then"
  write(ilun,format)"                    fsink_new(isink,1:ndim)=fsink_new(isink,1:ndim)-factG*mcell(i)*ff(i,1:ndim)"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do !end loop over cells"
  write(ilun,format)"        end do !end loop over grids"
  write(ilun,format)"        "
  write(ilun,format)"        d_min=d_min**0.5"
  write(ilun,format)"        d_min=max(ssoft,d_min)"
  write(ilun,format)"        rho_tff=max(rho_tff,msink(isink)/(4./3.*4.13145*d_min**3))"
  write(ilun,format)""
  write(ilun,format)"     end if !end if direct force"
  write(ilun,format)"  end do !end loop over sinks"
  write(ilun,format)""
  write(ilun,format)"  !collect sink acceleration from cpus"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(fsink_new,fsink_all,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"     fsink_all=fsink_new"
  write(ilun,format)"#endif"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     if (direct_force_sink(isink))then"
  write(ilun,format)"        fsink_partial(isink,1:ndim,ilevel)=fsink_all(isink,1:ndim)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do  "
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     call make_virtual_fine_dp(f(1,idim),ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  "
  write(ilun,format)"  !collect rho due to sinks for current level - used for timestep computation"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(rho_tff,rho_tff_tot,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  rho_tff_tot=rho_tff"
  write(ilun,format)"#endif"
  write(ilun,format)"  rho_sink_tff(ilevel)=rho_tff_tot"
  write(ilun,format)"  "
  write(ilun,format)"  "
  write(ilun,format)"  "
  write(ilun,format)"  if (ilevel==nlevelmax)call make_virtual_fine_dp(phi(1),ilevel)"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine f_gas_sink"
  write(ilun,format)"   "
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine f_sink_sink"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons  "
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"  ! In this subroutine the sink-sink force contribution are calculated by direct"
  write(ilun,format)"  ! n^2 - summation. A plummer-sphere with radius 4 cells is used for softening"
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"  integer::isink,idim,jsink"
  write(ilun,format)"  real(dp),allocatable,dimension(:)::d2"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:)::ff"
  write(ilun,format)"  logical,dimension(1:ndim)::period"
  write(ilun,format)"  real(dp)::factG"
  write(ilun,format)""
  write(ilun,format)"  allocate(d2(1:nsink))"
  write(ilun,format)"  allocate(ff(1:nsink,1:ndim))"
  write(ilun,format)"  "
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"!  fsink=0."
  write(ilun,format)""
  write(ilun,format)"  period(1)=(nx==1)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"  if(ndim>1)period(2)=(ny==1)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  if(ndim>2)period(3)=(nz==1)  "
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     if (direct_force_sink(isink))then"
  write(ilun,format)"        d2=0.d0"
  write(ilun,format)"        ff=0.d0"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           !compute relative position and and distances"
  write(ilun,format)"           if (period(idim))then"
  write(ilun,format)"              do jsink=1,nsink"
  write(ilun,format)"                 if (direct_force_sink(jsink))then           "
  write(ilun,format)"                    ff(jsink,idim)=xsink(jsink,idim)-xsink(isink,idim)"
  write(ilun,format)"                    if(ff(jsink,idim)>0.5*boxlen)ff(jsink,idim)=ff(jsink,idim)-boxlen"
  write(ilun,format)"                    if(ff(jsink,idim)<-0.5*boxlen)ff(jsink,idim)=ff(jsink,idim)+boxlen"
  write(ilun,format)"                    d2(jsink)=d2(jsink)+ff(jsink,idim)**2"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           else"
  write(ilun,format)"              do jsink=1,nsink"
  write(ilun,format)"                 if (direct_force_sink(jsink))then           "
  write(ilun,format)"                    ff(jsink,idim)=xsink(jsink,idim)-xsink(isink,idim)"
  write(ilun,format)"                    d2(jsink)=d2(jsink)+ff(jsink,idim)**2"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        !compute acceleration"
  write(ilun,format)"        do jsink=1,nsink"
  write(ilun,format)"           if (direct_force_sink(jsink))then"
  write(ilun,format)"              ff(jsink,1:ndim)=factG*msink(jsink)/(ssoft**2+d2(jsink))**1.5*ff(jsink,1:ndim)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        do jsink=1,nsink           "
  write(ilun,format)"           fsink(isink,1:ndim)=fsink(isink,1:ndim)+ff(jsink,1:ndim)"
  write(ilun,format)"           if(jsink<0)then"
  write(ilun,format)"              print*,'This is just a stupid trick to prevent'"
  write(ilun,format)"              print*,'the compiler from optimizing this loop!'"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do             "
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"end subroutine f_sink_sink"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine read_sink_params()"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! read sink related parameters and perform some 'sanity chekcs'"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx_min,scale,cty"
  write(ilun,format)"  integer::nx_loc"
  write(ilun,format)"  namelist/sink_params/n_sink,rho_sink,d_sink,accretion_scheme,nol_accretion,merging_timescale,jeans_accretion, &"
  write(ilun,format)"       ir_cloud_massive,sink_soft,mass_sink_direct_force,ir_cloud,nsinkmax,c_acc,create_sinks,mass_sink_seed,&"
  write(ilun,format)"       eddington_limit,sink_drag,acc_sink_boost,mass_merger_vel_check_AGN,&"
  write(ilun,format)"       clump_core,verbose_AGN,T2_AGN,v_AGN,cone_opening,mass_halo_AGN,mass_clump_AGN,feedback_scheme"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)""
  write(ilun,format)"  if(.not.cosmo) call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)  "
  write(ilun,format)""
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale = boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist file "
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=sink_params,END=111)"
  write(ilun,format)"  goto 112"
  write(ilun,format)"111 if(myid==1)write(*,*)'You did not set up &SINK_PARAMS in the namelist file'"
  write(ilun,format)"  if(myid==1)write(*,*)'Using default values '"
  write(ilun,format)"112 rewind(1)"
  write(ilun,format)""
  write(ilun,format)"  if (sink .and. (ndim .ne. 3))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Sink particles are only implemented for 3d sims.'"
  write(ilun,format)"     print*, ndim"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if (sink .and. (nlevelmax==levelmin))then"
  write(ilun,format)"     if(myid==1)write(*,*)'sink particles do currently not work in a single-level cartesian grid'"
  write(ilun,format)"     if(myid==1)write(*,*)'because they need level 1 to be activated.'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"  if (create_sinks .and. accretion_scheme=='none')then"
  write(ilun,format)"     if(myid==1)write(*,*)'formation of new sinks without subsequent accretion is pointless.' "
  write(ilun,format)"     if(myid==1)write(*,*)'Choose accretion_scheme=...!'"
  write(ilun,format)"!     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if ((create_sinks .or. accretion_scheme .ne. 'none') .and. (.not. hydro))then"
  write(ilun,format)"     if(myid==1)write(*,*)'sink creation and accretion require hydro to be turned on'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"  !check for accretion scheme"
  write(ilun,format)"  if (accretion_scheme =='flux')flux_accretion=.true."
  write(ilun,format)"  if (accretion_scheme =='bondi')bondi_accretion=.true."
  write(ilun,format)"  if (accretion_scheme =='threshold')threshold_accretion=.true."
  write(ilun,format)""
  write(ilun,format)"  ! for sink formation and accretion a threshold must be given"
  write(ilun,format)"  if (create_sinks .or. (accretion_scheme .ne. 'none'))then"
  write(ilun,format)""
  write(ilun,format)"     ! check for threshold  "
  write(ilun,format)"     if (.not. cosmo)then"
  write(ilun,format)""
  write(ilun,format)"     if (rho_sink<0. .and. n_sink<0. .and. d_sink>0.) then"
  write(ilun,format)"        if(myid==1)write(*,*)'Found d_sink! Assuming code units'"
  write(ilun,format)"     else if (rho_sink>0. .and. n_sink<0. .and. d_sink<0.)then"
  write(ilun,format)"        if(myid==1)write(*,*)'Found rho_sink! Assuming g/cc'"
  write(ilun,format)"        d_sink=rho_sink/scale_d"
  write(ilun,format)"     else if (rho_sink<0. .and. n_sink>0. .and. d_sink<0.)then"
  write(ilun,format)"        if(myid==1)write(*,*)'Found n_sink! Assuming H/cc'"
  write(ilun,format)"        d_sink=n_sink/scale_nH"
  write(ilun,format)"     else if ((rho_sink>0. .and. n_sink>0.) .or. (rho_sink>0. .and. d_sink>0.) .or. (n_sink>0. .and. d_sink>0.))then"
  write(ilun,format)"        if (myid==1)write(*,*)'Use n_sink [H/cc] OR rho_sink [g/cc] OR d_sink [code_units]'"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"     else"
  write(ilun,format)"        if(myid==1)write(*,*)'Trying to setting sink threshold such that jeans length at '"
  write(ilun,format)"        if(myid==1)write(*,*)'max resolution is resolved by 4 cells, assuming isothermal gas'"
  write(ilun,format)"        if(T2_star==0.)then "
  write(ilun,format)"           if(myid==1)write(*,*)'No value for T2_star given. Do not know what to do...'"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        else"
  write(ilun,format)"           dx_min=0.5**nlevelmax*scale"
  write(ilun,format)"           d_sink=T2_star/scale_T2 *3.14159/16./(dx_min**2)"
  write(ilun,format)"           if(myid==1)write(*,*)'d_sink = ',d_sink"
  write(ilun,format)"           if(myid==1)write(*,*)'rho_sink = ',d_sink*scale_d"
  write(ilun,format)"           if(myid==1)write(*,*)'n_sink = ',d_sink*scale_nH"
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"  if (.not.smbh)then"
  write(ilun,format)"     if (merging_timescale > 0.)then"
  write(ilun,format)"        cty=scale_t/(365.25*24.*3600.)"
  write(ilun,format)"        cont_speed=-1./(merging_timescale/cty)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! nol_accretion requires a somewhat smaller timestep per default"
  write(ilun,format)"  if(c_acc < 0.)then"
  write(ilun,format)"     if (nol_accretion)then"
  write(ilun,format)"        c_acc=0.25"
  write(ilun,format)"     else"
  write(ilun,format)"        c_acc=0.75"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !check for periodic boundary conditions"
  write(ilun,format)"  if (nx==1 .or. ny==1 .or. nz==1)then"
  write(ilun,format)"     if (mass_sink_direct_force .ge. 0.)then"
  write(ilun,format)"        if(myid==1)print*, 'periodic boundaries in combination with '"
  write(ilun,format)"        if(myid==1)print*, 'direct force sinks are not treated accurately....'"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(mass_sink_direct_force<0.)then "
  write(ilun,format)"     mass_sink_direct_force=huge(0._dp)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_sink_params"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine count_clouds(ilevel,action)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use poisson_commons, only:rho"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  character(len=15)::action"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! loop over all sink cloud particles and pass nvector parts to count_clouds_np"
  write(ilun,format)"  ! first pass (action 'count'): count the number of sink cloud parts per cell"
  write(ilun,format)"  ! and store them in flag2"
  write(ilun,format)"  ! second pass (action 'weight'): assign a weight corresponding to the physical"
  write(ilun,format)"  ! volume to each cloud particle. reduce if sinks overlap (flag2 too big)."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,icpu,ind,cell_index"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  "
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if (action=='count')then"
  write(ilun,format)"     ! Loop over cpus"
  write(ilun,format)"     do icpu=1,ncpu"
  write(ilun,format)"        igrid=headl(icpu,ilevel)"
  write(ilun,format)"        ! Loop over grids"
  write(ilun,format)"        do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"           !set flag2 to zero for all cells in the grid"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              cell_index=ncoarse+(ind-1)*ngridmax+igrid"
  write(ilun,format)"              rho(cell_index)=0."
  write(ilun,format)"           end do"
  write(ilun,format)"           igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     igrid=headl(icpu,ilevel)"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)""
  write(ilun,format)"        ! Count sink and cloud particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather sink and cloud particles"
  write(ilun,format)"        if(npart2>0)then        "
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only sink particles"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig   "
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"!                 call count_clouds_np(ind_part,ip,action,ilevel)"
  write(ilun,format)"                 call count_clouds_np(ind_grid,ind_part,ind_grid_part,ig,ip,action,ilevel)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)then"
  write(ilun,format)"!        call count_clouds_np(ind_part,ip,action,ilevel)"
  write(ilun,format)"        call count_clouds_np(ind_grid,ind_part,ind_grid_part,ig,ip,action,ilevel)"
  write(ilun,format)"    end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over cpus"
  write(ilun,format)""
  write(ilun,format)"end subroutine count_clouds"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine count_clouds_np(ind_grid,ind_part,ind_grid_part,ng,np,action,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons, only:uold"
  write(ilun,format)"  use poisson_commons, only:rho"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_part,ind_grid,ind_grid_part"
  write(ilun,format)"  character(len=15)::action"
  write(ilun,format)"  !--------------------------------------------------------------------------------"
  write(ilun,format)"  ! inner loop of count_clouds"
  write(ilun,format)"  !--------------------------------------------------------------------------------  "
  write(ilun,format)"  integer::i,nx_loc,isink,idim,ind"
  write(ilun,format)"  real(dp)::scale,dx_min,weight,parts_per_cell,vol_min"
  write(ilun,format)"  integer,dimension(1:nvector),save::clevl"
  write(ilun,format)"  integer,dimension(1:nvector,1:twotondim),save::cind_part"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xpart"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:twotondim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim),save::vol"
  write(ilun,format)"  logical,dimension(1:nvector,twotondim)::ok"
  write(ilun,format)""
  write(ilun,format)"  ! compute volume of smallest cell"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=(0.5D0**nlevelmax)*scale"
  write(ilun,format)"  vol_min=dx_min**ndim"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,np"
  write(ilun,format)"        xpart(i,idim)=xp(ind_part(i),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"!  call get_cell_index(cind_part,clevl,xpart,nlevelmax,np)"
  write(ilun,format)"!  call get_cell_index_for_particle(cind_part,xx,clevl,ind_grid,xpart,ind_grid_part,ng,np,ilevel,ok)"
  write(ilun,format)"  call cic_get_cells(cind_part,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)""
  write(ilun,format)"!  do i=1,np"
  write(ilun,format)"!     if (cind_part(i).ne.cind_part2(i))print*,'oups at count clouds'"
  write(ilun,format)"!  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!  do i=1,np"
  write(ilun,format)"!     if (clevl(i) .ne. ilevel)then "
  write(ilun,format)"!        write(*,*)'particle outside its level'"
  write(ilun,format)"!        write(*,*)'this should not happen'"
  write(ilun,format)"!     end if"
  write(ilun,format)"!  end do"
  write(ilun,format)""
  write(ilun,format)"  !only particles 'in their level' accrete"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do i=1,np"
  write(ilun,format)"        if(.not. ok(i,ind))then"
  write(ilun,format)"           vol(i,ind)=0."
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  if (action=='count')then"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do i=1,np"
  write(ilun,format)"           rho(cind_part(i,ind))=rho(cind_part(i,ind))+vol(i,ind)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"  ! weight each particle with its actual volume (reduced in the case of overlapping sinks)  "
  write(ilun,format)"  if (action=='weight')then     "
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do i=1,np"
  write(ilun,format)"           isink=-idp(ind_part(i))"
  write(ilun,format)"           parts_per_cell=8*8.**(nlevelmax-ilevel)"
  write(ilun,format)"           weight=vol_min*0.125*vol(i,ind)"
  write(ilun,format)"           if (rho(cind_part(i,ind))>parts_per_cell)then"
  write(ilun,format)"              weight=weight*parts_per_cell/rho(cind_part(i,ind))"
  write(ilun,format)"           end if"
  write(ilun,format)"           weightp(ind_part(i),ind)=weight"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        if(threshold_accretion)then"
  write(ilun,format)"           do i=1,np"
  write(ilun,format)"              if(uold(cind_part(i,ind),1)<d_sink)then"
  write(ilun,format)"                 weightp(ind_part(i),ind)=0."
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine count_clouds_np"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine get_cell_index_for_particle(indp,xx,cell_lev,ind_grid,xpart,ind_grid_part,ng,np,ilevel,ok)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,indp,cell_lev,ind_grid_part"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xpart,xx"
  write(ilun,format)"  logical,dimension(1:nvector)::ok"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! This subroutine finds the leaf cell in which a particle sits "
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::i,j,idim,nx_loc,ind,ix,iy,iz"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,one_over_dx,one_over_scale"
  write(ilun,format)"  ! Grid based arrays"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x0"
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector,1:threetondim),save::nbors_father_cells"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::nbors_father_grids"
  write(ilun,format)"  ! Particle based arrays"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x"
  write(ilun,format)"  integer ,dimension(1:nvector,1:ndim),save::id,igd,icd,icd_fine"
  write(ilun,format)"  integer ,dimension(1:nvector),save::igrid,icell,kg,icell_fine"
  write(ilun,format)"  real(dp),dimension(1:3),save::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3),save::xc"
  write(ilun,format)" "
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  one_over_dx=1./dx"
  write(ilun,format)"  one_over_scale=1./scale"
  write(ilun,format)""
  write(ilun,format)"  ! Cells center position relative to grid center position"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Lower left corner of 3x3x3 grid-cube"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,ng"
  write(ilun,format)"        x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Gather 27 neighboring father cells (should be present anytime !)"
  write(ilun,format)"  do i=1,ng"
  write(ilun,format)"     ind_cell(i)=father(ind_grid(i))"
  write(ilun,format)"  end do"
  write(ilun,format)"  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ng,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  ! Rescale position at level ilevel"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=xpart(j,idim)*one_over_scale+skip_loc(idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)*one_over_dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check for illegal moves"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(x(j,idim)<=0.0D0.or.x(j,idim)>=6.0D0)then"
  write(ilun,format)"           print*,'cpu ', myid, ' hosts an escaped particle'"
  write(ilun,format)"           print*,'x: ',x(j,1:ndim)"
  write(ilun,format)"           print*,'x0: ',x0(ind_grid_part(j),1:ndim)"
  write(ilun,format)"           print*,'xg: ',xg(ind_grid(ind_grid_part(j)),1:ndim)"
  write(ilun,format)"           print*,'xp: ',xpart(j,1:ndim)"
  write(ilun,format)"           print*,'skip_loc: ',skip_loc(1:ndim)"
  write(ilun,format)"           print*,'scale: ',scale"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! NGP at level ilevel"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        id(j,idim)=int(x(j,idim))"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"   ! Compute parent grids"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        igd(j,idim)=id(j,idim)/2"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j)=1+igd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j)=1+igd(j,1)+3*igd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     igrid(j)=son(nbors_father_cells(ind_grid_part(j),kg(j)))"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check if particle has escaped to ilevel-1"
  write(ilun,format)"  ok(1:np)=.true."
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if (igrid(j)==0)then"
  write(ilun,format)"!        print*,'particle has escaped to ilevel-1'"
  write(ilun,format)"        ok(j)=.false."
  write(ilun,format)"        indp(j)=nbors_father_cells(ind_grid_part(j),kg(j))"
  write(ilun,format)"        cell_lev(j)=ilevel-1"
  write(ilun,format)"        xx(j,1:ndim)=(xg(ind_grid(ind_grid_part(j)),1:ndim)+(igd(j,1:ndim)-1.)*2.*dx-skip_loc(1:ndim))*scale"
  write(ilun,format)"        if (sum((xx(j,1:ndim)-xpart(j,1:ndim))**2)**0.5>1.000001*dx_loc*3**0.5)print*,'oups at ilevel-1'"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Compute parent cell position"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"!        if(ok(j))then"
  write(ilun,format)"           icd(j,idim)=id(j,idim)-2*igd(j,idim)"
  write(ilun,format)"!        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"! #if NDIM==1"
  write(ilun,format)"!   do j=1,np"
  write(ilun,format)"!      if(ok(j))then"
  write(ilun,format)"!         icell(j)=1+icd(j,1)"
  write(ilun,format)"!      end if"
  write(ilun,format)"!   end do"
  write(ilun,format)"! #endif"
  write(ilun,format)"! #if NDIM==2"
  write(ilun,format)"!   do j=1,np"
  write(ilun,format)"!      if(ok(j))then"
  write(ilun,format)"!         icell(j)=1+icd(j,1)+2*icd(j,2)"
  write(ilun,format)"!      end if"
  write(ilun,format)"!   end do"
  write(ilun,format)"! #endif"
  write(ilun,format)"!#if NDIM==3"
  write(ilun,format)"!  do j=1,np"
  write(ilun,format)"!     if(ok(j))then"
  write(ilun,format)"!        icell(j)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"!     end if"
  write(ilun,format)"!  end do"
  write(ilun,format)"!#endif"
  write(ilun,format)"        "
  write(ilun,format)"  call geticell(icell,icd,np)"
  write(ilun,format)"  "
  write(ilun,format)"  ! Compute parent cell adress"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if(ok(j))then"
  write(ilun,format)"        indp(j)=ncoarse+(icell(j)-1)*ngridmax+igrid(j)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check if particles have leaked into level ilevel+1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if(ok(j))then"
  write(ilun,format)"        if (son(indp(j))>0)then"
  write(ilun,format)"!           print*,'particle has escaped to ilevel+1'"
  write(ilun,format)"           ok(j)=.false."
  write(ilun,format)"           cell_lev(j)=ilevel+1"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              icd_fine(1,idim)=int(2*(x(j,idim)-int(x(j,idim))))"
  write(ilun,format)"           end do"
  write(ilun,format)"           call geticell(icell_fine,icd_fine,1)"
  write(ilun,format)"           xx(j,1:ndim)=(xg(son(indp(j)),1:ndim)+xc(icell_fine(1),1:ndim)*0.5-skip_loc(1:ndim))*scale"
  write(ilun,format)"           indp(j)=ncoarse+(icell_fine(1)-1)*ngridmax+son(indp(j))"
  write(ilun,format)"           if (sum((xx(j,1:ndim)-xpart(j,1:ndim))**2)**0.5>1.0000001*0.25*dx_loc*3**0.5)then"
  write(ilun,format)"              print*,icd_fine(1,1:ndim)"
  write(ilun,format)"              print*,icell_fine(1)"
  write(ilun,format)"              print*,'oups at ilevel+1'"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !cell center positions for particles which sit in the leve ilevel"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if (ok(j))then"
  write(ilun,format)"        xx(j,1:ndim)=(xg(igrid(j),1:ndim)+xc(icell(j),1:ndim)-skip_loc(1:ndim))*scale"
  write(ilun,format)"        cell_lev(j)=ilevel"
  write(ilun,format)"        ! if (sum((xx(j,1:ndim)-xpart(j,1:ndim))**2)**0.5>1.000001*0.5*dx_loc*3**0.5)then"
  write(ilun,format)"        !    print*,'oups at ilevel'        "
  write(ilun,format)"        !    print*,xpart(j,1:ndim)"
  write(ilun,format)"        !    print*,xx(j,1:ndim)"
  write(ilun,format)"        !    print*,sum((xx(j,1:ndim)-xpart(j,1:ndim))**2)**0.5/dx"
  write(ilun,format)"        ! end if"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine get_cell_index_for_particle"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine geticell(icell,icd,np)"
  write(ilun,format)"  use amr_parameters, only:nvector,ndim"
  write(ilun,format)"  integer::np"
  write(ilun,format)"  integer,dimension(1:nvector,1:ndim)::icd"
  write(ilun,format)"  integer,dimension(1:nvector)::icell"
  write(ilun,format)"  ! mini subroutine that gets the cell index (1 to 8)"
  write(ilun,format)"  ! for certain coordinates (0,1 along each direction)"
  write(ilun,format)"  ! put into a subroutine to make the code look less ugly"
  write(ilun,format)"  integer::j"
  write(ilun,format)"    "
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j)=1+icd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j)=1+icd(j,1)+2*icd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine geticell"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine get_cell_center(xx,index,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp),dimension(1:3)::xx"
  write(ilun,format)"  integer::index,ilevel"
  write(ilun,format)"  ! little helper routine that gets the cell center of a cell with a given index"
  write(ilun,format)"  ! used only for debugging..."
  write(ilun,format)"  integer::ind,ix,iy,iz,i,ind8,grid"
  write(ilun,format)"  real(dp)::dx,scale"
  write(ilun,format)"  real(dp),dimension(1:8,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  integer::nx_loc"
  write(ilun,format)"  dx=0.5D0**ilevel "
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Cells center position relative to grid center position"
  write(ilun,format)"  do ind=1,8  "
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ind8=(index-ncoarse)/ngridmax"
  write(ilun,format)""
  write(ilun,format)"  grid=mod((index-ncoarse),ngridmax)"
  write(ilun,format)"  print*,'ind8',ind8"
  write(ilun,format)"  print*,'grid',grid"
  write(ilun,format)"  print*,'xg',xg(grid,1:3)"
  write(ilun,format)"  print*,'xc',xc(ind8+1,1:3)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  do i=1,3"
  write(ilun,format)"     xx(i)=(xg(grid,i)+xc(ind8+1,i)-skip_loc(i))*scale"
  write(ilun,format)"  end do"
  write(ilun,format)"  print*,'xx',xx(1:3)"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine get_cell_center"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine count_parts"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! ugly routine to count all particles in the simulation level by level"
  write(ilun,format)"  ! used for debugging"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  integer::igrid,jgrid,i,ngrid,ncache"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,npart2_tot,icpu,info"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  integer,dimension(1:nlevelmax)::npts"
  write(ilun,format)""
  write(ilun,format)"  npts=0  "
  write(ilun,format)"  do ilevel=1,nlevelmax"
  write(ilun,format)"     npart2=0"
  write(ilun,format)"     ! Loop over cpus"
  write(ilun,format)"     do icpu=1,ncpu"
  write(ilun,format)"        igrid=headl(icpu,ilevel)"
  write(ilun,format)"        ig=0"
  write(ilun,format)"        ip=0"
  write(ilun,format)"        ! Loop over grids"
  write(ilun,format)"        do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"           npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"           npart2=npart2+npart1"
  write(ilun,format)"           igrid=next(igrid)   ! Go to next grid                                                              "
  write(ilun,format)"        "
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(npart2,npart2_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"     npart2_tot=npart2"
  write(ilun,format)"#endif          "
  write(ilun,format)"     npts(ilevel)=npart2_tot"
  write(ilun,format)"  end do"
  write(ilun,format)"  if (myid==1)print*,'total'"
  write(ilun,format)"  if (myid==1)print*,npts(1:nlevelmax)"
  write(ilun,format)"  "
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)"   npts=0  "
  write(ilun,format)"   do ilevel=1,nlevelmax"
  write(ilun,format)"      npart2=0        "
  write(ilun,format)"      "
  write(ilun,format)"      ncache=active(ilevel)%ngrid"
  write(ilun,format)"      do igrid=1,ncache,nvector"
  write(ilun,format)"         ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"         do i=1,ngrid"
  write(ilun,format)"            ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"         end do"
  write(ilun,format)"         do i=1,ngrid"
  write(ilun,format)"            npart2=npart2+numbp(ind_grid(i))"
  write(ilun,format)"         end do"
  write(ilun,format)"        "
  write(ilun,format)"      end do"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"      call MPI_ALLREDUCE(npart2,npart2_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"      npart2_tot=npart2"
  write(ilun,format)"#endif          "
  write(ilun,format)"      npts(ilevel)=npart2_tot"
  write(ilun,format)"   end do"
  write(ilun,format)"   if (myid==1)print*,'active'"
  write(ilun,format)"   if (myid==1)print*,npts(1:nlevelmax)        "
  write(ilun,format)"   "
  write(ilun,format)"   "
  write(ilun,format)"end subroutine count_parts"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine cic_get_cells(indp,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_grid_part"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xpart"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim)::vol"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim)::indp"
  write(ilun,format)"  logical ,dimension(1:nvector,1:twotondim)::ok"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,twotondim)::xx"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine returns the CIC cells and volumes for np particles."
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  logical::error"
  write(ilun,format)"  integer::i,j,ind,idim,nx_loc,ix,iy,iz"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc"
  write(ilun,format)"  ! Grid-based arrays"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector,1:threetondim),save::nbors_father_cells"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::nbors_father_grids"
  write(ilun,format)"  ! Particle-based arrays"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::mmm"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::ttt=0d0"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::vol2"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x,dd,dg"
  write(ilun,format)"  integer ,dimension(1:nvector,1:ndim),save::ig,id,igg,igd,icg,icd"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::igrid,icell,kg"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x0"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:ndim)::xc"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel "
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"#endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Lower left corner of 3x3x3 grid-cube  do idim=1,ndim"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,ng"
  write(ilun,format)"        x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do i=1,ng"
  write(ilun,format)"     ind_cell(i)=father(ind_grid(i))"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Gather neighboring father cells (should be present anytime !)"
  write(ilun,format)"  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ng,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  ! Rescale particle position at level ilevel"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=xpart(j,idim)/scale+skip_loc(idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)/dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if (x(j,idim)<0.5 .or. x(j,idim)>5.5)then"
  write(ilun,format)"           print*,'particle outside allowed boundary for cic_get_cell'"
  write(ilun,format)"           print*,x(j,1:ndim)"
  write(ilun,format)"           if (x(j,idim)<0. .or. x(j,idim)>6.)then"
  write(ilun,format)"              print*,'particle outside allowed 3by3by3 grid cube'"
  write(ilun,format)"           end if"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! CIC at level ilevel (dd: right cloud boundary; dg: left cloud boundary)"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        dd(j,idim)=x(j,idim)+0.5D0"
  write(ilun,format)"        id(j,idim)=dd(j,idim)"
  write(ilun,format)"        dd(j,idim)=dd(j,idim)-id(j,idim)"
  write(ilun,format)"        dg(j,idim)=1.0D0-dd(j,idim)"
  write(ilun,format)"        ig(j,idim)=id(j,idim)-1"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute cloud volumes"
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     vol(j,1)=dg(j,1)"
  write(ilun,format)"     vol(j,2)=dd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     vol(j,1)=dg(j,1)*dg(j,2)"
  write(ilun,format)"     vol(j,2)=dd(j,1)*dg(j,2)"
  write(ilun,format)"     vol(j,3)=dg(j,1)*dd(j,2)"
  write(ilun,format)"     vol(j,4)=dd(j,1)*dd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     vol(j,1)=dg(j,1)*dg(j,2)*dg(j,3)"
  write(ilun,format)"     vol(j,2)=dd(j,1)*dg(j,2)*dg(j,3)"
  write(ilun,format)"     vol(j,3)=dg(j,1)*dd(j,2)*dg(j,3)"
  write(ilun,format)"     vol(j,4)=dd(j,1)*dd(j,2)*dg(j,3)"
  write(ilun,format)"     vol(j,5)=dg(j,1)*dg(j,2)*dd(j,3)"
  write(ilun,format)"     vol(j,6)=dd(j,1)*dg(j,2)*dd(j,3)"
  write(ilun,format)"     vol(j,7)=dg(j,1)*dd(j,2)*dd(j,3)"
  write(ilun,format)"     vol(j,8)=dd(j,1)*dd(j,2)*dd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"        "
  write(ilun,format)"  ! Compute parent grids"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        igg(j,idim)=ig(j,idim)/2"
  write(ilun,format)"        igd(j,idim)=id(j,idim)/2"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j,1)=1+igg(j,1)"
  write(ilun,format)"     kg(j,2)=1+igd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j,1)=1+igg(j,1)+3*igg(j,2)"
  write(ilun,format)"     kg(j,2)=1+igd(j,1)+3*igg(j,2)"
  write(ilun,format)"     kg(j,3)=1+igg(j,1)+3*igd(j,2)"
  write(ilun,format)"     kg(j,4)=1+igd(j,1)+3*igd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j,1)=1+igg(j,1)+3*igg(j,2)+9*igg(j,3)"
  write(ilun,format)"     kg(j,2)=1+igd(j,1)+3*igg(j,2)+9*igg(j,3)"
  write(ilun,format)"     kg(j,3)=1+igg(j,1)+3*igd(j,2)+9*igg(j,3)"
  write(ilun,format)"     kg(j,4)=1+igd(j,1)+3*igd(j,2)+9*igg(j,3)"
  write(ilun,format)"     kg(j,5)=1+igg(j,1)+3*igg(j,2)+9*igd(j,3)"
  write(ilun,format)"     kg(j,6)=1+igd(j,1)+3*igg(j,2)+9*igd(j,3)"
  write(ilun,format)"     kg(j,7)=1+igg(j,1)+3*igd(j,2)+9*igd(j,3)"
  write(ilun,format)"     kg(j,8)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        igrid(j,ind)=son(nbors_father_cells(ind_grid_part(j),kg(j,ind)))"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Check if particle has escaped to ilevel-1"
  write(ilun,format)"  ok(1:np,1:twotondim)=.true."
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if (igrid(j,ind)==0)then"
  write(ilun,format)"           ! print*,'particle has partially escaped to ilevel-1' "
  write(ilun,format)"           ok(j,ind)=.false."
  write(ilun,format)"           indp(j,ind)=nbors_father_cells(ind_grid_part(j),kg(j,ind))"
  write(ilun,format)"!           xx(j,1:ndim,ind)=(xg(ind_grid(ind_grid_part(j)),1:ndim)+ind3(kg(j,ind),1:ndim)*2.*dx-skip_loc(1:ndim))*scale"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Compute parent cell position"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        icg(j,idim)=ig(j,idim)-2*igg(j,idim)"
  write(ilun,format)"        icd(j,idim)=id(j,idim)-2*igd(j,idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j,1)=1+icg(j,1)"
  write(ilun,format)"     icell(j,2)=1+icd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j,1)=1+icg(j,1)+2*icg(j,2)"
  write(ilun,format)"     icell(j,2)=1+icd(j,1)+2*icg(j,2)"
  write(ilun,format)"     icell(j,3)=1+icg(j,1)+2*icd(j,2)"
  write(ilun,format)"     icell(j,4)=1+icd(j,1)+2*icd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j,1)=1+icg(j,1)+2*icg(j,2)+4*icg(j,3)"
  write(ilun,format)"     icell(j,2)=1+icd(j,1)+2*icg(j,2)+4*icg(j,3)"
  write(ilun,format)"     icell(j,3)=1+icg(j,1)+2*icd(j,2)+4*icg(j,3)"
  write(ilun,format)"     icell(j,4)=1+icd(j,1)+2*icd(j,2)+4*icg(j,3)"
  write(ilun,format)"     icell(j,5)=1+icg(j,1)+2*icg(j,2)+4*icd(j,3)"
  write(ilun,format)"     icell(j,6)=1+icd(j,1)+2*icg(j,2)+4*icd(j,3)"
  write(ilun,format)"     icell(j,7)=1+icg(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"     icell(j,8)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if (ok(j,ind))then"
  write(ilun,format)"           ! Compute parent cell adress for cells in ilevel or ilevel+1"
  write(ilun,format)"           indp(j,ind)=ncoarse+(icell(j,ind)-1)*ngridmax+igrid(j,ind)"
  write(ilun,format)"           ! Check if particles have leaked into level ilevel+1"
  write(ilun,format)"           ! if so, set ok to false, but read values from split cell"
  write(ilun,format)"           ok(j,ind)=(son(indp(j,ind))==0)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if (ok(j,ind))then"
  write(ilun,format)"           xx(j,1:ndim,ind)=(xg(igrid(j,ind),1:ndim)+xc(icell(j,ind),1:ndim)-skip_loc(1:ndim))*scale"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine cic_get_cells"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"subroutine cic_get_vals(fluid_var,ind_grid,xpart,ind_grid_part,ng,np,ilevel,ilevel_only)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  use hydro_commons, ONLY: nvar,uold"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  logical::ilevel_only"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_grid_part"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:nvar+3)::fluid_var"
  write(ilun,format)"#else"
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:nvar)::fluid_var"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:ndim)::xpart"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine returns the CIC cells and volumes for np particles."
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  integer::i,j,ind,ivar"
  write(ilun,format)""
  write(ilun,format)"  ! Particle-based arrays"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::igrid,icell,kg"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x0"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::vol_tot"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:twotondim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim),save::vol"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::indp"
  write(ilun,format)"  logical ,dimension(1:nvector,twotondim),save::ok"
  write(ilun,format)""
  write(ilun,format)"  call cic_get_cells(indp,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  fluid_var(1:np,1:nvar)=0._dp"
  write(ilun,format)""
  write(ilun,format)"  if (ilevel_only)then"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do j=1,np"
  write(ilun,format)"           if(.not. ok(j,ind))vol(j,ind)=0."
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     vol_tot(1:np)=0._dp"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do j=1,np"
  write(ilun,format)"           vol_tot(j)=vol_tot(j)+vol(j,ind)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  do ivar=1,nvar"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do j=1,np"
  write(ilun,format)"           "
  write(ilun,format)"           fluid_var(j,ivar)=fluid_var(j,ivar)&"
  write(ilun,format)"                +uold(indp(j,ind),ivar)*vol(j,ind)        "
  write(ilun,format)"           "
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if (ilevel_only)then"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"        do j=1,np"
  write(ilun,format)"           if (vol_tot(j)>0.)fluid_var(j,ivar)=fluid_var(j,ivar)/vol_tot(j)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)"end subroutine cic_get_vals"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine radiative_feedback_sink(ilevel)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,only: clight"
  write(ilun,format)"  use radiation_parameters,only:stellar_photon"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine performs radiative feedback from the sink. It vectorizes "
  write(ilun,format)"  ! the loop over all sink cloud particles and calls accrete_sink as soon "
  write(ilun,format)"  !as nvector particles are collected"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"!!   integer::igrid,jgrid,ipart,jpart,next_part,info,ix,iy,iz"
  write(ilun,format)"!!   integer::ig,ip,npart1,npart2,icpu,lev,isink,ind"
  write(ilun,format)"!!   integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  integer::isink,ind,ix,iy,iz,ngrid,iskip"
  write(ilun,format)"  integer::i,nx_loc,igrid,ncache,igrp"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_cell"
  write(ilun,format)"  real(dp)::x,y,z,dx,dxx,dyy,dzz,drr,rr,pi"
  write(ilun,format)"  real(dp)::scale,dx_loc,vol_loc,rmax2,rmax"
  write(ilun,format)"  real(dp)::q,h_loc,kernelvalue,weight,radiation_source, Tstar,Lum_group"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  logical ,dimension(1:nvector)::ok"
  write(ilun,format)""
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  "
  write(ilun,format)"  ! Computing local volume (important for averaging hydro quantities) "
  write(ilun,format)"  dx=0.5D0**ilevel "
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)"  rmax = ir_cloud*dx_loc"
  write(ilun,format)"  rmax2=rmax**2"
  write(ilun,format)"  h_loc=rmax/2.0d0"
  write(ilun,format)"  ! Cells center position relative to grid center position"
  write(ilun,format)"  do ind=1,twotondim  "
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Loop over grids"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim  "
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"           ! Flag leaf cells"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(ok(i))then"
  write(ilun,format)"              ! Get gas cell position"
  write(ilun,format)"              x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"              y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"              z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*scale"
  write(ilun,format)"              do isink=1,nsink"
  write(ilun,format)"                 ! Check if the cell lies within the sink radius"
  write(ilun,format)"                 dxx=x-xsink(isink,1)"
  write(ilun,format)"                 if(dxx> 0.5*scale)then"
  write(ilun,format)"                    dxx=dxx-scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(dxx<-0.5*scale)then"
  write(ilun,format)"                    dxx=dxx+scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 dyy=y-xsink(isink,2)"
  write(ilun,format)"                 if(dyy> 0.5*scale)then"
  write(ilun,format)"                    dyy=dyy-scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(dyy<-0.5*scale)then"
  write(ilun,format)"                    dyy=dyy+scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 dzz=z-xsink(isink,3)"
  write(ilun,format)"                 if(dzz> 0.5*scale)then"
  write(ilun,format)"                    dzz=dzz-scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(dzz<-0.5*scale)then"
  write(ilun,format)"                    dzz=dzz+scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 drr=dxx*dxx+dyy*dyy+dzz*dzz"
  write(ilun,format)"                 rr=sqrt(drr)"
  write(ilun,format)"                 "
  write(ilun,format)"                 if(drr.lt.rmax2)then"
  write(ilun,format)"                    q = rr/h_loc"
  write(ilun,format)"                    !              "
  write(ilun,format)"                    ! Spread luminosity using a M4 spline truncated at 2*h_loc"
  write(ilun,format)"                    kernelvalue=0.0d0"
  write(ilun,format)"                    "
  write(ilun,format)"                    if ((q.lt.1.0)) kernelvalue = 1.0d0-1.5d0*q**2+0.75d0*q**3 !=0.25d0*(2.0d0-q)**3-(1.0d0-q)**3"
  write(ilun,format)"                    if ((q.ge.1.0)  .and.(q.lt.2.0)) kernelvalue = 0.25d0*(2.0d0-q)**3"
  write(ilun,format)"                    weight = kernelvalue/(pi*h_loc**3)"
  write(ilun,format)"                    weight =1.0d0 ! bypass wightin. Maybe to be reconsidered..."
  write(ilun,format)"                    Tstar = Teff_sink(isink)"
  write(ilun,format)"                    if(Tstar .gt. 0)then"
  write(ilun,format)"                       if(stellar_photon)then"
  write(ilun,format)"                          igrp=1    ! Put all stellar radiative flux in the first group "
  write(ilun,format)"                          uold(ind_cell(i),5     )=uold(ind_cell(i),5     ) + Lum_sink(isink)*weight*dtnew(ilevel)/((4.0d0*pi*rmax**3)/3.0d0)"
  write(ilun,format)"                          uold(ind_cell(i),8+igrp)=uold(ind_cell(i),8+igrp) + Lum_sink(isink)*weight*dtnew(ilevel)/((4.0d0*pi*rmax**3)/3.0d0)"
  write(ilun,format)"                       else"
  write(ilun,format)"                          do igrp=1,ngrp "
  write(ilun,format)"                             Lum_group = radiation_source(Tstar,igrp)/(scale_d*scale_v**2)*(pi*rsink_star(isink)**2*clight/scale_v)/((4.0d0*pi*rmax**3)/3.0d0)"
  write(ilun,format)"                             uold(ind_cell(i),5     )=uold(ind_cell(i),5     ) + Lum_group*weight*dtnew(ilevel)"
  write(ilun,format)"                             uold(ind_cell(i),8+igrp)=uold(ind_cell(i),8+igrp) + Lum_group*weight*dtnew(ilevel)"
  write(ilun,format)"                          end do"
  write(ilun,format)"                       end if"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 endif"
  write(ilun,format)"                 "
  write(ilun,format)"              end do"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)"111 format('   Entering radiative_feedback_sink for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"  ! Update hydro quantities for split cells"
  write(ilun,format)"  call upload_fine(ilevel)"
  write(ilun,format)"  do igrp=1,nvar"
  write(ilun,format)"     call make_virtual_fine_dp(uold(1,igrp),ilevel)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)"end subroutine radiative_feedback_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"../patch/rt/frig_main/output_amr.f90"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine dump_all"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)""
  write(ilun,format)"  use feedback_module"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  character::nml_char"
  write(ilun,format)"  character(LEN=5)::nchar,ncharcpu"
  write(ilun,format)"  character(LEN=80)::filename,filedir,filedirini,filecmd"
  write(ilun,format)"  integer::i,itest,info,irec,ierr"
  write(ilun,format)""
  write(ilun,format)"  if(nstep_coarse==nstep_coarse_old.and.nstep_coarse>0)return"
  write(ilun,format)"  if(nstep_coarse==0.and.nrestart>0)return"
  write(ilun,format)"  if(verbose)write(*,*)'Entering dump_all'"
  write(ilun,format)""
  write(ilun,format)"  call write_screen"
  write(ilun,format)"  call title(ifout,nchar)"
  write(ilun,format)"  ifout=ifout+1"
  write(ilun,format)"  if(t>=tout(iout).or.aexp>=aout(iout))iout=iout+1"
  write(ilun,format)"  output_done=.true."
  write(ilun,format)"  "
  write(ilun,format)"  if(IOGROUPSIZEREP>0)call title(((myid-1)/IOGROUPSIZEREP)+1,ncharcpu)"
  write(ilun,format)""
  write(ilun,format)"  if(ndim>1)then"
  write(ilun,format)"     if(IOGROUPSIZEREP>0) then"
  write(ilun,format)"        filedirini='output_'//TRIM(nchar)//'/'"
  write(ilun,format)"        filedir='output_'//TRIM(nchar)//'/group_'//TRIM(ncharcpu)//'/'"
  write(ilun,format)"     else"
  write(ilun,format)"        filedir='output_'//TRIM(nchar)//'/'"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     filecmd='mkdir -p '//TRIM(filedir)"
  write(ilun,format)"     "
  write(ilun,format)"     if (.not.withoutmkdir) then "
  write(ilun,format)"#ifdef NOSYSTEM"
  write(ilun,format)"        call PXFMKDIR(TRIM(filedirini),LEN(TRIM(filedirini)),O'755',info)"
  write(ilun,format)"        call PXFMKDIR(TRIM(filedir),LEN(TRIM(filedir)),O'755',info)"
  write(ilun,format)"#else"
  write(ilun,format)"        call EXECUTE_COMMAND_LINE(filecmd,exitstat=ierr,wait=.true.)"
  write(ilun,format)"        if(ierr.ne.0 .and. ierr.ne.127)then"
  write(ilun,format)"           write(*,*) 'Error - Could not create ',trim(filedir),' error code=',ierr"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"           call MPI_ABORT(MPI_COMM_WORLD,1,info)"
  write(ilun,format)"#else"
  write(ilun,format)"           stop"
  write(ilun,format)"#endif"
  write(ilun,format)"        endif"
  write(ilun,format)"#endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     "
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup header'"
  write(ilun,format)"     ! Output header: must be called by each process !"
  write(ilun,format)"     filename=TRIM(filedir)//'header_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"     call output_header(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif     "
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup header'"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup info etc.'"
  write(ilun,format)"     ! Only master process"
  write(ilun,format)"     if(myid==1)then"
  write(ilun,format)"        filename=TRIM(filedir)//'info_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"        call output_info(filename)"
  write(ilun,format)"        filename=TRIM(filedir)//'makefile.txt'"
  write(ilun,format)"!        call output_makefile(filename)"
  write(ilun,format)"        filename=TRIM(filedir)//'patches.txt'"
  write(ilun,format)"!        call output_patch(filename)"
  write(ilun,format)"        if(hydro)then"
  write(ilun,format)"           filename=TRIM(filedir)//'hydro_file_descriptor.txt'"
  write(ilun,format)"           call file_descriptor_hydro(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(cooling .and. .not. neq_chem)then"
  write(ilun,format)"           filename=TRIM(filedir)//'cooling_'//TRIM(nchar)//'.out'"
  write(ilun,format)"           call output_cool(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(sink)then"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.info'"
  write(ilun,format)"           call output_sink(filename)"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.csv'"
  write(ilun,format)"           call output_sink_csv(filename)"
  write(ilun,format)"        endif"
  write(ilun,format)"        ! Copy namelist file to output directory"
  write(ilun,format)"        filename=TRIM(filedir)//'namelist.txt'"
  write(ilun,format)"        OPEN(UNIT=10, FILE=namelist_file, ACCESS='DIRECT', STATUS='OLD', &"
  write(ilun,format)"             & ACTION='READ',  IOSTAT=IERR, RECL=1)"
  write(ilun,format)"        OPEN(UNIT=11, FILE=filename, ACCESS='DIRECT', STATUS='REPLACE', &"
  write(ilun,format)"             & ACTION='WRITE', IOSTAT=IERR, RECL=1)"
  write(ilun,format)"        IREC = 1"
  write(ilun,format)"        DO"
  write(ilun,format)"           READ(UNIT=10, REC=IREC, IOSTAT=IERR)nml_char"
  write(ilun,format)"           IF (IERR.NE.0) EXIT"
  write(ilun,format)"           WRITE(UNIT=11, REC=IREC)nml_char"
  write(ilun,format)"           IREC = IREC + 1"
  write(ilun,format)"        END DO"
  write(ilun,format)"        CLOSE(10)"
  write(ilun,format)"        CLOSE(11)"
  write(ilun,format)"        ! Copy compilation details to output directory"
  write(ilun,format)"        filename=TRIM(filedir)//'compilation.txt'"
  write(ilun,format)"        OPEN(UNIT=11, FILE=filename, FORM='formatted')"
  write(ilun,format)"        write(11,'(' compile date = ',A)')TRIM(builddate)"
  write(ilun,format)"        write(11,'(' patch dir    = ',A)')TRIM(patchdir)"
  write(ilun,format)"        write(11,'(' remote repo  = ',A)')TRIM(gitrepo)"
  write(ilun,format)"        write(11,'(' local branch = ',A)')TRIM(gitbranch)"
  write(ilun,format)"        write(11,'(' last commit  = ',A)')TRIM(githash)"
  write(ilun,format)"        CLOSE(11)"
  write(ilun,format)"     endif"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup info etc.'"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup amr'"
  write(ilun,format)"     filename=TRIM(filedir)//'amr_'//TRIM(nchar)//'.out'"
  write(ilun,format)"     call backup_amr(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup amr'"
  write(ilun,format)""
  write(ilun,format)"     if(hydro)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup hydro'"
  write(ilun,format)"        filename=TRIM(filedir)//'hydro_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_hydro(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup hydro'"
  write(ilun,format)"     end if"
  write(ilun,format)"     "
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(rt.or.neq_chem)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup rt'"
  write(ilun,format)"        filename=TRIM(filedir)//'rt_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call rt_backup_hydro(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup rt'"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)"    "
  write(ilun,format)"     if(pic)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup part'"
  write(ilun,format)"        filename=TRIM(filedir)//'part_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_part(filename)"
  write(ilun,format)"        if(sink)then"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.out'"
  write(ilun,format)"           call backup_sink(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        if(stellar)then"
  write(ilun,format)"           filename=TRIM(filedir)//'stellar_'//TRIM(nchar)//'.out'"
  write(ilun,format)"           call backup_stellar(filename)"
  write(ilun,format)"           filename=TRIM(filedir)//'stellar_'//TRIM(nchar)//'.csv'"
  write(ilun,format)"           call output_stellar_csv(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup part'"
  write(ilun,format)"     end if"
  write(ilun,format)"     "
  write(ilun,format)"     if(poisson)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup poisson'"
  write(ilun,format)"        filename=TRIM(filedir)//'grav_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_poisson(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup poisson'"
  write(ilun,format)"     end if"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"     if(aton)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup rad'"
  write(ilun,format)"        filename=TRIM(filedir)//'rad_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_radiation(filename)"
  write(ilun,format)"        filename=TRIM(filedir)//'radgpu_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call store_radiation(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup rad'"
  write(ilun,format)"     end if"
  write(ilun,format)"#endif"
  write(ilun,format)"     if (gadget_output) then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup gadget format'"
  write(ilun,format)"        filename=TRIM(filedir)//'gsnapshot_'//TRIM(nchar)"
  write(ilun,format)"        call savegadget(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup gadget format'"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine dump_all"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine backup_amr(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::nx_loc,ny_loc,nz_loc,ilun"
  write(ilun,format)"  integer::ilevel,ibound,ncache,istart,i,igrid,idim,ind,iskip"
  write(ilun,format)"  integer,allocatable,dimension(:)::ind_grid,iig"
  write(ilun,format)"  real(dp),allocatable,dimension(:)::xdp"
  write(ilun,format)"  real(sp),allocatable,dimension(:)::xsp"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"  character(LEN=5)::nchar"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::scale"
  write(ilun,format)"  integer,parameter::tag=1120"
  write(ilun,format)"  integer::dummy_io,info2"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering backup_amr'"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=nx; ny_loc=ny; nz_loc=nz"
  write(ilun,format)"  if(ndim>0)nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  if(ndim>1)ny_loc=(jcoarse_max-jcoarse_min+1)"
  write(ilun,format)"  if(ndim>2)nz_loc=(kcoarse_max-kcoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Output amr grid in file"
  write(ilun,format)"  !-----------------------------------  "
  write(ilun,format)"  ilun=myid+10"
  write(ilun,format)"  call title(myid,nchar)"
  write(ilun,format)"  fileloc=TRIM(filename)//TRIM(nchar)"
  write(ilun,format)""
  write(ilun,format)"   ! Wait for the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"           call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag,&"
  write(ilun,format)"                & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  open(unit=ilun,file=fileloc,form='unformatted')"
  write(ilun,format)"  ! Write grid variables"
  write(ilun,format)"  write(ilun)ncpu"
  write(ilun,format)"  write(ilun)ndim"
  write(ilun,format)"  write(ilun)nx,ny,nz"
  write(ilun,format)"  write(ilun)nlevelmax"
  write(ilun,format)"  write(ilun)ngridmax"
  write(ilun,format)"  write(ilun)nboundary"
  write(ilun,format)"  write(ilun)ngrid_current"
  write(ilun,format)"  write(ilun)boxlen"
  write(ilun,format)"  ! Write time variables"
  write(ilun,format)"  write(ilun)noutput,iout,ifout"
  write(ilun,format)"  write(ilun)tout(1:noutput)"
  write(ilun,format)"  write(ilun)aout(1:noutput)"
  write(ilun,format)"  write(ilun)t"
  write(ilun,format)"  write(ilun)dtold(1:nlevelmax)"
  write(ilun,format)"  write(ilun)dtnew(1:nlevelmax)"
  write(ilun,format)"  write(ilun)nstep,nstep_coarse"
  write(ilun,format)"  write(ilun)einit,mass_tot_0,rho_tot"
  write(ilun,format)"  write(ilun)omega_m,omega_l,omega_k,omega_b,h0,aexp_ini,boxlen_ini"
  write(ilun,format)"  write(ilun)aexp,hexp,aexp_old,epot_tot_int,epot_tot_old"
  write(ilun,format)"  write(ilun)mass_sph"
  write(ilun,format)"  ! Write levels variables"
  write(ilun,format)"  write(ilun)headl(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)taill(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)numbl(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)numbtot(1:10,1:nlevelmax)"
  write(ilun,format)"  ! Read boundary linked list"
  write(ilun,format)"  if(simple_boundary)then"
  write(ilun,format)"     write(ilun)headb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"     write(ilun)tailb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"     write(ilun)numbb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"  end if"
  write(ilun,format)"  ! Write free memory"
  write(ilun,format)"  write(ilun)headf,tailf,numbf,used_mem,used_mem_tot"
  write(ilun,format)"  ! Write cpu boundaries"
  write(ilun,format)"  write(ilun)ordering"
  write(ilun,format)"  if(ordering=='bisection') then"
  write(ilun,format)"     write(ilun)bisec_wall(1:nbinodes)"
  write(ilun,format)"     write(ilun)bisec_next(1:nbinodes,1:2)"
  write(ilun,format)"     write(ilun)bisec_indx(1:nbinodes)"
  write(ilun,format)"     write(ilun)bisec_cpubox_min(1:ncpu,1:ndim)"
  write(ilun,format)"     write(ilun)bisec_cpubox_max(1:ncpu,1:ndim)"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun)bound_key(0:ndomain)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Write coarse level"
  write(ilun,format)"  write(ilun)son(1:ncoarse)"
  write(ilun,format)"  write(ilun)flag1(1:ncoarse)"
  write(ilun,format)"  write(ilun)cpu_map(1:ncoarse)"
  write(ilun,format)"  ! Write fine levels"
  write(ilun,format)"  do ilevel=1,nlevelmax"
  write(ilun,format)"     do ibound=1,nboundary+ncpu"
  write(ilun,format)"        if(ibound<=ncpu)then"
  write(ilun,format)"           ncache=numbl(ibound,ilevel)"
  write(ilun,format)"           istart=headl(ibound,ilevel)"
  write(ilun,format)"        else"
  write(ilun,format)"           ncache=numbb(ibound-ncpu,ilevel)"
  write(ilun,format)"           istart=headb(ibound-ncpu,ilevel)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(ncache>0)then"
  write(ilun,format)"           allocate(ind_grid(1:ncache),xdp(1:ncache),iig(1:ncache))"
  write(ilun,format)"           ! Write grid index"
  write(ilun,format)"           igrid=istart"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              ind_grid(i)=igrid"
  write(ilun,format)"              igrid=next(igrid)"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)ind_grid"
  write(ilun,format)"           ! Write next index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=next(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write prev index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=prev(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write grid center"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 xdp(i)=xg(ind_grid(i),idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)xdp"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write father index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=father(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write nbor index"
  write(ilun,format)"           do ind=1,twondim"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=nbor(ind_grid(i),ind)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write son index"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=son(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write cpu map"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=cpu_map(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write refinement map"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=flag1(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           deallocate(xdp,iig,ind_grid)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  close(ilun)"
  write(ilun,format)"   "
  write(ilun,format)"  ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  if(IOGROUPSIZE>0) then"
  write(ilun,format)"     if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"        dummy_io=1"
  write(ilun,format)"        call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag, &"
  write(ilun,format)"             & MPI_COMM_WORLD,info2)"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine backup_amr"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine output_info(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use radiation_parameters,only: mu_gas"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::nx_loc,ny_loc,nz_loc,ilun,icpu,idom,ierr"
  write(ilun,format)"  real(dp)::scale"
  write(ilun,format)"!  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"  character(LEN=5)::nchar"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering output_info'"
  write(ilun,format)""
  write(ilun,format)"  ilun=11"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  !call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=nx; ny_loc=ny; nz_loc=nz"
  write(ilun,format)"  if(ndim>0)nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  if(ndim>1)ny_loc=(jcoarse_max-jcoarse_min+1)"
  write(ilun,format)"  if(ndim>2)nz_loc=(kcoarse_max-kcoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)"  ! Open file"
  write(ilun,format)"  fileloc=TRIM(filename)"
  write(ilun,format)"  open(unit=ilun,file=fileloc,form='formatted',iostat=ierr)"
  write(ilun,format)"  if(ierr .ne. 0)then"
  write(ilun,format)"     write(*,*) 'Error - Could not write ',fileloc"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ABORT(MPI_COMM_WORLD,1,ierr)"
  write(ilun,format)"#else"
  write(ilun,format)"     stop"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"  ! Write run parameters"
  write(ilun,format)"  write(ilun,'('ncpu        =',I11)')ncpu"
  write(ilun,format)"  write(ilun,'('ndim        =',I11)')ndim"
  write(ilun,format)"  write(ilun,'('levelmin    =',I11)')levelmin"
  write(ilun,format)"  write(ilun,'('levelmax    =',I11)')nlevelmax"
  write(ilun,format)"  write(ilun,'('ngridmax    =',I11)')ngridmax"
  write(ilun,format)"  write(ilun,'('nstep_coarse=',I11)')nstep_coarse"
  write(ilun,format)"  write(ilun,*)"
  write(ilun,format)""
  write(ilun,format)"  ! Write physical parameters"
  write(ilun,format)"  write(ilun,'('boxlen      =',E23.15)')scale"
  write(ilun,format)"  write(ilun,'('time        =',E23.15)')t"
  write(ilun,format)"  write(ilun,'('aexp        =',E23.15)')aexp"
  write(ilun,format)"  write(ilun,'('H0          =',E23.15)')h0"
  write(ilun,format)"  write(ilun,'('omega_m     =',E23.15)')omega_m"
  write(ilun,format)"  write(ilun,'('omega_l     =',E23.15)')omega_l"
  write(ilun,format)"  write(ilun,'('omega_k     =',E23.15)')omega_k"
  write(ilun,format)"  write(ilun,'('omega_b     =',E23.15)')omega_b"
  write(ilun,format)"  write(ilun,'('unit_l      =',E23.15)')scale_l"
  write(ilun,format)"  write(ilun,'('unit_d      =',E23.15)')scale_d"
  write(ilun,format)"  write(ilun,'('unit_t      =',E23.15)')scale_t"
  write(ilun,format)"  write(ilun,'('mu_gas      =',E23.15)')mu_gas  "
  write(ilun,format)"  write(ilun,'('ngrp        =',I11)')ngrp"
  write(ilun,format)"  write(ilun,'('nent        =',I11)')nent"
  write(ilun,format)"  write(ilun,'('npscal      =',I11)')npscal"
  write(ilun,format)"  write(ilun,'('nextinct    =',I11)')nextinct"
  write(ilun,format)"  write(ilun,*)"
  write(ilun,format)"  "
  write(ilun,format)"  ! Write ordering information"
  write(ilun,format)"  write(ilun,'('ordering type=',A80)')ordering"
  write(ilun,format)"  if(ordering=='bisection') then"
  write(ilun,format)"     do icpu=1,ncpu"
  write(ilun,format)"        ! write 2*ndim floats for cpu bound box                                                         "
  write(ilun,format)"        write(ilun,'(E23.15)')bisec_cpubox_min(icpu,:),bisec_cpubox_max(icpu,:)"
  write(ilun,format)"        ! write 1 float for cpu load                                                                    "
  write(ilun,format)"        write(ilun,'(E23.15)')dble(bisec_cpu_load(icpu))"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun,'('   DOMAIN   ind_min                 ind_max')')"
  write(ilun,format)"     do idom=1,ndomain"
  write(ilun,format)"        write(ilun,'(I8,1X,E23.15,1X,E23.15)')idom,bound_key(idom-1),bound_key(idom)"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  write(ilun,*)"
  write(ilun,format)"  write(ilun,'('ir_cloud    =',I11)')ir_cloud"
  write(ilun,format)"  if(eos) then"
  write(ilun,format)"     write(ilun,'('eos         =',I11)')1"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun,'('eos         =',I11)')0"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(write_conservative) then"
  write(ilun,format)"     write(ilun,'('write_cons  =',I11)')1"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun,'('write_cons  =',I11)')0"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  close(ilun)"
  write(ilun,format)""
  write(ilun,format)"end subroutine output_info"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine output_header(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::info,ilun"
  write(ilun,format)"  integer(i8b)::tmp_long,npart_tot"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering output_header'"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total number of particles"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  call MPI_ALLREDUCE(npart,npart_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  tmp_long=npart"
  write(ilun,format)"  call MPI_ALLREDUCE(tmp_long,npart_tot,1,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  npart_tot=npart"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)""
  write(ilun,format)"     ilun=myid+10"
  write(ilun,format)""
  write(ilun,format)"     ! Open file"
  write(ilun,format)"     fileloc=TRIM(filename)"
  write(ilun,format)"     open(unit=ilun,file=fileloc,form='formatted')"
  write(ilun,format)"     "
  write(ilun,format)"     ! Write header information"
  write(ilun,format)"     write(ilun,*)'Total number of particles'"
  write(ilun,format)"     write(ilun,*)npart_tot"
  write(ilun,format)"     write(ilun,*)'Total number of dark matter particles'"
  write(ilun,format)"     write(ilun,*)npart_tot-nstar_tot"
  write(ilun,format)"     write(ilun,*)'Total number of star particles'"
  write(ilun,format)"     write(ilun,*)nstar_tot"
  write(ilun,format)"     write(ilun,*)'Total number of sink particles'"
  write(ilun,format)"     write(ilun,*)nsink"
  write(ilun,format)""
  write(ilun,format)"     ! Keep track of what particle fields are present"
  write(ilun,format)"     write(ilun,*)'Particle fields'"
  write(ilun,format)"     write(ilun,'(a)',advance='no')'pos vel mass iord level '"
  write(ilun,format)"#ifdef OUTPUT_PARTICLE_POTENTIAL"
  write(ilun,format)"     write(ilun,'(a)',advance='no')'phi '"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(star.or.sink) then"
  write(ilun,format)"        write(ilun,'(a)',advance='no')'tform '"
  write(ilun,format)"        if(metal) then"
  write(ilun,format)"           write(ilun,'(a)',advance='no')'metal '"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     close(ilun)"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine output_header"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine savegadget(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use gadgetreadfilemod"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)"  TYPE (gadgetheadertype) :: header"
  write(ilun,format)"  real,allocatable,dimension(:,:)::pos, vel"
  write(ilun,format)"  integer(i8b),allocatable,dimension(:)::ids"
  write(ilun,format)"  integer::i, idim, ipart"
  write(ilun,format)"  real:: gadgetvfact"
  write(ilun,format)"  integer::info"
  write(ilun,format)"  integer(i8b)::npart_tot, npart_loc"
  write(ilun,format)"  real, parameter:: RHOcrit = 2.7755d11"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  npart_loc=npart"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_loc,npart_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_loc,npart_tot,1,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#else"
  write(ilun,format)"  npart_tot=npart"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  allocate(pos(ndim, npart), vel(ndim, npart), ids(npart))"
  write(ilun,format)"  gadgetvfact = 100.0 * boxlen_ini / aexp / SQRT(aexp)"
  write(ilun,format)""
  write(ilun,format)"  header%npart = 0"
  write(ilun,format)"  header%npart(2) = npart"
  write(ilun,format)"  header%mass = 0"
  write(ilun,format)"  header%mass(2) = omega_m*RHOcrit*(boxlen_ini)**3/npart_tot/1.d10"
  write(ilun,format)"  header%time = aexp"
  write(ilun,format)"  header%redshift = 1.d0/aexp-1.d0"
  write(ilun,format)"  header%flag_sfr = 0"
  write(ilun,format)"  header%nparttotal = 0"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  header%nparttotal(2) = npart_tot"
  write(ilun,format)"#else"
  write(ilun,format)"  header%nparttotal(2) = MOD(npart_tot,4294967296)"
  write(ilun,format)"#endif"
  write(ilun,format)"  header%flag_cooling = 0"
  write(ilun,format)"  header%numfiles = ncpu"
  write(ilun,format)"  header%boxsize = boxlen_ini"
  write(ilun,format)"  header%omega0 = omega_m"
  write(ilun,format)"  header%omegalambda = omega_l"
  write(ilun,format)"  header%hubbleparam = h0/100.0"
  write(ilun,format)"  header%flag_stellarage = 0"
  write(ilun,format)"  header%flag_metals = 0"
  write(ilun,format)"  header%totalhighword = 0"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  header%totalhighword(2) = 0"
  write(ilun,format)"#else"
  write(ilun,format)"  header%totalhighword(2) = npart_tot/4294967296"
  write(ilun,format)"#endif"
  write(ilun,format)"  header%flag_entropy_instead_u = 0"
  write(ilun,format)"  header%flag_doubleprecision = 0"
  write(ilun,format)"  header%flag_ic_info = 0"
  write(ilun,format)"  header%lpt_scalingfactor = 0"
  write(ilun,format)"  header%unused = ' '"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     ipart=0"
  write(ilun,format)"     do i=1,npartmax"
  write(ilun,format)"        if(levelp(i)>0)then"
  write(ilun,format)"           ipart=ipart+1"
  write(ilun,format)"           if (ipart .gt. npart) then"
  write(ilun,format)"                write(*,*) myid, 'Ipart=',ipart, 'exceeds', npart"
  write(ilun,format)"                call clean_stop"
  write(ilun,format)"           endif"
  write(ilun,format)"           pos(idim, ipart)=xp(i,idim) * boxlen_ini"
  write(ilun,format)"           vel(idim, ipart)=vp(i,idim) * gadgetvfact"
  write(ilun,format)"           if (idim.eq.1) ids(ipart) = idp(i)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  call gadgetwritefile(filename, myid-1, header, pos, vel, ids)"
  write(ilun,format)"  deallocate(pos, vel, ids)"
  write(ilun,format)""
  write(ilun,format)"end subroutine savegadget"
  write(ilun,format)""
  write(ilun,format)"../patch/rt/frig_main/read_params.f90"
  write(ilun,format)"subroutine read_params"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_parameters"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)""
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"  use feedback_module"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  external DDPDD"
  write(ilun,format)"#endif"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Local variables"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  integer::i,narg,iargc,ierr,levelmax"
  write(ilun,format)"  character(LEN=80)::infile, info_file"
  write(ilun,format)"  character(LEN=80)::cmdarg"
  write(ilun,format)"  character(LEN=5)::nchar"
  write(ilun,format)"  integer(kind=8)::ngridtot=0"
  write(ilun,format)"  integer(kind=8)::nparttot=0"
  write(ilun,format)"  real(kind=8)::delta_tout=0,tend=0"
  write(ilun,format)"  real(kind=8)::delta_aout=0,aend=0"
  write(ilun,format)"  logical::nml_ok, info_ok"
  write(ilun,format)"  integer,parameter::tag=1134"
  write(ilun,format)"  integer::dummy_io,info2"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Namelist definitions"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  namelist/run_params/clumpfind,cosmo,pic,sink,lightcone,poisson,hydro,rt,verbose,debug &"
  write(ilun,format)"       & ,nrestart,ncontrol,nstepmax,nsubcycle,nremap,ordering &"
  write(ilun,format)"       & ,bisec_tol,static,geom,overload,cost_weighting,aton,nrestart_quad,restart_remap &"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"       & ,DTU,radiative_nimhdheating &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,static_dm,static_gas,static_stars,convert_birth_times,use_proper_time,remap_pscalar &"
  write(ilun,format)"       & ,FLD,tracer,extinction,stellar &"
  write(ilun,format)"       & ,x_load_balance,y_load_balance,z_load_balance,angular_auto_center,angular_auto_min_rho"
  write(ilun,format)"  namelist/output_params/noutput,foutput,fbackup,aout,tout &"
  write(ilun,format)"       & ,tend,delta_tout,aend,delta_aout,gadget_output,write_conservative"
  write(ilun,format)"  namelist/amr_params/levelmin,levelmax,ngridmax,ngridtot &"
  write(ilun,format)"       & ,npartmax,nparttot,nexpand,boxlen,nlevel_collapse"
  write(ilun,format)"  namelist/poisson_params/epsilon,gravity_type,gravity_params &"
  write(ilun,format)"       & ,cg_levelmin,cic_levelmax"
  write(ilun,format)"  namelist/lightcone_params/thetay_cone,thetaz_cone,zmax_cone"
  write(ilun,format)"  namelist/movie_params/levelmax_frame,nw_frame,nh_frame,ivar_frame &"
  write(ilun,format)"       & ,xcentre_frame,ycentre_frame,zcentre_frame &"
  write(ilun,format)"       & ,deltax_frame,deltay_frame,deltaz_frame,movie,zoom_only_frame &"
  write(ilun,format)"       & ,imovout,imov,tstartmov,astartmov,tendmov,aendmov,proj_axis,movie_vars_txt &"
  write(ilun,format)"       & ,theta_camera,phi_camera,dtheta_camera,dphi_camera,focal_camera,dist_camera,ddist_camera &"
  write(ilun,format)"       & ,perspective_camera,smooth_frame,shader_frame,tstart_theta_camera,tstart_phi_camera &"
  write(ilun,format)"       & ,tend_theta_camera,tend_phi_camera,method_frame,varmin_frame,varmax_frame"
  write(ilun,format)""
  write(ilun,format)"  ! MPI initialization"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_INIT(ierr)"
  write(ilun,format)"  call MPI_COMM_RANK(MPI_COMM_WORLD,myid,ierr)"
  write(ilun,format)"  call MPI_COMM_SIZE(MPI_COMM_WORLD,ncpu,ierr)"
  write(ilun,format)"  myid=myid+1 ! Careful with this..."
  write(ilun,format)"  ! operator MPI_SUMDD is created based on an external function DDPDD."
  write(ilun,format)"  call MPI_OP_CREATE (DDPDD, .TRUE., MPI_SUMDD, ierr)"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  ncpu=1"
  write(ilun,format)"  myid=1"
  write(ilun,format)"#endif"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Advertise RAMSES"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"  write(*,*)'_/_/_/       _/_/     _/    _/    _/_/_/   _/_/_/_/    _/_/_/  '"
  write(ilun,format)"  write(*,*)'_/    _/    _/  _/    _/_/_/_/   _/    _/  _/         _/    _/ '"
  write(ilun,format)"  write(*,*)'_/    _/   _/    _/   _/ _/ _/   _/        _/         _/       '"
  write(ilun,format)"  write(*,*)'_/_/_/     _/_/_/_/   _/    _/     _/_/    _/_/_/       _/_/   '"
  write(ilun,format)"  write(*,*)'_/    _/   _/    _/   _/    _/         _/  _/               _/ '"
  write(ilun,format)"  write(*,*)'_/    _/   _/    _/   _/    _/   _/    _/  _/         _/    _/ '"
  write(ilun,format)"  write(*,*)'_/    _/   _/    _/   _/    _/    _/_/_/   _/_/_/_/    _/_/_/  '"
  write(ilun,format)"  write(*,*)'                        Version 3.0                            '"
  write(ilun,format)"  write(*,*)'       written by Romain Teyssier (University of Zurich)       '"
  write(ilun,format)"  write(*,*)'               (c) CEA 1999-2007, UZH 2008-2014                '"
  write(ilun,format)"  write(*,*)' '"
  write(ilun,format)"  write(*,'(' Working with nproc = ',I4,' for ndim = ',I1)')ncpu,ndim"
  write(ilun,format)"  ! Check nvar is not too small"
  write(ilun,format)"#ifdef SOLVERhydro"
  write(ilun,format)"  write(*,'(' Using solver = hydro with nvar = ',I2)')nvar"
  write(ilun,format)"  if(nvar<ndim+2)then"
  write(ilun,format)"     write(*,*)'You should have: nvar>=ndim+2'"
  write(ilun,format)"     write(*,'(' Please recompile with -DNVAR=',I2)')ndim+2"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  write(*,'(' Using solver = mhd with nvar = ',I2)')nvar"
  write(ilun,format)"  if(nvar<8)then"
  write(ilun,format)"     write(*,*)'You should have: nvar>=8'"
  write(ilun,format)"     write(*,'(' Please recompile with -DNVAR=8')')"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"  !Write I/O group size information"
  write(ilun,format)"  if(IOGROUPSIZE>0.or.IOGROUPSIZECONE>0.or.IOGROUPSIZEREP>0)write(*,*)' '"
  write(ilun,format)"  if(IOGROUPSIZE>0) write(*,*)'IOGROUPSIZE=',IOGROUPSIZE"
  write(ilun,format)"  if(IOGROUPSIZECONE>0) write(*,*)'IOGROUPSIZECONE=',IOGROUPSIZECONE"
  write(ilun,format)"  if(IOGROUPSIZEREP>0) write(*,*)'IOGROUPSIZEREP=',IOGROUPSIZEREP"
  write(ilun,format)"  if(IOGROUPSIZE>0.or.IOGROUPSIZECONE>0.or.IOGROUPSIZEREP>0)write(*,*)' '"
  write(ilun,format)""
  write(ilun,format)"  ! Write information about git version"
  write(ilun,format)"!  call write_gitinfo"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist filename from command line argument"
  write(ilun,format)"  narg = iargc()"
  write(ilun,format)"  IF(narg .LT. 1)THEN"
  write(ilun,format)"     write(*,*)'You should type: ramses3d input.nml [nrestart]'"
  write(ilun,format)"     write(*,*)'File input.nml should contain a parameter namelist'"
  write(ilun,format)"     write(*,*)'nrestart is optional'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  END IF"
  write(ilun,format)"  CALL getarg(1,infile)"
  write(ilun,format)"  endif"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_BCAST(infile,80,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! Read the namelist"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  ! Wait for the token                                                                                                                                                                                "
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"           call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag,&"
  write(ilun,format)"                & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  namelist_file=TRIM(infile)"
  write(ilun,format)"  INQUIRE(file=infile,exist=nml_ok)"
  write(ilun,format)"  if(.not. nml_ok)then"
  write(ilun,format)"     if(myid==1)then"
  write(ilun,format)"        write(*,*)'File '//TRIM(infile)//' does not exist'"
  write(ilun,format)"     endif"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  open(1,file=infile)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=run_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=output_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=amr_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=lightcone_params,END=83)"
  write(ilun,format)"83 continue"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=movie_params,END=82)"
  write(ilun,format)"82 continue"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=poisson_params,END=81)"
  write(ilun,format)"81 continue"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! Read optional nrestart command-line argument"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  if (myid==1 .and. narg == 2) then"
  write(ilun,format)"     CALL getarg(2,cmdarg)"
  write(ilun,format)"     read(cmdarg,*) nrestart"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if (myid==1 .and. nrestart .gt. 0) then"
  write(ilun,format)"     call title(nrestart,nchar)"
  write(ilun,format)"     info_file='output_'//TRIM(nchar)//'/info_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"     inquire(file=info_file, exist=info_ok) "
  write(ilun,format)"     do while(.not. info_ok .and. nrestart .gt. 1)"
  write(ilun,format)"        nrestart = nrestart - 1"
  write(ilun,format)"        call title(nrestart,nchar)"
  write(ilun,format)"        info_file='output_'//TRIM(nchar)//'/info_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"        inquire(file=info_file, exist=info_ok) "
  write(ilun,format)"     enddo   "
  write(ilun,format)"     if (.not. info_ok) then"
  write(ilun,format)"         write(*,*) 'Error: Could not find restart file'"
  write(ilun,format)"         call clean_stop"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_BCAST(nrestart,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! Compute time step for outputs"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  if(tend>0)then"
  write(ilun,format)"     if(delta_tout==0)delta_tout=tend"
  write(ilun,format)"     noutput=MIN(int(tend/delta_tout),MAXOUT)"
  write(ilun,format)"     do i=1,noutput"
  write(ilun,format)"        tout(i)=dble(i)*delta_tout"
  write(ilun,format)"     end do"
  write(ilun,format)"  else if(aend>0)then"
  write(ilun,format)"     if(delta_aout==0)delta_aout=aend"
  write(ilun,format)"     noutput=MIN(int(aend/delta_aout),MAXOUT)"
  write(ilun,format)"     do i=1,noutput"
  write(ilun,format)"        aout(i)=dble(i)*delta_aout"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)"  noutput=MIN(noutput,MAXOUT)"
  write(ilun,format)"  if(imovout>0) then"
  write(ilun,format)"     allocate(tmovout(0:imovout))"
  write(ilun,format)"     allocate(amovout(0:imovout))"
  write(ilun,format)"     tmovout=1d100"
  write(ilun,format)"     amovout=1d100"
  write(ilun,format)"     if(tendmov>0)then"
  write(ilun,format)"        do i=0,imovout"
  write(ilun,format)"           tmovout(i)=(tendmov-tstartmov)*dble(i)/dble(imovout)+tstartmov"
  write(ilun,format)"        enddo"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(aendmov>0)then"
  write(ilun,format)"        do i=0,imovout"
  write(ilun,format)"           amovout(i)=(aendmov-astartmov)*dble(i)/dble(imovout)+astartmov"
  write(ilun,format)"        enddo"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(tendmov==0.and.aendmov==0)movie=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for errors in the namelist so far"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  levelmin=MAX(levelmin,1)"
  write(ilun,format)"  nlevelmax=levelmax"
  write(ilun,format)"  nml_ok=.true."
  write(ilun,format)"  if(levelmin<1)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error in the namelist:'"
  write(ilun,format)"     if(myid==1)write(*,*)'levelmin should not be lower than 1 !!!'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  end if"
  write(ilun,format)"  if(nlevelmax<levelmin)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error in the namelist:'"
  write(ilun,format)"     if(myid==1)write(*,*)'levelmax should not be lower than levelmin'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  end if"
  write(ilun,format)"  if(ngridmax==0)then"
  write(ilun,format)"     if(ngridtot==0)then"
  write(ilun,format)"        if(myid==1)write(*,*)'Error in the namelist:'"
  write(ilun,format)"        if(myid==1)write(*,*)'Allocate some space for refinements !!!'"
  write(ilun,format)"        nml_ok=.false."
  write(ilun,format)"     else"
  write(ilun,format)"        ngridmax=ngridtot/int(ncpu,kind=8)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)"  if(npartmax==0)then"
  write(ilun,format)"     npartmax=nparttot/int(ncpu,kind=8)"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(myid>1)verbose=.false."
  write(ilun,format)"  if(sink.and.(.not.pic))then"
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  endif"
  write(ilun,format)"  !if(clumpfind.and.(.not.pic))then"
  write(ilun,format)"  !   pic=.true."
  write(ilun,format)"  !endif"
  write(ilun,format)"  !if(pic.and.(.not.poisson))then"
  write(ilun,format)"  !   poisson=.true."
  write(ilun,format)"  !endif"
  write(ilun,format)""
  write(ilun,format)"  call read_hydro_params(nml_ok)"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  call rt_read_hydro_params(nml_ok)"
  write(ilun,format)"#endif"
  write(ilun,format)"  if (sink)call read_sink_params"
  write(ilun,format)"  if (clumpfind .or. sink)call read_clumpfind_params"
  write(ilun,format)"  if (movie)call set_movie_vars"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Cloud and feedback parameter "
  write(ilun,format)"  call read_cloud_params(nml_ok)"
  write(ilun,format)"  call read_feedback_params(nml_ok)"
  write(ilun,format)"  "
  write(ilun,format)"  ! Stellar objects"
  write(ilun,format)"  if (stellar)call read_stellar_params"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  close(1)"
  write(ilun,format)""
  write(ilun,format)"  ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  if(IOGROUPSIZE>0) then"
  write(ilun,format)"     if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"        dummy_io=1"
  write(ilun,format)"        call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag, &"
  write(ilun,format)"             & MPI_COMM_WORLD,info2)"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !-----------------"
  write(ilun,format)"  ! Max size checks"
  write(ilun,format)"  !-----------------"
  write(ilun,format)"  if(nlevelmax>MAXLEVEL)then"
  write(ilun,format)"     write(*,*) 'Error: nlevelmax>MAXLEVEL'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  if(nregion>MAXREGION)then"
  write(ilun,format)"     write(*,*) 'Error: nregion>MAXREGION'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Rearrange level dependent arrays"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  do i=nlevelmax,levelmin,-1"
  write(ilun,format)"     nexpand   (i)=nexpand   (i-levelmin+1)"
  write(ilun,format)"     nsubcycle (i)=nsubcycle (i-levelmin+1)"
  write(ilun,format)"     r_refine  (i)=r_refine  (i-levelmin+1)"
  write(ilun,format)"     a_refine  (i)=a_refine  (i-levelmin+1)"
  write(ilun,format)"     b_refine  (i)=b_refine  (i-levelmin+1)"
  write(ilun,format)"     x_refine  (i)=x_refine  (i-levelmin+1)"
  write(ilun,format)"     y_refine  (i)=y_refine  (i-levelmin+1)"
  write(ilun,format)"     z_refine  (i)=z_refine  (i-levelmin+1)"
  write(ilun,format)"     m_refine  (i)=m_refine  (i-levelmin+1)"
  write(ilun,format)"     exp_refine(i)=exp_refine(i-levelmin+1)"
  write(ilun,format)"     initfile  (i)=initfile  (i-levelmin+1)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do i=1,levelmin-1"
  write(ilun,format)"     nexpand   (i)= 1"
  write(ilun,format)"     nsubcycle (i)= 1"
  write(ilun,format)"     r_refine  (i)=-1.0"
  write(ilun,format)"     a_refine  (i)= 1.0"
  write(ilun,format)"     b_refine  (i)= 1.0"
  write(ilun,format)"     x_refine  (i)= 0.0"
  write(ilun,format)"     y_refine  (i)= 0.0"
  write(ilun,format)"     z_refine  (i)= 0.0"
  write(ilun,format)"     m_refine  (i)=-1.0"
  write(ilun,format)"     exp_refine(i)= 2.0"
  write(ilun,format)"     initfile  (i)= ' '"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if(.not.cosmo)then"
  write(ilun,format)"     use_proper_time=.false."
  write(ilun,format)"     convert_birth_times=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"     "
  write(ilun,format)"  if(.not. nml_ok)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Too many errors in the namelist'"
  write(ilun,format)"     if(myid==1)write(*,*)'Aborting...'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_BARRIER(MPI_COMM_WORLD,ierr)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_params"
  write(ilun,format)""
  write(ilun,format)"../patch/rt/frig_main/stellar_particle.f90"
  write(ilun,format)"subroutine read_stellar_params()"
  write(ilun,format)"!    use pm_commons, only: stellar, stellar_msink_th, nstellarmax, sn_direct, &"
  write(ilun,format)"!                        & imf_index, imf_low, imf_high, &"
  write(ilun,format)"!                        & lt_t0, lt_m0, lt_a, lt_b, &"
  write(ilun,format)"!                        & stf_K, stf_m0, stf_a, stf_b, stf_c, &"
  write(ilun,format)"!                        & hii_w, hii_alpha, hii_c, hii_t, hii_T2, &"
  write(ilun,format)"!                        & mH_code"
  write(ilun,format)"    use cooling_module, only: mH"
  write(ilun,format)"    use amr_commons, only: dp, myid"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    use feedback_module"
  write(ilun,format)"    implicit none"
  write(ilun,format)""
  write(ilun,format)"    !------------------------------------------------------------------------"
  write(ilun,format)"    ! Read stellar object related parameters and perform some 'sanity chekcs'"
  write(ilun,format)"    !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"    namelist/stellar_params/ nstellarmax, stellar_msink_th, sn_direct, &"
  write(ilun,format)"                           & imf_index, imf_low, imf_high, &"
  write(ilun,format)"                           & lt_t0, lt_m0, lt_a, lt_b, &"
  write(ilun,format)"                           & stf_K, stf_m0, stf_a, stf_b, stf_c, &"
  write(ilun,format)"                           & hii_w, hii_alpha, hii_c, hii_t, hii_T2 ,sn_feedback_sink,make_stellar_glob"
  write(ilun,format)""
  write(ilun,format)"    real(dp):: scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"    real(dp):: msun, Myr, km_s"
  write(ilun,format)""
  write(ilun,format)"    ! Read namelist file "
  write(ilun,format)"    rewind(1)"
  write(ilun,format)"    read(1, nml=stellar_params, end=111)"
  write(ilun,format)"    rewind(1)"
  write(ilun,format)""
  write(ilun,format)"    if(nstellarmax <= 0) stellar = .false."
  write(ilun,format)""
  write(ilun,format)"    if(.not. stellar) return"
  write(ilun,format)""
  write(ilun,format)"    if(imf_index >= -1.0d0) then"
  write(ilun,format)"        if(myid == 1) write(*, *) 'imf_alpha should be lower than -1'"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"    end if"
  write(ilun,format)""
  write(ilun,format)"    if(imf_low <= 0.0d0 .or. imf_low >= imf_high) then"
  write(ilun,format)"        if(myid == 1) write(*, *) '0 < imf_low < imf_high has to be respected'"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"    end if"
  write(ilun,format)""
  write(ilun,format)"    if(stellar_msink_th <= 0.0d0) then"
  write(ilun,format)"        if(myid == 1) write(*, *) 'stellar_msink_th should be positive'"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"    end if"
  write(ilun,format)""
  write(ilun,format)"    call units(scale_l, scale_t, scale_d, scale_v, scale_nH, scale_T2)"
  write(ilun,format)""
  write(ilun,format)"    ! Convert parameters to code units"
  write(ilun,format)"    msun = 2d33 / scale_d / scale_l**3"
  write(ilun,format)"    Myr = 1d6 * 365.25d0 * 86400d0 / scale_t"
  write(ilun,format)"    km_s = 1d5 / scale_v"
  write(ilun,format)""
  write(ilun,format)"    imf_low = imf_low * msun"
  write(ilun,format)"    imf_high = imf_high * msun"
  write(ilun,format)"    lt_t0 = lt_t0 * Myr"
  write(ilun,format)"    lt_m0 = lt_m0 * msun"
  write(ilun,format)"    stellar_msink_th = stellar_msink_th * msun"
  write(ilun,format)""
  write(ilun,format)"    !Careful : convert the parameter for ionising flux in code units"
  write(ilun,format)"    stf_K = stf_K * scale_t ! K is in s**(-1)"
  write(ilun,format)"    stf_m0 = stf_m0 * msun "
  write(ilun,format)""
  write(ilun,format)"    hii_alpha = hii_alpha / (scale_l**3 / scale_t) ! alpha is in cm**3 / s"
  write(ilun,format)"    hii_c = hii_c * km_s"
  write(ilun,format)""
  write(ilun,format)"    !Careful: normalised age of the time during which the star is emitting HII ionising flux"
  write(ilun,format)"    hii_t = hii_t * Myr "
  write(ilun,format)"    hii_T2 = hii_T2 / scale_T2"
  write(ilun,format)"    mH_code = mH / (scale_d * scale_l**3) ! make this useful..."
  write(ilun,format)""
  write(ilun,format)"111 return"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_stellar_params"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"subroutine make_stellar_from_sinks"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)""
  write(ilun,format)"  use feedback_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  integer:: isink"
  write(ilun,format)"  integer:: idim"
  write(ilun,format)""
  write(ilun,format)"  integer:: nbuf"
  write(ilun,format)"  integer, parameter:: nbufmax = 1000"
  write(ilun,format)"  real(dp), dimension(1:nbufmax, 1:ndim):: buf"
  write(ilun,format)"  integer, dimension(1:nbufmax):: buf_id"
  write(ilun,format)"  logical, dimension(1:nstellarmax):: mark_del"
  write(ilun,format)""
  write(ilun,format)"  if(.not. hydro) return"
  write(ilun,format)"  if(ndim /= 3) return"
  write(ilun,format)""
  write(ilun,format)"  if(verbose) write(*,*) 'Entering make_stellar_from_sinks'"
  write(ilun,format)""
  write(ilun,format)"  nbuf = 0"
  write(ilun,format)"  do isink = 1, nsink"
  write(ilun,format)"    do while(dmfsink(isink) .gt. stellar_msink_th)"
  write(ilun,format)"      dmfsink(isink) = dmfsink(isink) - stellar_msink_th"
  write(ilun,format)""
  write(ilun,format)"      nbuf = nbuf + 1"
  write(ilun,format)"      if(nbuf > nbufmax) then"
  write(ilun,format)"        call create_stellar(nbufmax, nbufmax, buf, buf_id, .true.)"
  write(ilun,format)"        nbuf = 1"
  write(ilun,format)"      end if"
  write(ilun,format)""
  write(ilun,format)"      buf(nbuf, 1:ndim) = xsink(isink, 1:ndim)"
  write(ilun,format)"      buf_id(nbuf) = isink"
  write(ilun,format)""
  write(ilun,format)"    end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  call create_stellar(nbuf, nbufmax, buf, buf_id, .true.)"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_stellar_from_sinks"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!! This routine determines how many new stellar objects must be created by summing all the mass"
  write(ilun,format)"!! within sinks and looking at how many objects have been created already"
  write(ilun,format)"!! It then places them on the sinks which have the largest dmfsink, i.e. recently accreted gas  "
  write(ilun,format)"subroutine make_stellar_from_sinks_glob"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)""
  write(ilun,format)"  use feedback_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  integer:: isink"
  write(ilun,format)"  integer:: idim"
  write(ilun,format)""
  write(ilun,format)"  integer:: nbuf"
  write(ilun,format)"  integer, parameter:: nbufmax = 1000"
  write(ilun,format)"  real(dp), dimension(1:nbufmax, 1:ndim):: buf"
  write(ilun,format)"  integer, dimension(1:nbufmax):: buf_id"
  write(ilun,format)"  logical, dimension(1:nstellarmax):: mark_del"
  write(ilun,format)"  real(dp):: mass_total"
  write(ilun,format)"  integer:: iobj,nobj_new"
  write(ilun,format)"  real(dp), dimension(1:nsink) :: dmfsink_sort"
  write(ilun,format)"!  integer, dimension(1:nsink) :: idsink_sort"
  write(ilun,format)"   "
  write(ilun,format)"  if(.not. hydro) return"
  write(ilun,format)"  if(ndim /= 3) return"
  write(ilun,format)""
  write(ilun,format)"  if(verbose) write(*,*) 'Entering make_stellar_from_sinks'"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !compare the total number of objects formed and the mass of the sinks"
  write(ilun,format)"  mass_total = sum(dmfsink) "
  write(ilun,format)""
  write(ilun,format)"  !number of objects to be created"
  write(ilun,format)"  nobj_new = mass_total / stellar_msink_th"
  write(ilun,format)""
  write(ilun,format)"  !order the sinks by recently accreted mass"
  write(ilun,format)"  dmfsink_sort = dmfsink"
  write(ilun,format)"  call quick_sort_dp(dmfsink_sort,idsink_sort,nsink)"
  write(ilun,format)""
  write(ilun,format)"  !loop over the sinks ranked by recently accreted mass"
  write(ilun,format)"  !one object per sink is assumed"
  write(ilun,format)"  nbuf = 0"
  write(ilun,format)""
  write(ilun,format)"  !this assumes that the number of sinks is larger than the number of objects"
  write(ilun,format)"  if(nobj_new .gt. nsink) then"
  write(ilun,format)"     write(*,*) 'number of new objects is larger than the number of sinks ',nobj_new, nsink"
  write(ilun,format)"     write(*,*) 'use make_stellar_from_sinks instead of make_stellar_from_sinks_glob or modify the code' "
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  do iobj = nsink - nobj_new + 1, nsink"
  write(ilun,format)"      isink = idsink_sort(iobj)"
  write(ilun,format)"      !note with this formulation dmfsink can be negative "
  write(ilun,format)"      dmfsink(isink) = dmfsink(isink) - stellar_msink_th"
  write(ilun,format)""
  write(ilun,format)"      nbuf = nbuf + 1"
  write(ilun,format)"      if(nbuf > nbufmax) then"
  write(ilun,format)"        call create_stellar(nbufmax, nbufmax, buf, buf_id, .true.)"
  write(ilun,format)"        nbuf = 1"
  write(ilun,format)"      end if"
  write(ilun,format)""
  write(ilun,format)"      buf(nbuf, 1:ndim) = xsink(isink, 1:ndim)"
  write(ilun,format)"      buf_id(nbuf) = isink"
  write(ilun,format)"  end do"
  write(ilun,format)"  call create_stellar(nbuf, nbufmax, buf, buf_id, .true.)"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_stellar_from_sinks_glob"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"subroutine create_stellar(ncreate, nbuf, xnew, id_new, print_table)"
  write(ilun,format)"!    use pm_commons, only: stellar, imf_index, imf_low, imf_high, &"
  write(ilun,format)"!                         & lt_t0, lt_m0, lt_a, lt_b, sn_direct, &"
  write(ilun,format)"!                         & nstellarmax, nstellar, stellar_msink_th, &"
  write(ilun,format)"!                         & xstellar, mstellar, tstellar, ltstellar"
  write(ilun,format)"    use amr_commons, only: dp, myid, ncpu, ndim, t"
  write(ilun,format)""
  write(ilun,format)"    use feedback_module"
  write(ilun,format)"    implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"    !------------------------------------------------------------------------"
  write(ilun,format)"    ! Create new stellar objects"
  write(ilun,format)"    !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"    integer, intent(in):: ncreate, nbuf"
  write(ilun,format)"    real(dp), dimension(1:nbuf, 1:ndim), intent(in):: xnew"
  write(ilun,format)"    integer, dimension(1:nbuf), intent(in):: id_new"
  write(ilun,format)"    logical, intent(in):: print_table"
  write(ilun,format)""
  write(ilun,format)"    integer:: ncreate_loc"
  write(ilun,format)"    real(dp), dimension(1:ncreate):: mnew_loc, tnew_loc, ltnew_loc"
  write(ilun,format)"    real(dp), dimension(1:ncreate):: mnew, tnew, ltnew"
  write(ilun,format)"    real(dp), dimension(1:ncreate, 1:ndim):: xnew_loc, xnew2"
  write(ilun,format)"    integer, dimension(1:ncreate):: id_new_loc, id_new2"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    integer:: info, icpu, idim, isplit, nsplit"
  write(ilun,format)"    integer, dimension(1:ncpu):: narr, displ"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"    integer:: istellar"
  write(ilun,format)""
  write(ilun,format)"    if(ncreate == 0) return"
  write(ilun,format)""
  write(ilun,format)"    ! Check that there is enough space"
  write(ilun,format)"    if(ncreate + nstellar > nstellarmax) then"
  write(ilun,format)"        if(myid == 1) write(*, *) 'Not enough space for new stellar objects'"
  write(ilun,format)"        if(myid == 1) write(*, *) 'Increase nstellarmax'"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"    end if"
  write(ilun,format)""
  write(ilun,format)"    ! Split work among processes"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    isplit = mod(ncreate, ncpu)"
  write(ilun,format)"    nsplit = ncreate / ncpu"
  write(ilun,format)"    narr(       1:isplit) = nsplit + 1"
  write(ilun,format)"    narr(isplit+1:  ncpu) = nsplit"
  write(ilun,format)"    displ(1) = 0"
  write(ilun,format)"    do icpu = 2, ncpu"
  write(ilun,format)"        displ(icpu) = displ(icpu - 1) + narr(icpu - 1)"
  write(ilun,format)"    end do"
  write(ilun,format)"    ncreate_loc = narr(myid)"
  write(ilun,format)"#else"
  write(ilun,format)"    ncreate_loc = ncreate"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"    xnew_loc(1:ncreate_loc, 1:ndim) = xnew(displ(myid)+1:displ(myid)+ncreate_loc, 1:ndim)"
  write(ilun,format)""
  write(ilun,format)"    id_new_loc(1:ncreate_loc) = id_new(displ(myid)+1:displ(myid)+ncreate_loc)"
  write(ilun,format)""
  write(ilun,format)"    ! Draw random masses fro the IMF"
  write(ilun,format)"    call sample_powerlaw(mnew_loc, imf_low, imf_high, imf_index, ncreate_loc)"
  write(ilun,format)""
  write(ilun,format)"    ! Set birth time to current time"
  write(ilun,format)"    tnew_loc(1:ncreate_loc) = t"
  write(ilun,format)""
  write(ilun,format)"    ! Compute lifetime"
  write(ilun,format)"    ltnew_loc(1:ncreate_loc) = lt_t0 * exp(lt_a * (log(lt_m0 / mnew_loc))**lt_b)"
  write(ilun,format)""
  write(ilun,format)"    ! Communicate data"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    do idim = 1, ndim"
  write(ilun,format)"        call MPI_ALLGATHERV(xnew_loc(:, idim), ncreate_loc, MPI_DOUBLE_PRECISION, xnew2(:, idim), narr, displ, MPI_DOUBLE_PRECISION, MPI_COMM_WORLD, info)"
  write(ilun,format)"    end do"
  write(ilun,format)"    call MPI_ALLGATHERV(id_new_loc, ncreate_loc, MPI_INTEGER,          id_new2, narr, displ, MPI_INTEGER, MPI_COMM_WORLD, info)"
  write(ilun,format)""
  write(ilun,format)"    call MPI_ALLGATHERV(  mnew_loc, ncreate_loc, MPI_DOUBLE_PRECISION, mnew, narr, displ, MPI_DOUBLE_PRECISION, MPI_COMM_WORLD, info)"
  write(ilun,format)"    call MPI_ALLGATHERV(  tnew_loc, ncreate_loc, MPI_DOUBLE_PRECISION, tnew, narr, displ, MPI_DOUBLE_PRECISION, MPI_COMM_WORLD, info)"
  write(ilun,format)"    call MPI_ALLGATHERV( ltnew_loc, ncreate_loc, MPI_DOUBLE_PRECISION, ltnew, narr, displ, MPI_DOUBLE_PRECISION, MPI_COMM_WORLD, info)"
  write(ilun,format)"#else"
  write(ilun,format)"    mnew = mnew_loc"
  write(ilun,format)"    tnew = tnew_loc"
  write(ilun,format)"    ltnew = ltnew_loc"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"    ! Add new objects to the arrays"
  write(ilun,format)"    xstellar(nstellar+1:nstellar+ncreate, 1:ndim) = xnew2(1:ncreate, 1:ndim)"
  write(ilun,format)"    id_stellar(nstellar+1:nstellar+ncreate) = id_new2(1:ncreate)"
  write(ilun,format)""
  write(ilun,format)"    mstellar(nstellar+1:nstellar+ncreate) = mnew"
  write(ilun,format)"    tstellar(nstellar+1:nstellar+ncreate) = tnew"
  write(ilun,format)"    ltstellar(nstellar+1:nstellar+ncreate) = ltnew"
  write(ilun,format)""
  write(ilun,format)"    if(myid == 1) then"
  write(ilun,format)"        write(*, '('Created ', I5, ' stellar objects:')') ncreate"
  write(ilun,format)"        if(print_table) then"
  write(ilun,format)"            write(*, '('===================================================================================================')')"
  write(ilun,format)"            write(*, '('       x              y              z               Mass          Birth          LifeT       id   ')')"
  write(ilun,format)"            write(*, '('===================================================================================================')')"
  write(ilun,format)"            do istellar = nstellar + 1, nstellar + ncreate"
  write(ilun,format)"                write(*, '(3F15.10, 2X, 3ES15.7,2X,i6)') xstellar(istellar, 1), xstellar(istellar, 2), xstellar(istellar, 3), &"
  write(ilun,format)"                    & mstellar(istellar), tstellar(istellar), ltstellar(istellar), id_stellar(istellar)"
  write(ilun,format)"            end do"
  write(ilun,format)"        end if"
  write(ilun,format)"    end if"
  write(ilun,format)""
  write(ilun,format)"    if(sn_direct) then"
  write(ilun,format)"        ltstellar(nstellar+1:nstellar+ncreate) = 0.0d0"
  write(ilun,format)"    end if"
  write(ilun,format)""
  write(ilun,format)"    nstellar = nstellar + ncreate"
  write(ilun,format)"    nstellar_tot = nstellar_tot + ncreate !total number of created stellar objects"
  write(ilun,format)""
  write(ilun,format)"end subroutine create_stellar"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"subroutine delete_stellar(flag_delete)"
  write(ilun,format)"    use pm_commons"
  write(ilun,format)"    use amr_commons"
  write(ilun,format)""
  write(ilun,format)"    use feedback_module"
  write(ilun,format)"    implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"    !------------------------------------------------------------------------"
  write(ilun,format)"    ! Delete flagged stellar objects"
  write(ilun,format)"    !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"    logical, dimension(1:nstellar), intent(in):: flag_delete"
  write(ilun,format)""
  write(ilun,format)"    integer:: i, inew, info"
  write(ilun,format)"    logical, dimension(1:nstellar):: flag_any"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    ! Make sure every process deletes the same objects"
  write(ilun,format)"    call MPI_ALLREDUCE(flag_delete, flag_any, nstellar, MPI_LOGICAL, MPI_LOR, MPI_COMM_WORLD, info)"
  write(ilun,format)"#else"
  write(ilun,format)"    flag_any = flag_delete"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"    inew = 1"
  write(ilun,format)"    do i = 1, nstellar"
  write(ilun,format)"        if(.not. flag_any(i)) then"
  write(ilun,format)"            if(i > inew) then"
  write(ilun,format)"                xstellar(inew, 1:ndim) = xstellar(i, 1:ndim)"
  write(ilun,format)"                id_stellar(inew) = id_stellar(i)"
  write(ilun,format)"                mstellar(inew) = mstellar(i)"
  write(ilun,format)"                tstellar(inew) = tstellar(i)"
  write(ilun,format)"                ltstellar(inew) = ltstellar(i)"
  write(ilun,format)"            end if"
  write(ilun,format)"            inew = inew + 1"
  write(ilun,format)"        end if"
  write(ilun,format)"    end do"
  write(ilun,format)""
  write(ilun,format)"    ! Update nstellar"
  write(ilun,format)"    nstellar = inew - 1"
  write(ilun,format)""
  write(ilun,format)"end subroutine delete_stellar"
  write(ilun,format)""
  write(ilun,format)"subroutine sample_powerlaw(x, a, b, alpha, n)"
  write(ilun,format)"    ! Sample from a power-law between a and b, with an index of alpha (for the PDF)"
  write(ilun,format)"    use amr_commons"
  write(ilun,format)"    use pm_commons"
  write(ilun,format)"    use random"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    implicit none"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    real(8), dimension(1:n), intent(out):: x"
  write(ilun,format)"    real(8), intent(in):: a, b, alpha"
  write(ilun,format)"    integer, intent(in):: n"
  write(ilun,format)""
  write(ilun,format)"    integer ,dimension(1:ncpu,1:IRandNumSize)::allseed"
  write(ilun,format)""
  write(ilun,format)"    real(8):: u, p, q"
  write(ilun,format)"    integer:: i"
  write(ilun,format)""
  write(ilun,format)"    p = alpha + 1.0_8"
  write(ilun,format)"    q = 1.0_8 / p"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    ! If necessary, initialize random number generator"
  write(ilun,format)"    if(localseed(1)==-1)then"
  write(ilun,format)"      call rans(ncpu,iseed,allseed)"
  write(ilun,format)"      localseed=allseed(myid,1:IRandNumSize)"
  write(ilun,format)"    end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    do i = 1, n"
  write(ilun,format)"        call Ranf( localseed, u )"
  write(ilun,format)""
  write(ilun,format)"        write(*,*) 'random number generated ', u"
  write(ilun,format)"        "
  write(ilun,format)"!        call random_number(u)"
  write(ilun,format)"        ! u follows an uniform law between 0 and 1"
  write(ilun,format)"        ! Scale it to b^p..a^p"
  write(ilun,format)"        u = b**p + (a**p - b**p) * u"
  write(ilun,format)""
  write(ilun,format)"        ! Calculate x(i)"
  write(ilun,format)"        x(i) = u**q"
  write(ilun,format)"    end do"
  write(ilun,format)"end subroutine sample_powerlaw"
  write(ilun,format)"../patch/rt/frig_main/units.f90"
  write(ilun,format)"subroutine units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_t,scale_v,scale_d,scale_l"
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! Conversion factors from user units into cgs units"
  write(ilun,format)"  ! For gravity runs, make sure that G=1 in user units."
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  ! scale_d converts mass density from user units into g/cc"
  write(ilun,format)"  scale_d = units_density"
  write(ilun,format)"  if(cosmo) scale_d = omega_m * rhoc *(h0/100.)**2 / aexp**3"
  write(ilun,format)""
  write(ilun,format)"  ! scale_t converts time from user units into seconds"
  write(ilun,format)"  scale_t = units_time"
  write(ilun,format)"  if(cosmo) scale_t = aexp**2 / (h0*1d5/3.08d24)"
  write(ilun,format)""
  write(ilun,format)"  ! scale_l converts distance from user units into cm"
  write(ilun,format)"  scale_l = units_length"
  write(ilun,format)"  if(cosmo) scale_l = aexp * boxlen_ini * 3.08d24 / (h0/100)"
  write(ilun,format)""
  write(ilun,format)"  ! scale_v converts velocity in user units into cm/s"
  write(ilun,format)"  scale_v = scale_l / scale_t"
  write(ilun,format)""
  write(ilun,format)"  ! scale_T2 converts (P/rho) in user unit into (T/mu) in Kelvin"
  write(ilun,format)"  scale_T2 = mH/kB * scale_v**2"
  write(ilun,format)""
  write(ilun,format)"  ! scale_nH converts rho in user units into nH in H/cc"
  write(ilun,format)"  scale_nH = X/mH * scale_d"
  write(ilun,format)""
  write(ilun,format)"end subroutine units"
  close(ilun)
end subroutine output_patch
